/* soapC.c
   Generated by gSOAP 2.8.10 from quote.h

Copyright(C) 2000-2012, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.10 2015-05-11 05:51:36 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns1__VideoStandard:
		return soap_in_ns1__VideoStandard(soap, NULL, NULL, "ns1:VideoStandard");
	case SOAP_TYPE_ns1__RateType:
		return soap_in_ns1__RateType(soap, NULL, NULL, "ns1:RateType");
	case SOAP_TYPE_ns1__FrameSize:
		return soap_in_ns1__FrameSize(soap, NULL, NULL, "ns1:FrameSize");
	case SOAP_TYPE_ns1__PTZPreset:
		return soap_in_ns1__PTZPreset(soap, NULL, NULL, "ns1:PTZPreset");
	case SOAP_TYPE_ns1__PTZLens:
		return soap_in_ns1__PTZLens(soap, NULL, NULL, "ns1:PTZLens");
	case SOAP_TYPE_ns1__PTZDirection:
		return soap_in_ns1__PTZDirection(soap, NULL, NULL, "ns1:PTZDirection");
	case SOAP_TYPE_ns1__PwdType:
		return soap_in_ns1__PwdType(soap, NULL, NULL, "ns1:PwdType");
	case SOAP_TYPE_ns1__MCUClientType:
		return soap_in_ns1__MCUClientType(soap, NULL, NULL, "ns1:MCUClientType");
	case SOAP_TYPE_ns1__EventState:
		return soap_in_ns1__EventState(soap, NULL, NULL, "ns1:EventState");
	case SOAP_TYPE_ns1__EventType:
		return soap_in_ns1__EventType(soap, NULL, NULL, "ns1:EventType");
	case SOAP_TYPE_ns1__NATType:
		return soap_in_ns1__NATType(soap, NULL, NULL, "ns1:NATType");
	case SOAP_TYPE_ns1__StreamType:
		return soap_in_ns1__StreamType(soap, NULL, NULL, "ns1:StreamType");
	case SOAP_TYPE_ns1__AuxiliaryState:
		return soap_in_ns1__AuxiliaryState(soap, NULL, NULL, "ns1:AuxiliaryState");
	case SOAP_TYPE_ns1__AuxiliaryType:
		return soap_in_ns1__AuxiliaryType(soap, NULL, NULL, "ns1:AuxiliaryType");
	case SOAP_TYPE_ns1__DeliveryType:
		return soap_in_ns1__DeliveryType(soap, NULL, NULL, "ns1:DeliveryType");
	case SOAP_TYPE_ns1__CountryAbbr2ISO3166:
		return soap_in_ns1__CountryAbbr2ISO3166(soap, NULL, NULL, "ns1:CountryAbbr2ISO3166");
	case SOAP_TYPE_ns1__NoticeClassification:
		return soap_in_ns1__NoticeClassification(soap, NULL, NULL, "ns1:NoticeClassification");
	case SOAP_TYPE_ns1__NoticeStatus:
		return soap_in_ns1__NoticeStatus(soap, NULL, NULL, "ns1:NoticeStatus");
	case SOAP_TYPE_ns1__MCUOSType:
		return soap_in_ns1__MCUOSType(soap, NULL, NULL, "ns1:MCUOSType");
	case SOAP_TYPE_ns1__MCUDevType:
		return soap_in_ns1__MCUDevType(soap, NULL, NULL, "ns1:MCUDevType");
	case SOAP_TYPE_ns1__NetType:
		return soap_in_ns1__NetType(soap, NULL, NULL, "ns1:NetType");
	case SOAP_TYPE_ns1__NetworkOperator:
		return soap_in_ns1__NetworkOperator(soap, NULL, NULL, "ns1:NetworkOperator");
	case SOAP_TYPE_ns1__WirelessType:
		return soap_in_ns1__WirelessType(soap, NULL, NULL, "ns1:WirelessType");
	case SOAP_TYPE_ns1__RelayState:
		return soap_in_ns1__RelayState(soap, NULL, NULL, "ns1:RelayState");
	case SOAP_TYPE_ns1__MCUResult:
		return soap_in_ns1__MCUResult(soap, NULL, NULL, "ns1:MCUResult");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__VODRecord:
		return soap_in_ns1__VODRecord(soap, NULL, NULL, "ns1:VODRecord");
	case SOAP_TYPE_ns1__PrivacyMaskRegion:
		return soap_in_ns1__PrivacyMaskRegion(soap, NULL, NULL, "ns1:PrivacyMaskRegion");
	case SOAP_TYPE_ns1__VMDGrid:
		return soap_in_ns1__VMDGrid(soap, NULL, NULL, "ns1:VMDGrid");
	case SOAP_TYPE_ns1__DevLog:
		return soap_in_ns1__DevLog(soap, NULL, NULL, "ns1:DevLog");
	case SOAP_TYPE_ns1__ArrayOfDevLog:
		return soap_in_ns1__ArrayOfDevLog(soap, NULL, NULL, "ns1:ArrayOfDevLog");
	case SOAP_TYPE_ns1__PuLog:
		return soap_in_ns1__PuLog(soap, NULL, NULL, "ns1:PuLog");
	case SOAP_TYPE_ns1__ArrayOfPuLog:
		return soap_in_ns1__ArrayOfPuLog(soap, NULL, NULL, "ns1:ArrayOfPuLog");
	case SOAP_TYPE_ns1__Device:
		return soap_in_ns1__Device(soap, NULL, NULL, "ns1:Device");
	case SOAP_TYPE_ns1__ArrayOfDevice:
		return soap_in_ns1__ArrayOfDevice(soap, NULL, NULL, "ns1:ArrayOfDevice");
	case SOAP_TYPE_ns1__userLoginRes:
		return soap_in_ns1__userLoginRes(soap, NULL, NULL, "ns1:userLoginRes");
	case SOAP_TYPE_ns1__userLoginReq:
		return soap_in_ns1__userLoginReq(soap, NULL, NULL, "ns1:userLoginReq");
	case SOAP_TYPE_ns1__DeviceSharer:
		return soap_in_ns1__DeviceSharer(soap, NULL, NULL, "ns1:DeviceSharer");
	case SOAP_TYPE_ns1__ArrayOfDeviceSharer:
		return soap_in_ns1__ArrayOfDeviceSharer(soap, NULL, NULL, "ns1:ArrayOfDeviceSharer");
	case SOAP_TYPE_ns1__PUEventLog:
		return soap_in_ns1__PUEventLog(soap, NULL, NULL, "ns1:PUEventLog");
	case SOAP_TYPE_ns1__ArrayOfPUEventLog:
		return soap_in_ns1__ArrayOfPUEventLog(soap, NULL, NULL, "ns1:ArrayOfPUEventLog");
	case SOAP_TYPE_ns1__PUOnOffLog:
		return soap_in_ns1__PUOnOffLog(soap, NULL, NULL, "ns1:PUOnOffLog");
	case SOAP_TYPE_ns1__ArrayOfPUOnOffLog:
		return soap_in_ns1__ArrayOfPUOnOffLog(soap, NULL, NULL, "ns1:ArrayOfPUOnOffLog");
	case SOAP_TYPE_ns1__TURNServer:
		return soap_in_ns1__TURNServer(soap, NULL, NULL, "ns1:TURNServer");
	case SOAP_TYPE_ns1__ArrayOfTURNServer:
		return soap_in_ns1__ArrayOfTURNServer(soap, NULL, NULL, "ns1:ArrayOfTURNServer");
	case SOAP_TYPE_ns1__STUNServer:
		return soap_in_ns1__STUNServer(soap, NULL, NULL, "ns1:STUNServer");
	case SOAP_TYPE_ns1__ArrayOfSTUNServer:
		return soap_in_ns1__ArrayOfSTUNServer(soap, NULL, NULL, "ns1:ArrayOfSTUNServer");
	case SOAP_TYPE_ns1__inviteRes:
		return soap_in_ns1__inviteRes(soap, NULL, NULL, "ns1:inviteRes");
	case SOAP_TYPE_ns1__inviteReq:
		return soap_in_ns1__inviteReq(soap, NULL, NULL, "ns1:inviteReq");
	case SOAP_TYPE_ns1__WirelessNetwork:
		return soap_in_ns1__WirelessNetwork(soap, NULL, NULL, "ns1:WirelessNetwork");
	case SOAP_TYPE_ns1__NodeDetails:
		return soap_in_ns1__NodeDetails(soap, NULL, NULL, "ns1:NodeDetails");
	case SOAP_TYPE_ns1__ArrayOfNodeDetails:
		return soap_in_ns1__ArrayOfNodeDetails(soap, NULL, NULL, "ns1:ArrayOfNodeDetails");
	case SOAP_TYPE_ns1__ArrayOfString:
		return soap_in_ns1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__Notice:
		return soap_in_ns1__Notice(soap, NULL, NULL, "ns1:Notice");
	case SOAP_TYPE_ns1__ArrayOfNotice:
		return soap_in_ns1__ArrayOfNotice(soap, NULL, NULL, "ns1:ArrayOfNotice");
	case SOAP_TYPE_ns1__Dev:
		return soap_in_ns1__Dev(soap, NULL, NULL, "ns1:Dev");
	case SOAP_TYPE_ns1__ArrayOfDev:
		return soap_in_ns1__ArrayOfDev(soap, NULL, NULL, "ns1:ArrayOfDev");
	case SOAP_TYPE_ns1__trustedAuthorityLoginRes:
		return soap_in_ns1__trustedAuthorityLoginRes(soap, NULL, NULL, "ns1:trustedAuthorityLoginRes");
	case SOAP_TYPE_ns1__MCUDev:
		return soap_in_ns1__MCUDev(soap, NULL, NULL, "ns1:MCUDev");
	case SOAP_TYPE_ns1__trustedAuthorityLoginReq:
		return soap_in_ns1__trustedAuthorityLoginReq(soap, NULL, NULL, "ns1:trustedAuthorityLoginReq");
	case SOAP_TYPE_ns1__Relay:
		return soap_in_ns1__Relay(soap, NULL, NULL, "ns1:Relay");
	case SOAP_TYPE_ns1__WorkSheet:
		return soap_in_ns1__WorkSheet(soap, NULL, NULL, "ns1:WorkSheet");
	case SOAP_TYPE_PointerTo_ns1__vodSearchRes:
		return soap_in_PointerTo_ns1__vodSearchRes(soap, NULL, NULL, "ns1:vodSearchRes");
	case SOAP_TYPE_PointerTo_ns1__vodSearchReq:
		return soap_in_PointerTo_ns1__vodSearchReq(soap, NULL, NULL, "ns1:vodSearchReq");
	case SOAP_TYPE_PointerTo_ns1__getVODUrlRes:
		return soap_in_PointerTo_ns1__getVODUrlRes(soap, NULL, NULL, "ns1:getVODUrlRes");
	case SOAP_TYPE_PointerTo_ns1__getVODUrlReq:
		return soap_in_PointerTo_ns1__getVODUrlReq(soap, NULL, NULL, "ns1:getVODUrlReq");
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlRes:
		return soap_in_PointerTo_ns1__getPlayUrlRes(soap, NULL, NULL, "ns1:getPlayUrlRes");
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlReq:
		return soap_in_PointerTo_ns1__getPlayUrlReq(soap, NULL, NULL, "ns1:getPlayUrlReq");
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamRes:
		return soap_in_PointerTo_ns1__setPrivacyMaskParamRes(soap, NULL, NULL, "ns1:setPrivacyMaskParamRes");
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamReq:
		return soap_in_PointerTo_ns1__setPrivacyMaskParamReq(soap, NULL, NULL, "ns1:setPrivacyMaskParamReq");
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamRes:
		return soap_in_PointerTo_ns1__getPrivacyMaskParamRes(soap, NULL, NULL, "ns1:getPrivacyMaskParamRes");
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamReq:
		return soap_in_PointerTo_ns1__getPrivacyMaskParamReq(soap, NULL, NULL, "ns1:getPrivacyMaskParamReq");
	case SOAP_TYPE_PointerTo_ns1__setVMDParamRes:
		return soap_in_PointerTo_ns1__setVMDParamRes(soap, NULL, NULL, "ns1:setVMDParamRes");
	case SOAP_TYPE_PointerTo_ns1__setVMDParamReq:
		return soap_in_PointerTo_ns1__setVMDParamReq(soap, NULL, NULL, "ns1:setVMDParamReq");
	case SOAP_TYPE_PointerTo_ns1__getVMDParamRes:
		return soap_in_PointerTo_ns1__getVMDParamRes(soap, NULL, NULL, "ns1:getVMDParamRes");
	case SOAP_TYPE_PointerTo_ns1__getVMDParamReq:
		return soap_in_PointerTo_ns1__getVMDParamReq(soap, NULL, NULL, "ns1:getVMDParamReq");
	case SOAP_TYPE_PointerTo_ns1__setTimeRes:
		return soap_in_PointerTo_ns1__setTimeRes(soap, NULL, NULL, "ns1:setTimeRes");
	case SOAP_TYPE_PointerTo_ns1__setTimeReq:
		return soap_in_PointerTo_ns1__setTimeReq(soap, NULL, NULL, "ns1:setTimeReq");
	case SOAP_TYPE_PointerTo_ns1__getTimeRes:
		return soap_in_PointerTo_ns1__getTimeRes(soap, NULL, NULL, "ns1:getTimeRes");
	case SOAP_TYPE_PointerTo_ns1__getTimeReq:
		return soap_in_PointerTo_ns1__getTimeReq(soap, NULL, NULL, "ns1:getTimeReq");
	case SOAP_TYPE_PointerTo_ns1__setOSDParamRes:
		return soap_in_PointerTo_ns1__setOSDParamRes(soap, NULL, NULL, "ns1:setOSDParamRes");
	case SOAP_TYPE_PointerTo_ns1__setOSDParamReq:
		return soap_in_PointerTo_ns1__setOSDParamReq(soap, NULL, NULL, "ns1:setOSDParamReq");
	case SOAP_TYPE_PointerTo_ns1__getOSDParamRes:
		return soap_in_PointerTo_ns1__getOSDParamRes(soap, NULL, NULL, "ns1:getOSDParamRes");
	case SOAP_TYPE_PointerTo_ns1__getOSDParamReq:
		return soap_in_PointerTo_ns1__getOSDParamReq(soap, NULL, NULL, "ns1:getOSDParamReq");
	case SOAP_TYPE_PointerTo_ns1__setVideoParamRes:
		return soap_in_PointerTo_ns1__setVideoParamRes(soap, NULL, NULL, "ns1:setVideoParamRes");
	case SOAP_TYPE_PointerTo_ns1__setVideoParamReq:
		return soap_in_PointerTo_ns1__setVideoParamReq(soap, NULL, NULL, "ns1:setVideoParamReq");
	case SOAP_TYPE_PointerTo_ns1__getVideoParamRes:
		return soap_in_PointerTo_ns1__getVideoParamRes(soap, NULL, NULL, "ns1:getVideoParamRes");
	case SOAP_TYPE_PointerTo_ns1__getVideoParamReq:
		return soap_in_PointerTo_ns1__getVideoParamReq(soap, NULL, NULL, "ns1:getVideoParamReq");
	case SOAP_TYPE_PointerTo_ns1__queryDevLogRes:
		return soap_in_PointerTo_ns1__queryDevLogRes(soap, NULL, NULL, "ns1:queryDevLogRes");
	case SOAP_TYPE_PointerTo_ns1__queryDevLogReq:
		return soap_in_PointerTo_ns1__queryDevLogReq(soap, NULL, NULL, "ns1:queryDevLogReq");
	case SOAP_TYPE_PointerTo_ns1__queryLogRes:
		return soap_in_PointerTo_ns1__queryLogRes(soap, NULL, NULL, "ns1:queryLogRes");
	case SOAP_TYPE_PointerTo_ns1__queryLogReq:
		return soap_in_PointerTo_ns1__queryLogReq(soap, NULL, NULL, "ns1:queryLogReq");
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerRes:
		return soap_in_PointerTo_ns1__upgradeDevVerRes(soap, NULL, NULL, "ns1:upgradeDevVerRes");
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerReq:
		return soap_in_PointerTo_ns1__upgradeDevVerReq(soap, NULL, NULL, "ns1:upgradeDevVerReq");
	case SOAP_TYPE_PointerTo_ns1__getDevVerRes:
		return soap_in_PointerTo_ns1__getDevVerRes(soap, NULL, NULL, "ns1:getDevVerRes");
	case SOAP_TYPE_PointerTo_ns1__getDevVerReq:
		return soap_in_PointerTo_ns1__getDevVerReq(soap, NULL, NULL, "ns1:getDevVerReq");
	case SOAP_TYPE_PointerTo_ns1__rebootRes:
		return soap_in_PointerTo_ns1__rebootRes(soap, NULL, NULL, "ns1:rebootRes");
	case SOAP_TYPE_PointerTo_ns1__rebootReq:
		return soap_in_PointerTo_ns1__rebootReq(soap, NULL, NULL, "ns1:rebootReq");
	case SOAP_TYPE_PointerTo_ns1__setCodingParamRes:
		return soap_in_PointerTo_ns1__setCodingParamRes(soap, NULL, NULL, "ns1:setCodingParamRes");
	case SOAP_TYPE_PointerTo_ns1__setCodingParamReq:
		return soap_in_PointerTo_ns1__setCodingParamReq(soap, NULL, NULL, "ns1:setCodingParamReq");
	case SOAP_TYPE_PointerTo_ns1__getCodingParamRes:
		return soap_in_PointerTo_ns1__getCodingParamRes(soap, NULL, NULL, "ns1:getCodingParamRes");
	case SOAP_TYPE_PointerTo_ns1__getCodingParamReq:
		return soap_in_PointerTo_ns1__getCodingParamReq(soap, NULL, NULL, "ns1:getCodingParamReq");
	case SOAP_TYPE_PointerTo_ns1__presetControlRes:
		return soap_in_PointerTo_ns1__presetControlRes(soap, NULL, NULL, "ns1:presetControlRes");
	case SOAP_TYPE_PointerTo_ns1__presetControlReq:
		return soap_in_PointerTo_ns1__presetControlReq(soap, NULL, NULL, "ns1:presetControlReq");
	case SOAP_TYPE_PointerTo_ns1__lensControlRes:
		return soap_in_PointerTo_ns1__lensControlRes(soap, NULL, NULL, "ns1:lensControlRes");
	case SOAP_TYPE_PointerTo_ns1__lensControlReq:
		return soap_in_PointerTo_ns1__lensControlReq(soap, NULL, NULL, "ns1:lensControlReq");
	case SOAP_TYPE_PointerTo_ns1__ptzControlRes:
		return soap_in_PointerTo_ns1__ptzControlRes(soap, NULL, NULL, "ns1:ptzControlRes");
	case SOAP_TYPE_PointerTo_ns1__ptzControlReq:
		return soap_in_PointerTo_ns1__ptzControlReq(soap, NULL, NULL, "ns1:ptzControlReq");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceRes:
		return soap_in_PointerTo_ns1__nullifyDeviceRes(soap, NULL, NULL, "ns1:nullifyDeviceRes");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceReq:
		return soap_in_PointerTo_ns1__nullifyDeviceReq(soap, NULL, NULL, "ns1:nullifyDeviceReq");
	case SOAP_TYPE_PointerTo_ns1__addDeviceRes:
		return soap_in_PointerTo_ns1__addDeviceRes(soap, NULL, NULL, "ns1:addDeviceRes");
	case SOAP_TYPE_PointerTo_ns1__addDeviceReq:
		return soap_in_PointerTo_ns1__addDeviceReq(soap, NULL, NULL, "ns1:addDeviceReq");
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameRes:
		return soap_in_PointerTo_ns1__updateChannelNameRes(soap, NULL, NULL, "ns1:updateChannelNameRes");
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameReq:
		return soap_in_PointerTo_ns1__updateChannelNameReq(soap, NULL, NULL, "ns1:updateChannelNameReq");
	case SOAP_TYPE_PointerTo_ns1__userLogoutRes:
		return soap_in_PointerTo_ns1__userLogoutRes(soap, NULL, NULL, "ns1:userLogoutRes");
	case SOAP_TYPE_PointerTo_ns1__userLogoutReq:
		return soap_in_PointerTo_ns1__userLogoutReq(soap, NULL, NULL, "ns1:userLogoutReq");
	case SOAP_TYPE_PointerTons1__userLoginRes:
		return soap_in_PointerTons1__userLoginRes(soap, NULL, NULL, "ns1:userLoginRes");
	case SOAP_TYPE_PointerTons1__userLoginReq:
		return soap_in_PointerTons1__userLoginReq(soap, NULL, NULL, "ns1:userLoginReq");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceBondedRes:
		return soap_in_PointerTo_ns1__queryDeviceBondedRes(soap, NULL, NULL, "ns1:queryDeviceBondedRes");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceBondedReq:
		return soap_in_PointerTo_ns1__queryDeviceBondedReq(soap, NULL, NULL, "ns1:queryDeviceBondedReq");
	case SOAP_TYPE_PointerTo_ns1__queryClientVersionRes:
		return soap_in_PointerTo_ns1__queryClientVersionRes(soap, NULL, NULL, "ns1:queryClientVersionRes");
	case SOAP_TYPE_PointerTo_ns1__queryClientVersionReq:
		return soap_in_PointerTo_ns1__queryClientVersionReq(soap, NULL, NULL, "ns1:queryClientVersionReq");
	case SOAP_TYPE_PointerTo_ns1__queryAndroidTokenRes:
		return soap_in_PointerTo_ns1__queryAndroidTokenRes(soap, NULL, NULL, "ns1:queryAndroidTokenRes");
	case SOAP_TYPE_PointerTo_ns1__queryAndroidTokenReq:
		return soap_in_PointerTo_ns1__queryAndroidTokenReq(soap, NULL, NULL, "ns1:queryAndroidTokenReq");
	case SOAP_TYPE_PointerTo_ns1__queryAppleTokenRes:
		return soap_in_PointerTo_ns1__queryAppleTokenRes(soap, NULL, NULL, "ns1:queryAppleTokenRes");
	case SOAP_TYPE_PointerTo_ns1__queryAppleTokenReq:
		return soap_in_PointerTo_ns1__queryAppleTokenReq(soap, NULL, NULL, "ns1:queryAppleTokenReq");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceSharingSourceRes:
		return soap_in_PointerTo_ns1__queryDeviceSharingSourceRes(soap, NULL, NULL, "ns1:queryDeviceSharingSourceRes");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceSharingSourceReq:
		return soap_in_PointerTo_ns1__queryDeviceSharingSourceReq(soap, NULL, NULL, "ns1:queryDeviceSharingSourceReq");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceSharerRes:
		return soap_in_PointerTo_ns1__queryDeviceSharerRes(soap, NULL, NULL, "ns1:queryDeviceSharerRes");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceSharerReq:
		return soap_in_PointerTo_ns1__queryDeviceSharerReq(soap, NULL, NULL, "ns1:queryDeviceSharerReq");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceSharerRes:
		return soap_in_PointerTo_ns1__nullifyDeviceSharerRes(soap, NULL, NULL, "ns1:nullifyDeviceSharerRes");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceSharerReq:
		return soap_in_PointerTo_ns1__nullifyDeviceSharerReq(soap, NULL, NULL, "ns1:nullifyDeviceSharerReq");
	case SOAP_TYPE_PointerTo_ns1__addDeviceSharerRes:
		return soap_in_PointerTo_ns1__addDeviceSharerRes(soap, NULL, NULL, "ns1:addDeviceSharerRes");
	case SOAP_TYPE_PointerTo_ns1__addDeviceSharerReq:
		return soap_in_PointerTo_ns1__addDeviceSharerReq(soap, NULL, NULL, "ns1:addDeviceSharerReq");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceStatusRes:
		return soap_in_PointerTo_ns1__queryDeviceStatusRes(soap, NULL, NULL, "ns1:queryDeviceStatusRes");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceStatusReq:
		return soap_in_PointerTo_ns1__queryDeviceStatusReq(soap, NULL, NULL, "ns1:queryDeviceStatusReq");
	case SOAP_TYPE_PointerTo_ns1__updateAndroidTokenRes:
		return soap_in_PointerTo_ns1__updateAndroidTokenRes(soap, NULL, NULL, "ns1:updateAndroidTokenRes");
	case SOAP_TYPE_PointerTo_ns1__updateAndroidTokenReq:
		return soap_in_PointerTo_ns1__updateAndroidTokenReq(soap, NULL, NULL, "ns1:updateAndroidTokenReq");
	case SOAP_TYPE_PointerTo_ns1__queryPUEventLogRes:
		return soap_in_PointerTo_ns1__queryPUEventLogRes(soap, NULL, NULL, "ns1:queryPUEventLogRes");
	case SOAP_TYPE_PointerTo_ns1__queryPUEventLogReq:
		return soap_in_PointerTo_ns1__queryPUEventLogReq(soap, NULL, NULL, "ns1:queryPUEventLogReq");
	case SOAP_TYPE_PointerTo_ns1__queryPUOnOffLogRes:
		return soap_in_PointerTo_ns1__queryPUOnOffLogRes(soap, NULL, NULL, "ns1:queryPUOnOffLogRes");
	case SOAP_TYPE_PointerTo_ns1__queryPUOnOffLogReq:
		return soap_in_PointerTo_ns1__queryPUOnOffLogReq(soap, NULL, NULL, "ns1:queryPUOnOffLogReq");
	case SOAP_TYPE_PointerTo_ns1__inviteKeepAliveRes:
		return soap_in_PointerTo_ns1__inviteKeepAliveRes(soap, NULL, NULL, "ns1:inviteKeepAliveRes");
	case SOAP_TYPE_PointerTo_ns1__inviteKeepAliveReq:
		return soap_in_PointerTo_ns1__inviteKeepAliveReq(soap, NULL, NULL, "ns1:inviteKeepAliveReq");
	case SOAP_TYPE_PointerTo_ns1__notifyNATResultRes:
		return soap_in_PointerTo_ns1__notifyNATResultRes(soap, NULL, NULL, "ns1:notifyNATResultRes");
	case SOAP_TYPE_PointerTo_ns1__notifyNATResultReq:
		return soap_in_PointerTo_ns1__notifyNATResultReq(soap, NULL, NULL, "ns1:notifyNATResultReq");
	case SOAP_TYPE_PointerTo_ns1__subscribeEMailRes:
		return soap_in_PointerTo_ns1__subscribeEMailRes(soap, NULL, NULL, "ns1:subscribeEMailRes");
	case SOAP_TYPE_PointerTo_ns1__subscribeEMailReq:
		return soap_in_PointerTo_ns1__subscribeEMailReq(soap, NULL, NULL, "ns1:subscribeEMailReq");
	case SOAP_TYPE_PointerTo_ns1__subscribeSMSRes:
		return soap_in_PointerTo_ns1__subscribeSMSRes(soap, NULL, NULL, "ns1:subscribeSMSRes");
	case SOAP_TYPE_PointerTo_ns1__subscribeSMSReq:
		return soap_in_PointerTo_ns1__subscribeSMSReq(soap, NULL, NULL, "ns1:subscribeSMSReq");
	case SOAP_TYPE_PointerTo_ns1__getNATServerRes:
		return soap_in_PointerTo_ns1__getNATServerRes(soap, NULL, NULL, "ns1:getNATServerRes");
	case SOAP_TYPE_PointerTo_ns1__getNATServerReq:
		return soap_in_PointerTo_ns1__getNATServerReq(soap, NULL, NULL, "ns1:getNATServerReq");
	case SOAP_TYPE_PointerTo_ns1__byeRes:
		return soap_in_PointerTo_ns1__byeRes(soap, NULL, NULL, "ns1:byeRes");
	case SOAP_TYPE_PointerTo_ns1__byeReq:
		return soap_in_PointerTo_ns1__byeReq(soap, NULL, NULL, "ns1:byeReq");
	case SOAP_TYPE_PointerTons1__inviteRes:
		return soap_in_PointerTons1__inviteRes(soap, NULL, NULL, "ns1:inviteRes");
	case SOAP_TYPE_PointerTons1__inviteReq:
		return soap_in_PointerTons1__inviteReq(soap, NULL, NULL, "ns1:inviteReq");
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryRes:
		return soap_in_PointerTo_ns1__setAuxiliaryRes(soap, NULL, NULL, "ns1:setAuxiliaryRes");
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryReq:
		return soap_in_PointerTo_ns1__setAuxiliaryReq(soap, NULL, NULL, "ns1:setAuxiliaryReq");
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryRes:
		return soap_in_PointerTo_ns1__getAuxiliaryRes(soap, NULL, NULL, "ns1:getAuxiliaryRes");
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryReq:
		return soap_in_PointerTo_ns1__getAuxiliaryReq(soap, NULL, NULL, "ns1:getAuxiliaryReq");
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordRes:
		return soap_in_PointerTo_ns1__getBackPasswordRes(soap, NULL, NULL, "ns1:getBackPasswordRes");
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordReq:
		return soap_in_PointerTo_ns1__getBackPasswordReq(soap, NULL, NULL, "ns1:getBackPasswordReq");
	case SOAP_TYPE_PointerTo_ns1__getAccountRes:
		return soap_in_PointerTo_ns1__getAccountRes(soap, NULL, NULL, "ns1:getAccountRes");
	case SOAP_TYPE_PointerTo_ns1__getAccountReq:
		return soap_in_PointerTo_ns1__getAccountReq(soap, NULL, NULL, "ns1:getAccountReq");
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenRes:
		return soap_in_PointerTo_ns1__updateAppleTokenRes(soap, NULL, NULL, "ns1:updateAppleTokenRes");
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenReq:
		return soap_in_PointerTo_ns1__updateAppleTokenReq(soap, NULL, NULL, "ns1:updateAppleTokenReq");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceRes:
		return soap_in_PointerTo_ns1__queryDeviceRes(soap, NULL, NULL, "ns1:queryDeviceRes");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceReq:
		return soap_in_PointerTo_ns1__queryDeviceReq(soap, NULL, NULL, "ns1:queryDeviceReq");
	case SOAP_TYPE_PointerTo_ns1__updatePasswordRes:
		return soap_in_PointerTo_ns1__updatePasswordRes(soap, NULL, NULL, "ns1:updatePasswordRes");
	case SOAP_TYPE_PointerTo_ns1__updatePasswordReq:
		return soap_in_PointerTo_ns1__updatePasswordReq(soap, NULL, NULL, "ns1:updatePasswordReq");
	case SOAP_TYPE_PointerTo_ns1__updateAccountRes:
		return soap_in_PointerTo_ns1__updateAccountRes(soap, NULL, NULL, "ns1:updateAccountRes");
	case SOAP_TYPE_PointerTo_ns1__updateAccountReq:
		return soap_in_PointerTo_ns1__updateAccountReq(soap, NULL, NULL, "ns1:updateAccountReq");
	case SOAP_TYPE_PointerTo_ns1__createAccountRes:
		return soap_in_PointerTo_ns1__createAccountRes(soap, NULL, NULL, "ns1:createAccountRes");
	case SOAP_TYPE_PointerTo_ns1__createAccountReq:
		return soap_in_PointerTo_ns1__createAccountReq(soap, NULL, NULL, "ns1:createAccountReq");
	case SOAP_TYPE_PointerTo_ns1__getPictureRes:
		return soap_in_PointerTo_ns1__getPictureRes(soap, NULL, NULL, "ns1:getPictureRes");
	case SOAP_TYPE_PointerTo_ns1__getPictureReq:
		return soap_in_PointerTo_ns1__getPictureReq(soap, NULL, NULL, "ns1:getPictureReq");
	case SOAP_TYPE_PointerTo_ns1__flaggedNoticeStatusRes:
		return soap_in_PointerTo_ns1__flaggedNoticeStatusRes(soap, NULL, NULL, "ns1:flaggedNoticeStatusRes");
	case SOAP_TYPE_PointerTo_ns1__flaggedNoticeStatusReq:
		return soap_in_PointerTo_ns1__flaggedNoticeStatusReq(soap, NULL, NULL, "ns1:flaggedNoticeStatusReq");
	case SOAP_TYPE_PointerTo_ns1__queryNoticesRes:
		return soap_in_PointerTo_ns1__queryNoticesRes(soap, NULL, NULL, "ns1:queryNoticesRes");
	case SOAP_TYPE_PointerTo_ns1__queryNoticesReq:
		return soap_in_PointerTo_ns1__queryNoticesReq(soap, NULL, NULL, "ns1:queryNoticesReq");
	case SOAP_TYPE_PointerTons1__trustedAuthorityLoginRes:
		return soap_in_PointerTons1__trustedAuthorityLoginRes(soap, NULL, NULL, "ns1:trustedAuthorityLoginRes");
	case SOAP_TYPE_PointerTons1__trustedAuthorityLoginReq:
		return soap_in_PointerTons1__trustedAuthorityLoginReq(soap, NULL, NULL, "ns1:trustedAuthorityLoginReq");
	case SOAP_TYPE_PointerTo_ns1__getDeviceMatchingResultRes:
		return soap_in_PointerTo_ns1__getDeviceMatchingResultRes(soap, NULL, NULL, "ns1:getDeviceMatchingResultRes");
	case SOAP_TYPE_PointerTo_ns1__getDeviceMatchingResultReq:
		return soap_in_PointerTo_ns1__getDeviceMatchingResultReq(soap, NULL, NULL, "ns1:getDeviceMatchingResultReq");
	case SOAP_TYPE_PointerTo_ns1__getDeviceMatchingCodeRes:
		return soap_in_PointerTo_ns1__getDeviceMatchingCodeRes(soap, NULL, NULL, "ns1:getDeviceMatchingCodeRes");
	case SOAP_TYPE_PointerTo_ns1__getDeviceMatchingCodeReq:
		return soap_in_PointerTo_ns1__getDeviceMatchingCodeReq(soap, NULL, NULL, "ns1:getDeviceMatchingCodeReq");
	case SOAP_TYPE_PointerTo_ns1__getDynamicPasswordRes:
		return soap_in_PointerTo_ns1__getDynamicPasswordRes(soap, NULL, NULL, "ns1:getDynamicPasswordRes");
	case SOAP_TYPE_PointerTo_ns1__getDynamicPasswordReq:
		return soap_in_PointerTo_ns1__getDynamicPasswordReq(soap, NULL, NULL, "ns1:getDynamicPasswordReq");
	case SOAP_TYPE_PointerTo_ns1__getWirelessNetworkRes:
		return soap_in_PointerTo_ns1__getWirelessNetworkRes(soap, NULL, NULL, "ns1:getWirelessNetworkRes");
	case SOAP_TYPE_PointerTo_ns1__getWirelessNetworkReq:
		return soap_in_PointerTo_ns1__getWirelessNetworkReq(soap, NULL, NULL, "ns1:getWirelessNetworkReq");
	case SOAP_TYPE_PointerTo_ns1__setRelayRes:
		return soap_in_PointerTo_ns1__setRelayRes(soap, NULL, NULL, "ns1:setRelayRes");
	case SOAP_TYPE_PointerTo_ns1__setRelayReq:
		return soap_in_PointerTo_ns1__setRelayReq(soap, NULL, NULL, "ns1:setRelayReq");
	case SOAP_TYPE_PointerTo_ns1__getRelayRes:
		return soap_in_PointerTo_ns1__getRelayRes(soap, NULL, NULL, "ns1:getRelayRes");
	case SOAP_TYPE_PointerTo_ns1__getRelayReq:
		return soap_in_PointerTo_ns1__getRelayReq(soap, NULL, NULL, "ns1:getRelayReq");
	case SOAP_TYPE_PointerTo_ns1__setRecordParamRes:
		return soap_in_PointerTo_ns1__setRecordParamRes(soap, NULL, NULL, "ns1:setRecordParamRes");
	case SOAP_TYPE_PointerTo_ns1__setRecordParamReq:
		return soap_in_PointerTo_ns1__setRecordParamReq(soap, NULL, NULL, "ns1:setRecordParamReq");
	case SOAP_TYPE_PointerTo_ns1__getRecordParamRes:
		return soap_in_PointerTo_ns1__getRecordParamRes(soap, NULL, NULL, "ns1:getRecordParamRes");
	case SOAP_TYPE_PointerTo_ns1__getRecordParamReq:
		return soap_in_PointerTo_ns1__getRecordParamReq(soap, NULL, NULL, "ns1:getRecordParamReq");
	case SOAP_TYPE_PointerTo_ns1__setPushWorkSheetRes:
		return soap_in_PointerTo_ns1__setPushWorkSheetRes(soap, NULL, NULL, "ns1:setPushWorkSheetRes");
	case SOAP_TYPE_PointerTo_ns1__setPushWorkSheetReq:
		return soap_in_PointerTo_ns1__setPushWorkSheetReq(soap, NULL, NULL, "ns1:setPushWorkSheetReq");
	case SOAP_TYPE_PointerTo_ns1__getPushWorkSheetRes:
		return soap_in_PointerTo_ns1__getPushWorkSheetRes(soap, NULL, NULL, "ns1:getPushWorkSheetRes");
	case SOAP_TYPE_PointerTo_ns1__getPushWorkSheetReq:
		return soap_in_PointerTo_ns1__getPushWorkSheetReq(soap, NULL, NULL, "ns1:getPushWorkSheetReq");
	case SOAP_TYPE_PointerTo_ns1__subscribeAndroidPushRes:
		return soap_in_PointerTo_ns1__subscribeAndroidPushRes(soap, NULL, NULL, "ns1:subscribeAndroidPushRes");
	case SOAP_TYPE_PointerTo_ns1__subscribeAndroidPushReq:
		return soap_in_PointerTo_ns1__subscribeAndroidPushReq(soap, NULL, NULL, "ns1:subscribeAndroidPushReq");
	case SOAP_TYPE_PointerTo_ns1__subscribeApplePushRes:
		return soap_in_PointerTo_ns1__subscribeApplePushRes(soap, NULL, NULL, "ns1:subscribeApplePushRes");
	case SOAP_TYPE_PointerTo_ns1__subscribeApplePushReq:
		return soap_in_PointerTo_ns1__subscribeApplePushReq(soap, NULL, NULL, "ns1:subscribeApplePushReq");
	case SOAP_TYPE_PointerTons1__VODRecord:
		return soap_in_PointerTons1__VODRecord(soap, NULL, NULL, "ns1:VODRecord");
	case SOAP_TYPE_PointerTons1__PrivacyMaskRegion:
		return soap_in_PointerTons1__PrivacyMaskRegion(soap, NULL, NULL, "ns1:PrivacyMaskRegion");
	case SOAP_TYPE_PointerTons1__VMDGrid:
		return soap_in_PointerTons1__VMDGrid(soap, NULL, NULL, "ns1:VMDGrid");
	case SOAP_TYPE_PointerTons1__VideoStandard:
		return soap_in_PointerTons1__VideoStandard(soap, NULL, NULL, "ns1:VideoStandard");
	case SOAP_TYPE_PointerTons1__ArrayOfDevLog:
		return soap_in_PointerTons1__ArrayOfDevLog(soap, NULL, NULL, "ns1:ArrayOfDevLog");
	case SOAP_TYPE_PointerTons1__ArrayOfPuLog:
		return soap_in_PointerTons1__ArrayOfPuLog(soap, NULL, NULL, "ns1:ArrayOfPuLog");
	case SOAP_TYPE_PointerTons1__RateType:
		return soap_in_PointerTons1__RateType(soap, NULL, NULL, "ns1:RateType");
	case SOAP_TYPE_PointerTons1__FrameSize:
		return soap_in_PointerTons1__FrameSize(soap, NULL, NULL, "ns1:FrameSize");
	case SOAP_TYPE_PointerTons1__ArrayOfDevice:
		return soap_in_PointerTons1__ArrayOfDevice(soap, NULL, NULL, "ns1:ArrayOfDevice");
	case SOAP_TYPE_PointerTons1__ArrayOfDeviceSharer:
		return soap_in_PointerTons1__ArrayOfDeviceSharer(soap, NULL, NULL, "ns1:ArrayOfDeviceSharer");
	case SOAP_TYPE_PointerTons1__ArrayOfPUEventLog:
		return soap_in_PointerTons1__ArrayOfPUEventLog(soap, NULL, NULL, "ns1:ArrayOfPUEventLog");
	case SOAP_TYPE_PointerTons1__EventState:
		return soap_in_PointerTons1__EventState(soap, NULL, NULL, "ns1:EventState");
	case SOAP_TYPE_PointerTons1__EventType:
		return soap_in_PointerTons1__EventType(soap, NULL, NULL, "ns1:EventType");
	case SOAP_TYPE_PointerTons1__ArrayOfPUOnOffLog:
		return soap_in_PointerTons1__ArrayOfPUOnOffLog(soap, NULL, NULL, "ns1:ArrayOfPUOnOffLog");
	case SOAP_TYPE_PointerTons1__ArrayOfTURNServer:
		return soap_in_PointerTons1__ArrayOfTURNServer(soap, NULL, NULL, "ns1:ArrayOfTURNServer");
	case SOAP_TYPE_PointerTons1__ArrayOfSTUNServer:
		return soap_in_PointerTons1__ArrayOfSTUNServer(soap, NULL, NULL, "ns1:ArrayOfSTUNServer");
	case SOAP_TYPE_PointerTons1__AuxiliaryType:
		return soap_in_PointerTons1__AuxiliaryType(soap, NULL, NULL, "ns1:AuxiliaryType");
	case SOAP_TYPE_PointerTons1__AuxiliaryState:
		return soap_in_PointerTons1__AuxiliaryState(soap, NULL, NULL, "ns1:AuxiliaryState");
	case SOAP_TYPE_PointerTons1__ArrayOfNodeDetails:
		return soap_in_PointerTons1__ArrayOfNodeDetails(soap, NULL, NULL, "ns1:ArrayOfNodeDetails");
	case SOAP_TYPE_PointerTons1__CountryAbbr2ISO3166:
		return soap_in_PointerTons1__CountryAbbr2ISO3166(soap, NULL, NULL, "ns1:CountryAbbr2ISO3166");
	case SOAP_TYPE_PointerTons1__ArrayOfNotice:
		return soap_in_PointerTons1__ArrayOfNotice(soap, NULL, NULL, "ns1:ArrayOfNotice");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__NoticeStatus:
		return soap_in_PointerTons1__NoticeStatus(soap, NULL, NULL, "ns1:NoticeStatus");
	case SOAP_TYPE_PointerTons1__Relay:
		return soap_in_PointerTons1__Relay(soap, NULL, NULL, "ns1:Relay");
	case SOAP_TYPE_PointerTons1__WorkSheet:
		return soap_in_PointerTons1__WorkSheet(soap, NULL, NULL, "ns1:WorkSheet");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerTons1__DevLog:
		return soap_in_PointerTons1__DevLog(soap, NULL, NULL, "ns1:DevLog");
	case SOAP_TYPE_PointerTons1__PuLog:
		return soap_in_PointerTons1__PuLog(soap, NULL, NULL, "ns1:PuLog");
	case SOAP_TYPE_PointerTons1__Device:
		return soap_in_PointerTons1__Device(soap, NULL, NULL, "ns1:Device");
	case SOAP_TYPE_PointerTons1__DeviceSharer:
		return soap_in_PointerTons1__DeviceSharer(soap, NULL, NULL, "ns1:DeviceSharer");
	case SOAP_TYPE_PointerTons1__PUEventLog:
		return soap_in_PointerTons1__PUEventLog(soap, NULL, NULL, "ns1:PUEventLog");
	case SOAP_TYPE_PointerTons1__PUOnOffLog:
		return soap_in_PointerTons1__PUOnOffLog(soap, NULL, NULL, "ns1:PUOnOffLog");
	case SOAP_TYPE_PointerTons1__TURNServer:
		return soap_in_PointerTons1__TURNServer(soap, NULL, NULL, "ns1:TURNServer");
	case SOAP_TYPE_PointerTons1__STUNServer:
		return soap_in_PointerTons1__STUNServer(soap, NULL, NULL, "ns1:STUNServer");
	case SOAP_TYPE_PointerTons1__WirelessNetwork:
		return soap_in_PointerTons1__WirelessNetwork(soap, NULL, NULL, "ns1:WirelessNetwork");
	case SOAP_TYPE_PointerTons1__NodeDetails:
		return soap_in_PointerTons1__NodeDetails(soap, NULL, NULL, "ns1:NodeDetails");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_in_PointerTons1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTons1__Notice:
		return soap_in_PointerTons1__Notice(soap, NULL, NULL, "ns1:Notice");
	case SOAP_TYPE_PointerTons1__Dev:
		return soap_in_PointerTons1__Dev(soap, NULL, NULL, "ns1:Dev");
	case SOAP_TYPE_PointerTons1__ArrayOfDev:
		return soap_in_PointerTons1__ArrayOfDev(soap, NULL, NULL, "ns1:ArrayOfDev");
	case SOAP_TYPE_PointerTons1__MCUDev:
		return soap_in_PointerTons1__MCUDev(soap, NULL, NULL, "ns1:MCUDev");
	case SOAP_TYPE_PointerTons1__RelayState:
		return soap_in_PointerTons1__RelayState(soap, NULL, NULL, "ns1:RelayState");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_in_PointerToxsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VideoStandard"))
		{	*type = SOAP_TYPE_ns1__VideoStandard;
			return soap_in_ns1__VideoStandard(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RateType"))
		{	*type = SOAP_TYPE_ns1__RateType;
			return soap_in_ns1__RateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FrameSize"))
		{	*type = SOAP_TYPE_ns1__FrameSize;
			return soap_in_ns1__FrameSize(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PTZPreset"))
		{	*type = SOAP_TYPE_ns1__PTZPreset;
			return soap_in_ns1__PTZPreset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PTZLens"))
		{	*type = SOAP_TYPE_ns1__PTZLens;
			return soap_in_ns1__PTZLens(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PTZDirection"))
		{	*type = SOAP_TYPE_ns1__PTZDirection;
			return soap_in_ns1__PTZDirection(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PwdType"))
		{	*type = SOAP_TYPE_ns1__PwdType;
			return soap_in_ns1__PwdType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MCUClientType"))
		{	*type = SOAP_TYPE_ns1__MCUClientType;
			return soap_in_ns1__MCUClientType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EventState"))
		{	*type = SOAP_TYPE_ns1__EventState;
			return soap_in_ns1__EventState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EventType"))
		{	*type = SOAP_TYPE_ns1__EventType;
			return soap_in_ns1__EventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NATType"))
		{	*type = SOAP_TYPE_ns1__NATType;
			return soap_in_ns1__NATType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StreamType"))
		{	*type = SOAP_TYPE_ns1__StreamType;
			return soap_in_ns1__StreamType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AuxiliaryState"))
		{	*type = SOAP_TYPE_ns1__AuxiliaryState;
			return soap_in_ns1__AuxiliaryState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AuxiliaryType"))
		{	*type = SOAP_TYPE_ns1__AuxiliaryType;
			return soap_in_ns1__AuxiliaryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeliveryType"))
		{	*type = SOAP_TYPE_ns1__DeliveryType;
			return soap_in_ns1__DeliveryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CountryAbbr2ISO3166"))
		{	*type = SOAP_TYPE_ns1__CountryAbbr2ISO3166;
			return soap_in_ns1__CountryAbbr2ISO3166(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NoticeClassification"))
		{	*type = SOAP_TYPE_ns1__NoticeClassification;
			return soap_in_ns1__NoticeClassification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NoticeStatus"))
		{	*type = SOAP_TYPE_ns1__NoticeStatus;
			return soap_in_ns1__NoticeStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MCUOSType"))
		{	*type = SOAP_TYPE_ns1__MCUOSType;
			return soap_in_ns1__MCUOSType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MCUDevType"))
		{	*type = SOAP_TYPE_ns1__MCUDevType;
			return soap_in_ns1__MCUDevType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NetType"))
		{	*type = SOAP_TYPE_ns1__NetType;
			return soap_in_ns1__NetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NetworkOperator"))
		{	*type = SOAP_TYPE_ns1__NetworkOperator;
			return soap_in_ns1__NetworkOperator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WirelessType"))
		{	*type = SOAP_TYPE_ns1__WirelessType;
			return soap_in_ns1__WirelessType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RelayState"))
		{	*type = SOAP_TYPE_ns1__RelayState;
			return soap_in_ns1__RelayState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MCUResult"))
		{	*type = SOAP_TYPE_ns1__MCUResult;
			return soap_in_ns1__MCUResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VODRecord"))
		{	*type = SOAP_TYPE_ns1__VODRecord;
			return soap_in_ns1__VODRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PrivacyMaskRegion"))
		{	*type = SOAP_TYPE_ns1__PrivacyMaskRegion;
			return soap_in_ns1__PrivacyMaskRegion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VMDGrid"))
		{	*type = SOAP_TYPE_ns1__VMDGrid;
			return soap_in_ns1__VMDGrid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DevLog"))
		{	*type = SOAP_TYPE_ns1__DevLog;
			return soap_in_ns1__DevLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDevLog"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDevLog;
			return soap_in_ns1__ArrayOfDevLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PuLog"))
		{	*type = SOAP_TYPE_ns1__PuLog;
			return soap_in_ns1__PuLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfPuLog"))
		{	*type = SOAP_TYPE_ns1__ArrayOfPuLog;
			return soap_in_ns1__ArrayOfPuLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Device"))
		{	*type = SOAP_TYPE_ns1__Device;
			return soap_in_ns1__Device(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDevice"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDevice;
			return soap_in_ns1__ArrayOfDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userLoginRes"))
		{	*type = SOAP_TYPE_ns1__userLoginRes;
			return soap_in_ns1__userLoginRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userLoginReq"))
		{	*type = SOAP_TYPE_ns1__userLoginReq;
			return soap_in_ns1__userLoginReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeviceSharer"))
		{	*type = SOAP_TYPE_ns1__DeviceSharer;
			return soap_in_ns1__DeviceSharer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDeviceSharer"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDeviceSharer;
			return soap_in_ns1__ArrayOfDeviceSharer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PUEventLog"))
		{	*type = SOAP_TYPE_ns1__PUEventLog;
			return soap_in_ns1__PUEventLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfPUEventLog"))
		{	*type = SOAP_TYPE_ns1__ArrayOfPUEventLog;
			return soap_in_ns1__ArrayOfPUEventLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PUOnOffLog"))
		{	*type = SOAP_TYPE_ns1__PUOnOffLog;
			return soap_in_ns1__PUOnOffLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfPUOnOffLog"))
		{	*type = SOAP_TYPE_ns1__ArrayOfPUOnOffLog;
			return soap_in_ns1__ArrayOfPUOnOffLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TURNServer"))
		{	*type = SOAP_TYPE_ns1__TURNServer;
			return soap_in_ns1__TURNServer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTURNServer"))
		{	*type = SOAP_TYPE_ns1__ArrayOfTURNServer;
			return soap_in_ns1__ArrayOfTURNServer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:STUNServer"))
		{	*type = SOAP_TYPE_ns1__STUNServer;
			return soap_in_ns1__STUNServer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSTUNServer"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSTUNServer;
			return soap_in_ns1__ArrayOfSTUNServer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:inviteRes"))
		{	*type = SOAP_TYPE_ns1__inviteRes;
			return soap_in_ns1__inviteRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:inviteReq"))
		{	*type = SOAP_TYPE_ns1__inviteReq;
			return soap_in_ns1__inviteReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WirelessNetwork"))
		{	*type = SOAP_TYPE_ns1__WirelessNetwork;
			return soap_in_ns1__WirelessNetwork(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NodeDetails"))
		{	*type = SOAP_TYPE_ns1__NodeDetails;
			return soap_in_ns1__NodeDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfNodeDetails"))
		{	*type = SOAP_TYPE_ns1__ArrayOfNodeDetails;
			return soap_in_ns1__ArrayOfNodeDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfString"))
		{	*type = SOAP_TYPE_ns1__ArrayOfString;
			return soap_in_ns1__ArrayOfString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Notice"))
		{	*type = SOAP_TYPE_ns1__Notice;
			return soap_in_ns1__Notice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfNotice"))
		{	*type = SOAP_TYPE_ns1__ArrayOfNotice;
			return soap_in_ns1__ArrayOfNotice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Dev"))
		{	*type = SOAP_TYPE_ns1__Dev;
			return soap_in_ns1__Dev(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDev"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDev;
			return soap_in_ns1__ArrayOfDev(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:trustedAuthorityLoginRes"))
		{	*type = SOAP_TYPE_ns1__trustedAuthorityLoginRes;
			return soap_in_ns1__trustedAuthorityLoginRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MCUDev"))
		{	*type = SOAP_TYPE_ns1__MCUDev;
			return soap_in_ns1__MCUDev(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:trustedAuthorityLoginReq"))
		{	*type = SOAP_TYPE_ns1__trustedAuthorityLoginReq;
			return soap_in_ns1__trustedAuthorityLoginReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Relay"))
		{	*type = SOAP_TYPE_ns1__Relay;
			return soap_in_ns1__Relay(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WorkSheet"))
		{	*type = SOAP_TYPE_ns1__WorkSheet;
			return soap_in_ns1__WorkSheet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:vodSearchRes"))
		{	*type = SOAP_TYPE__ns1__vodSearchRes;
			return soap_in__ns1__vodSearchRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:vodSearchReq"))
		{	*type = SOAP_TYPE__ns1__vodSearchReq;
			return soap_in__ns1__vodSearchReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVODUrlRes"))
		{	*type = SOAP_TYPE__ns1__getVODUrlRes;
			return soap_in__ns1__getVODUrlRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVODUrlReq"))
		{	*type = SOAP_TYPE__ns1__getVODUrlReq;
			return soap_in__ns1__getVODUrlReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPlayUrlRes"))
		{	*type = SOAP_TYPE__ns1__getPlayUrlRes;
			return soap_in__ns1__getPlayUrlRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPlayUrlReq"))
		{	*type = SOAP_TYPE__ns1__getPlayUrlReq;
			return soap_in__ns1__getPlayUrlReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setPrivacyMaskParamRes"))
		{	*type = SOAP_TYPE__ns1__setPrivacyMaskParamRes;
			return soap_in__ns1__setPrivacyMaskParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setPrivacyMaskParamReq"))
		{	*type = SOAP_TYPE__ns1__setPrivacyMaskParamReq;
			return soap_in__ns1__setPrivacyMaskParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPrivacyMaskParamRes"))
		{	*type = SOAP_TYPE__ns1__getPrivacyMaskParamRes;
			return soap_in__ns1__getPrivacyMaskParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPrivacyMaskParamReq"))
		{	*type = SOAP_TYPE__ns1__getPrivacyMaskParamReq;
			return soap_in__ns1__getPrivacyMaskParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setVMDParamRes"))
		{	*type = SOAP_TYPE__ns1__setVMDParamRes;
			return soap_in__ns1__setVMDParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setVMDParamReq"))
		{	*type = SOAP_TYPE__ns1__setVMDParamReq;
			return soap_in__ns1__setVMDParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVMDParamRes"))
		{	*type = SOAP_TYPE__ns1__getVMDParamRes;
			return soap_in__ns1__getVMDParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVMDParamReq"))
		{	*type = SOAP_TYPE__ns1__getVMDParamReq;
			return soap_in__ns1__getVMDParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setTimeRes"))
		{	*type = SOAP_TYPE__ns1__setTimeRes;
			return soap_in__ns1__setTimeRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setTimeReq"))
		{	*type = SOAP_TYPE__ns1__setTimeReq;
			return soap_in__ns1__setTimeReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTimeRes"))
		{	*type = SOAP_TYPE__ns1__getTimeRes;
			return soap_in__ns1__getTimeRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTimeReq"))
		{	*type = SOAP_TYPE__ns1__getTimeReq;
			return soap_in__ns1__getTimeReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setOSDParamRes"))
		{	*type = SOAP_TYPE__ns1__setOSDParamRes;
			return soap_in__ns1__setOSDParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setOSDParamReq"))
		{	*type = SOAP_TYPE__ns1__setOSDParamReq;
			return soap_in__ns1__setOSDParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getOSDParamRes"))
		{	*type = SOAP_TYPE__ns1__getOSDParamRes;
			return soap_in__ns1__getOSDParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getOSDParamReq"))
		{	*type = SOAP_TYPE__ns1__getOSDParamReq;
			return soap_in__ns1__getOSDParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setVideoParamRes"))
		{	*type = SOAP_TYPE__ns1__setVideoParamRes;
			return soap_in__ns1__setVideoParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setVideoParamReq"))
		{	*type = SOAP_TYPE__ns1__setVideoParamReq;
			return soap_in__ns1__setVideoParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVideoParamRes"))
		{	*type = SOAP_TYPE__ns1__getVideoParamRes;
			return soap_in__ns1__getVideoParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVideoParamReq"))
		{	*type = SOAP_TYPE__ns1__getVideoParamReq;
			return soap_in__ns1__getVideoParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDevLogRes"))
		{	*type = SOAP_TYPE__ns1__queryDevLogRes;
			return soap_in__ns1__queryDevLogRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDevLogReq"))
		{	*type = SOAP_TYPE__ns1__queryDevLogReq;
			return soap_in__ns1__queryDevLogReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryLogRes"))
		{	*type = SOAP_TYPE__ns1__queryLogRes;
			return soap_in__ns1__queryLogRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryLogReq"))
		{	*type = SOAP_TYPE__ns1__queryLogReq;
			return soap_in__ns1__queryLogReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:upgradeDevVerRes"))
		{	*type = SOAP_TYPE__ns1__upgradeDevVerRes;
			return soap_in__ns1__upgradeDevVerRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:upgradeDevVerReq"))
		{	*type = SOAP_TYPE__ns1__upgradeDevVerReq;
			return soap_in__ns1__upgradeDevVerReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDevVerRes"))
		{	*type = SOAP_TYPE__ns1__getDevVerRes;
			return soap_in__ns1__getDevVerRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDevVerReq"))
		{	*type = SOAP_TYPE__ns1__getDevVerReq;
			return soap_in__ns1__getDevVerReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:rebootRes"))
		{	*type = SOAP_TYPE__ns1__rebootRes;
			return soap_in__ns1__rebootRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:rebootReq"))
		{	*type = SOAP_TYPE__ns1__rebootReq;
			return soap_in__ns1__rebootReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setCodingParamRes"))
		{	*type = SOAP_TYPE__ns1__setCodingParamRes;
			return soap_in__ns1__setCodingParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setCodingParamReq"))
		{	*type = SOAP_TYPE__ns1__setCodingParamReq;
			return soap_in__ns1__setCodingParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCodingParamRes"))
		{	*type = SOAP_TYPE__ns1__getCodingParamRes;
			return soap_in__ns1__getCodingParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCodingParamReq"))
		{	*type = SOAP_TYPE__ns1__getCodingParamReq;
			return soap_in__ns1__getCodingParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:presetControlRes"))
		{	*type = SOAP_TYPE__ns1__presetControlRes;
			return soap_in__ns1__presetControlRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:presetControlReq"))
		{	*type = SOAP_TYPE__ns1__presetControlReq;
			return soap_in__ns1__presetControlReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lensControlRes"))
		{	*type = SOAP_TYPE__ns1__lensControlRes;
			return soap_in__ns1__lensControlRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lensControlReq"))
		{	*type = SOAP_TYPE__ns1__lensControlReq;
			return soap_in__ns1__lensControlReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ptzControlRes"))
		{	*type = SOAP_TYPE__ns1__ptzControlRes;
			return soap_in__ns1__ptzControlRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ptzControlReq"))
		{	*type = SOAP_TYPE__ns1__ptzControlReq;
			return soap_in__ns1__ptzControlReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:nullifyDeviceRes"))
		{	*type = SOAP_TYPE__ns1__nullifyDeviceRes;
			return soap_in__ns1__nullifyDeviceRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:nullifyDeviceReq"))
		{	*type = SOAP_TYPE__ns1__nullifyDeviceReq;
			return soap_in__ns1__nullifyDeviceReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDeviceRes"))
		{	*type = SOAP_TYPE__ns1__addDeviceRes;
			return soap_in__ns1__addDeviceRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDeviceReq"))
		{	*type = SOAP_TYPE__ns1__addDeviceReq;
			return soap_in__ns1__addDeviceReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateChannelNameRes"))
		{	*type = SOAP_TYPE__ns1__updateChannelNameRes;
			return soap_in__ns1__updateChannelNameRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateChannelNameReq"))
		{	*type = SOAP_TYPE__ns1__updateChannelNameReq;
			return soap_in__ns1__updateChannelNameReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userLogoutRes"))
		{	*type = SOAP_TYPE__ns1__userLogoutRes;
			return soap_in__ns1__userLogoutRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userLogoutReq"))
		{	*type = SOAP_TYPE__ns1__userLogoutReq;
			return soap_in__ns1__userLogoutReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDeviceBondedRes"))
		{	*type = SOAP_TYPE__ns1__queryDeviceBondedRes;
			return soap_in__ns1__queryDeviceBondedRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDeviceBondedReq"))
		{	*type = SOAP_TYPE__ns1__queryDeviceBondedReq;
			return soap_in__ns1__queryDeviceBondedReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryClientVersionRes"))
		{	*type = SOAP_TYPE__ns1__queryClientVersionRes;
			return soap_in__ns1__queryClientVersionRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryClientVersionReq"))
		{	*type = SOAP_TYPE__ns1__queryClientVersionReq;
			return soap_in__ns1__queryClientVersionReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryAndroidTokenRes"))
		{	*type = SOAP_TYPE__ns1__queryAndroidTokenRes;
			return soap_in__ns1__queryAndroidTokenRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryAndroidTokenReq"))
		{	*type = SOAP_TYPE__ns1__queryAndroidTokenReq;
			return soap_in__ns1__queryAndroidTokenReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryAppleTokenRes"))
		{	*type = SOAP_TYPE__ns1__queryAppleTokenRes;
			return soap_in__ns1__queryAppleTokenRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryAppleTokenReq"))
		{	*type = SOAP_TYPE__ns1__queryAppleTokenReq;
			return soap_in__ns1__queryAppleTokenReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDeviceSharingSourceRes"))
		{	*type = SOAP_TYPE__ns1__queryDeviceSharingSourceRes;
			return soap_in__ns1__queryDeviceSharingSourceRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDeviceSharingSourceReq"))
		{	*type = SOAP_TYPE__ns1__queryDeviceSharingSourceReq;
			return soap_in__ns1__queryDeviceSharingSourceReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDeviceSharerRes"))
		{	*type = SOAP_TYPE__ns1__queryDeviceSharerRes;
			return soap_in__ns1__queryDeviceSharerRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDeviceSharerReq"))
		{	*type = SOAP_TYPE__ns1__queryDeviceSharerReq;
			return soap_in__ns1__queryDeviceSharerReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:nullifyDeviceSharerRes"))
		{	*type = SOAP_TYPE__ns1__nullifyDeviceSharerRes;
			return soap_in__ns1__nullifyDeviceSharerRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:nullifyDeviceSharerReq"))
		{	*type = SOAP_TYPE__ns1__nullifyDeviceSharerReq;
			return soap_in__ns1__nullifyDeviceSharerReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDeviceSharerRes"))
		{	*type = SOAP_TYPE__ns1__addDeviceSharerRes;
			return soap_in__ns1__addDeviceSharerRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDeviceSharerReq"))
		{	*type = SOAP_TYPE__ns1__addDeviceSharerReq;
			return soap_in__ns1__addDeviceSharerReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDeviceStatusRes"))
		{	*type = SOAP_TYPE__ns1__queryDeviceStatusRes;
			return soap_in__ns1__queryDeviceStatusRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDeviceStatusReq"))
		{	*type = SOAP_TYPE__ns1__queryDeviceStatusReq;
			return soap_in__ns1__queryDeviceStatusReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAndroidTokenRes"))
		{	*type = SOAP_TYPE__ns1__updateAndroidTokenRes;
			return soap_in__ns1__updateAndroidTokenRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAndroidTokenReq"))
		{	*type = SOAP_TYPE__ns1__updateAndroidTokenReq;
			return soap_in__ns1__updateAndroidTokenReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryPUEventLogRes"))
		{	*type = SOAP_TYPE__ns1__queryPUEventLogRes;
			return soap_in__ns1__queryPUEventLogRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryPUEventLogReq"))
		{	*type = SOAP_TYPE__ns1__queryPUEventLogReq;
			return soap_in__ns1__queryPUEventLogReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryPUOnOffLogRes"))
		{	*type = SOAP_TYPE__ns1__queryPUOnOffLogRes;
			return soap_in__ns1__queryPUOnOffLogRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryPUOnOffLogReq"))
		{	*type = SOAP_TYPE__ns1__queryPUOnOffLogReq;
			return soap_in__ns1__queryPUOnOffLogReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:inviteKeepAliveRes"))
		{	*type = SOAP_TYPE__ns1__inviteKeepAliveRes;
			return soap_in__ns1__inviteKeepAliveRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:inviteKeepAliveReq"))
		{	*type = SOAP_TYPE__ns1__inviteKeepAliveReq;
			return soap_in__ns1__inviteKeepAliveReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:notifyNATResultRes"))
		{	*type = SOAP_TYPE__ns1__notifyNATResultRes;
			return soap_in__ns1__notifyNATResultRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:notifyNATResultReq"))
		{	*type = SOAP_TYPE__ns1__notifyNATResultReq;
			return soap_in__ns1__notifyNATResultReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:subscribeEMailRes"))
		{	*type = SOAP_TYPE__ns1__subscribeEMailRes;
			return soap_in__ns1__subscribeEMailRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:subscribeEMailReq"))
		{	*type = SOAP_TYPE__ns1__subscribeEMailReq;
			return soap_in__ns1__subscribeEMailReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:subscribeSMSRes"))
		{	*type = SOAP_TYPE__ns1__subscribeSMSRes;
			return soap_in__ns1__subscribeSMSRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:subscribeSMSReq"))
		{	*type = SOAP_TYPE__ns1__subscribeSMSReq;
			return soap_in__ns1__subscribeSMSReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getNATServerRes"))
		{	*type = SOAP_TYPE__ns1__getNATServerRes;
			return soap_in__ns1__getNATServerRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getNATServerReq"))
		{	*type = SOAP_TYPE__ns1__getNATServerReq;
			return soap_in__ns1__getNATServerReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:byeRes"))
		{	*type = SOAP_TYPE__ns1__byeRes;
			return soap_in__ns1__byeRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:byeReq"))
		{	*type = SOAP_TYPE__ns1__byeReq;
			return soap_in__ns1__byeReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setAuxiliaryRes"))
		{	*type = SOAP_TYPE__ns1__setAuxiliaryRes;
			return soap_in__ns1__setAuxiliaryRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setAuxiliaryReq"))
		{	*type = SOAP_TYPE__ns1__setAuxiliaryReq;
			return soap_in__ns1__setAuxiliaryReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAuxiliaryRes"))
		{	*type = SOAP_TYPE__ns1__getAuxiliaryRes;
			return soap_in__ns1__getAuxiliaryRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAuxiliaryReq"))
		{	*type = SOAP_TYPE__ns1__getAuxiliaryReq;
			return soap_in__ns1__getAuxiliaryReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getBackPasswordRes"))
		{	*type = SOAP_TYPE__ns1__getBackPasswordRes;
			return soap_in__ns1__getBackPasswordRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getBackPasswordReq"))
		{	*type = SOAP_TYPE__ns1__getBackPasswordReq;
			return soap_in__ns1__getBackPasswordReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccountRes"))
		{	*type = SOAP_TYPE__ns1__getAccountRes;
			return soap_in__ns1__getAccountRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccountReq"))
		{	*type = SOAP_TYPE__ns1__getAccountReq;
			return soap_in__ns1__getAccountReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAppleTokenRes"))
		{	*type = SOAP_TYPE__ns1__updateAppleTokenRes;
			return soap_in__ns1__updateAppleTokenRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAppleTokenReq"))
		{	*type = SOAP_TYPE__ns1__updateAppleTokenReq;
			return soap_in__ns1__updateAppleTokenReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDeviceRes"))
		{	*type = SOAP_TYPE__ns1__queryDeviceRes;
			return soap_in__ns1__queryDeviceRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDeviceReq"))
		{	*type = SOAP_TYPE__ns1__queryDeviceReq;
			return soap_in__ns1__queryDeviceReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updatePasswordRes"))
		{	*type = SOAP_TYPE__ns1__updatePasswordRes;
			return soap_in__ns1__updatePasswordRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updatePasswordReq"))
		{	*type = SOAP_TYPE__ns1__updatePasswordReq;
			return soap_in__ns1__updatePasswordReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAccountRes"))
		{	*type = SOAP_TYPE__ns1__updateAccountRes;
			return soap_in__ns1__updateAccountRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAccountReq"))
		{	*type = SOAP_TYPE__ns1__updateAccountReq;
			return soap_in__ns1__updateAccountReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createAccountRes"))
		{	*type = SOAP_TYPE__ns1__createAccountRes;
			return soap_in__ns1__createAccountRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createAccountReq"))
		{	*type = SOAP_TYPE__ns1__createAccountReq;
			return soap_in__ns1__createAccountReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPictureRes"))
		{	*type = SOAP_TYPE__ns1__getPictureRes;
			return soap_in__ns1__getPictureRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPictureReq"))
		{	*type = SOAP_TYPE__ns1__getPictureReq;
			return soap_in__ns1__getPictureReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:flaggedNoticeStatusRes"))
		{	*type = SOAP_TYPE__ns1__flaggedNoticeStatusRes;
			return soap_in__ns1__flaggedNoticeStatusRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:flaggedNoticeStatusReq"))
		{	*type = SOAP_TYPE__ns1__flaggedNoticeStatusReq;
			return soap_in__ns1__flaggedNoticeStatusReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryNoticesRes"))
		{	*type = SOAP_TYPE__ns1__queryNoticesRes;
			return soap_in__ns1__queryNoticesRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryNoticesReq"))
		{	*type = SOAP_TYPE__ns1__queryNoticesReq;
			return soap_in__ns1__queryNoticesReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDeviceMatchingResultRes"))
		{	*type = SOAP_TYPE__ns1__getDeviceMatchingResultRes;
			return soap_in__ns1__getDeviceMatchingResultRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDeviceMatchingResultReq"))
		{	*type = SOAP_TYPE__ns1__getDeviceMatchingResultReq;
			return soap_in__ns1__getDeviceMatchingResultReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDeviceMatchingCodeRes"))
		{	*type = SOAP_TYPE__ns1__getDeviceMatchingCodeRes;
			return soap_in__ns1__getDeviceMatchingCodeRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDeviceMatchingCodeReq"))
		{	*type = SOAP_TYPE__ns1__getDeviceMatchingCodeReq;
			return soap_in__ns1__getDeviceMatchingCodeReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDynamicPasswordRes"))
		{	*type = SOAP_TYPE__ns1__getDynamicPasswordRes;
			return soap_in__ns1__getDynamicPasswordRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDynamicPasswordReq"))
		{	*type = SOAP_TYPE__ns1__getDynamicPasswordReq;
			return soap_in__ns1__getDynamicPasswordReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getWirelessNetworkRes"))
		{	*type = SOAP_TYPE__ns1__getWirelessNetworkRes;
			return soap_in__ns1__getWirelessNetworkRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getWirelessNetworkReq"))
		{	*type = SOAP_TYPE__ns1__getWirelessNetworkReq;
			return soap_in__ns1__getWirelessNetworkReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setRelayRes"))
		{	*type = SOAP_TYPE__ns1__setRelayRes;
			return soap_in__ns1__setRelayRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setRelayReq"))
		{	*type = SOAP_TYPE__ns1__setRelayReq;
			return soap_in__ns1__setRelayReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRelayRes"))
		{	*type = SOAP_TYPE__ns1__getRelayRes;
			return soap_in__ns1__getRelayRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRelayReq"))
		{	*type = SOAP_TYPE__ns1__getRelayReq;
			return soap_in__ns1__getRelayReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setRecordParamRes"))
		{	*type = SOAP_TYPE__ns1__setRecordParamRes;
			return soap_in__ns1__setRecordParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setRecordParamReq"))
		{	*type = SOAP_TYPE__ns1__setRecordParamReq;
			return soap_in__ns1__setRecordParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRecordParamRes"))
		{	*type = SOAP_TYPE__ns1__getRecordParamRes;
			return soap_in__ns1__getRecordParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRecordParamReq"))
		{	*type = SOAP_TYPE__ns1__getRecordParamReq;
			return soap_in__ns1__getRecordParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setPushWorkSheetRes"))
		{	*type = SOAP_TYPE__ns1__setPushWorkSheetRes;
			return soap_in__ns1__setPushWorkSheetRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setPushWorkSheetReq"))
		{	*type = SOAP_TYPE__ns1__setPushWorkSheetReq;
			return soap_in__ns1__setPushWorkSheetReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPushWorkSheetRes"))
		{	*type = SOAP_TYPE__ns1__getPushWorkSheetRes;
			return soap_in__ns1__getPushWorkSheetRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPushWorkSheetReq"))
		{	*type = SOAP_TYPE__ns1__getPushWorkSheetReq;
			return soap_in__ns1__getPushWorkSheetReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:subscribeAndroidPushRes"))
		{	*type = SOAP_TYPE__ns1__subscribeAndroidPushRes;
			return soap_in__ns1__subscribeAndroidPushRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:subscribeAndroidPushReq"))
		{	*type = SOAP_TYPE__ns1__subscribeAndroidPushReq;
			return soap_in__ns1__subscribeAndroidPushReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:subscribeApplePushRes"))
		{	*type = SOAP_TYPE__ns1__subscribeApplePushRes;
			return soap_in__ns1__subscribeApplePushRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:subscribeApplePushReq"))
		{	*type = SOAP_TYPE__ns1__subscribeApplePushReq;
			return soap_in__ns1__subscribeApplePushReq(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_ns1__VideoStandard:
		return soap_out_ns1__VideoStandard(soap, tag, id, (const enum ns1__VideoStandard *)ptr, "ns1:VideoStandard");
	case SOAP_TYPE_ns1__RateType:
		return soap_out_ns1__RateType(soap, tag, id, (const enum ns1__RateType *)ptr, "ns1:RateType");
	case SOAP_TYPE_ns1__FrameSize:
		return soap_out_ns1__FrameSize(soap, tag, id, (const enum ns1__FrameSize *)ptr, "ns1:FrameSize");
	case SOAP_TYPE_ns1__PTZPreset:
		return soap_out_ns1__PTZPreset(soap, tag, id, (const enum ns1__PTZPreset *)ptr, "ns1:PTZPreset");
	case SOAP_TYPE_ns1__PTZLens:
		return soap_out_ns1__PTZLens(soap, tag, id, (const enum ns1__PTZLens *)ptr, "ns1:PTZLens");
	case SOAP_TYPE_ns1__PTZDirection:
		return soap_out_ns1__PTZDirection(soap, tag, id, (const enum ns1__PTZDirection *)ptr, "ns1:PTZDirection");
	case SOAP_TYPE_ns1__PwdType:
		return soap_out_ns1__PwdType(soap, tag, id, (const enum ns1__PwdType *)ptr, "ns1:PwdType");
	case SOAP_TYPE_ns1__MCUClientType:
		return soap_out_ns1__MCUClientType(soap, tag, id, (const enum ns1__MCUClientType *)ptr, "ns1:MCUClientType");
	case SOAP_TYPE_ns1__EventState:
		return soap_out_ns1__EventState(soap, tag, id, (const enum ns1__EventState *)ptr, "ns1:EventState");
	case SOAP_TYPE_ns1__EventType:
		return soap_out_ns1__EventType(soap, tag, id, (const enum ns1__EventType *)ptr, "ns1:EventType");
	case SOAP_TYPE_ns1__NATType:
		return soap_out_ns1__NATType(soap, tag, id, (const enum ns1__NATType *)ptr, "ns1:NATType");
	case SOAP_TYPE_ns1__StreamType:
		return soap_out_ns1__StreamType(soap, tag, id, (const enum ns1__StreamType *)ptr, "ns1:StreamType");
	case SOAP_TYPE_ns1__AuxiliaryState:
		return soap_out_ns1__AuxiliaryState(soap, tag, id, (const enum ns1__AuxiliaryState *)ptr, "ns1:AuxiliaryState");
	case SOAP_TYPE_ns1__AuxiliaryType:
		return soap_out_ns1__AuxiliaryType(soap, tag, id, (const enum ns1__AuxiliaryType *)ptr, "ns1:AuxiliaryType");
	case SOAP_TYPE_ns1__DeliveryType:
		return soap_out_ns1__DeliveryType(soap, tag, id, (const enum ns1__DeliveryType *)ptr, "ns1:DeliveryType");
	case SOAP_TYPE_ns1__CountryAbbr2ISO3166:
		return soap_out_ns1__CountryAbbr2ISO3166(soap, tag, id, (const enum ns1__CountryAbbr2ISO3166 *)ptr, "ns1:CountryAbbr2ISO3166");
	case SOAP_TYPE_ns1__NoticeClassification:
		return soap_out_ns1__NoticeClassification(soap, tag, id, (const enum ns1__NoticeClassification *)ptr, "ns1:NoticeClassification");
	case SOAP_TYPE_ns1__NoticeStatus:
		return soap_out_ns1__NoticeStatus(soap, tag, id, (const enum ns1__NoticeStatus *)ptr, "ns1:NoticeStatus");
	case SOAP_TYPE_ns1__MCUOSType:
		return soap_out_ns1__MCUOSType(soap, tag, id, (const enum ns1__MCUOSType *)ptr, "ns1:MCUOSType");
	case SOAP_TYPE_ns1__MCUDevType:
		return soap_out_ns1__MCUDevType(soap, tag, id, (const enum ns1__MCUDevType *)ptr, "ns1:MCUDevType");
	case SOAP_TYPE_ns1__NetType:
		return soap_out_ns1__NetType(soap, tag, id, (const enum ns1__NetType *)ptr, "ns1:NetType");
	case SOAP_TYPE_ns1__NetworkOperator:
		return soap_out_ns1__NetworkOperator(soap, tag, id, (const enum ns1__NetworkOperator *)ptr, "ns1:NetworkOperator");
	case SOAP_TYPE_ns1__WirelessType:
		return soap_out_ns1__WirelessType(soap, tag, id, (const enum ns1__WirelessType *)ptr, "ns1:WirelessType");
	case SOAP_TYPE_ns1__RelayState:
		return soap_out_ns1__RelayState(soap, tag, id, (const enum ns1__RelayState *)ptr, "ns1:RelayState");
	case SOAP_TYPE_ns1__MCUResult:
		return soap_out_ns1__MCUResult(soap, tag, id, (const enum ns1__MCUResult *)ptr, "ns1:MCUResult");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns1__vodSearchRes:
		return soap_out__ns1__vodSearchRes(soap, "ns1:vodSearchRes", id, (const struct _ns1__vodSearchRes *)ptr, NULL);
	case SOAP_TYPE__ns1__vodSearchReq:
		return soap_out__ns1__vodSearchReq(soap, "ns1:vodSearchReq", id, (const struct _ns1__vodSearchReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getVODUrlRes:
		return soap_out__ns1__getVODUrlRes(soap, "ns1:getVODUrlRes", id, (const struct _ns1__getVODUrlRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getVODUrlReq:
		return soap_out__ns1__getVODUrlReq(soap, "ns1:getVODUrlReq", id, (const struct _ns1__getVODUrlReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getPlayUrlRes:
		return soap_out__ns1__getPlayUrlRes(soap, "ns1:getPlayUrlRes", id, (const struct _ns1__getPlayUrlRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getPlayUrlReq:
		return soap_out__ns1__getPlayUrlReq(soap, "ns1:getPlayUrlReq", id, (const struct _ns1__getPlayUrlReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setPrivacyMaskParamRes:
		return soap_out__ns1__setPrivacyMaskParamRes(soap, "ns1:setPrivacyMaskParamRes", id, (const struct _ns1__setPrivacyMaskParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setPrivacyMaskParamReq:
		return soap_out__ns1__setPrivacyMaskParamReq(soap, "ns1:setPrivacyMaskParamReq", id, (const struct _ns1__setPrivacyMaskParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getPrivacyMaskParamRes:
		return soap_out__ns1__getPrivacyMaskParamRes(soap, "ns1:getPrivacyMaskParamRes", id, (const struct _ns1__getPrivacyMaskParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getPrivacyMaskParamReq:
		return soap_out__ns1__getPrivacyMaskParamReq(soap, "ns1:getPrivacyMaskParamReq", id, (const struct _ns1__getPrivacyMaskParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setVMDParamRes:
		return soap_out__ns1__setVMDParamRes(soap, "ns1:setVMDParamRes", id, (const struct _ns1__setVMDParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setVMDParamReq:
		return soap_out__ns1__setVMDParamReq(soap, "ns1:setVMDParamReq", id, (const struct _ns1__setVMDParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getVMDParamRes:
		return soap_out__ns1__getVMDParamRes(soap, "ns1:getVMDParamRes", id, (const struct _ns1__getVMDParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getVMDParamReq:
		return soap_out__ns1__getVMDParamReq(soap, "ns1:getVMDParamReq", id, (const struct _ns1__getVMDParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setTimeRes:
		return soap_out__ns1__setTimeRes(soap, "ns1:setTimeRes", id, (const struct _ns1__setTimeRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setTimeReq:
		return soap_out__ns1__setTimeReq(soap, "ns1:setTimeReq", id, (const struct _ns1__setTimeReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getTimeRes:
		return soap_out__ns1__getTimeRes(soap, "ns1:getTimeRes", id, (const struct _ns1__getTimeRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getTimeReq:
		return soap_out__ns1__getTimeReq(soap, "ns1:getTimeReq", id, (const struct _ns1__getTimeReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setOSDParamRes:
		return soap_out__ns1__setOSDParamRes(soap, "ns1:setOSDParamRes", id, (const struct _ns1__setOSDParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setOSDParamReq:
		return soap_out__ns1__setOSDParamReq(soap, "ns1:setOSDParamReq", id, (const struct _ns1__setOSDParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getOSDParamRes:
		return soap_out__ns1__getOSDParamRes(soap, "ns1:getOSDParamRes", id, (const struct _ns1__getOSDParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getOSDParamReq:
		return soap_out__ns1__getOSDParamReq(soap, "ns1:getOSDParamReq", id, (const struct _ns1__getOSDParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setVideoParamRes:
		return soap_out__ns1__setVideoParamRes(soap, "ns1:setVideoParamRes", id, (const struct _ns1__setVideoParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setVideoParamReq:
		return soap_out__ns1__setVideoParamReq(soap, "ns1:setVideoParamReq", id, (const struct _ns1__setVideoParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getVideoParamRes:
		return soap_out__ns1__getVideoParamRes(soap, "ns1:getVideoParamRes", id, (const struct _ns1__getVideoParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getVideoParamReq:
		return soap_out__ns1__getVideoParamReq(soap, "ns1:getVideoParamReq", id, (const struct _ns1__getVideoParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDevLogRes:
		return soap_out__ns1__queryDevLogRes(soap, "ns1:queryDevLogRes", id, (const struct _ns1__queryDevLogRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDevLogReq:
		return soap_out__ns1__queryDevLogReq(soap, "ns1:queryDevLogReq", id, (const struct _ns1__queryDevLogReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryLogRes:
		return soap_out__ns1__queryLogRes(soap, "ns1:queryLogRes", id, (const struct _ns1__queryLogRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryLogReq:
		return soap_out__ns1__queryLogReq(soap, "ns1:queryLogReq", id, (const struct _ns1__queryLogReq *)ptr, NULL);
	case SOAP_TYPE__ns1__upgradeDevVerRes:
		return soap_out__ns1__upgradeDevVerRes(soap, "ns1:upgradeDevVerRes", id, (const struct _ns1__upgradeDevVerRes *)ptr, NULL);
	case SOAP_TYPE__ns1__upgradeDevVerReq:
		return soap_out__ns1__upgradeDevVerReq(soap, "ns1:upgradeDevVerReq", id, (const struct _ns1__upgradeDevVerReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getDevVerRes:
		return soap_out__ns1__getDevVerRes(soap, "ns1:getDevVerRes", id, (const struct _ns1__getDevVerRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getDevVerReq:
		return soap_out__ns1__getDevVerReq(soap, "ns1:getDevVerReq", id, (const struct _ns1__getDevVerReq *)ptr, NULL);
	case SOAP_TYPE__ns1__rebootRes:
		return soap_out__ns1__rebootRes(soap, "ns1:rebootRes", id, (const struct _ns1__rebootRes *)ptr, NULL);
	case SOAP_TYPE__ns1__rebootReq:
		return soap_out__ns1__rebootReq(soap, "ns1:rebootReq", id, (const struct _ns1__rebootReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setCodingParamRes:
		return soap_out__ns1__setCodingParamRes(soap, "ns1:setCodingParamRes", id, (const struct _ns1__setCodingParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setCodingParamReq:
		return soap_out__ns1__setCodingParamReq(soap, "ns1:setCodingParamReq", id, (const struct _ns1__setCodingParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getCodingParamRes:
		return soap_out__ns1__getCodingParamRes(soap, "ns1:getCodingParamRes", id, (const struct _ns1__getCodingParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getCodingParamReq:
		return soap_out__ns1__getCodingParamReq(soap, "ns1:getCodingParamReq", id, (const struct _ns1__getCodingParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__presetControlRes:
		return soap_out__ns1__presetControlRes(soap, "ns1:presetControlRes", id, (const struct _ns1__presetControlRes *)ptr, NULL);
	case SOAP_TYPE__ns1__presetControlReq:
		return soap_out__ns1__presetControlReq(soap, "ns1:presetControlReq", id, (const struct _ns1__presetControlReq *)ptr, NULL);
	case SOAP_TYPE__ns1__lensControlRes:
		return soap_out__ns1__lensControlRes(soap, "ns1:lensControlRes", id, (const struct _ns1__lensControlRes *)ptr, NULL);
	case SOAP_TYPE__ns1__lensControlReq:
		return soap_out__ns1__lensControlReq(soap, "ns1:lensControlReq", id, (const struct _ns1__lensControlReq *)ptr, NULL);
	case SOAP_TYPE__ns1__ptzControlRes:
		return soap_out__ns1__ptzControlRes(soap, "ns1:ptzControlRes", id, (const struct _ns1__ptzControlRes *)ptr, NULL);
	case SOAP_TYPE__ns1__ptzControlReq:
		return soap_out__ns1__ptzControlReq(soap, "ns1:ptzControlReq", id, (const struct _ns1__ptzControlReq *)ptr, NULL);
	case SOAP_TYPE__ns1__nullifyDeviceRes:
		return soap_out__ns1__nullifyDeviceRes(soap, "ns1:nullifyDeviceRes", id, (const struct _ns1__nullifyDeviceRes *)ptr, NULL);
	case SOAP_TYPE__ns1__nullifyDeviceReq:
		return soap_out__ns1__nullifyDeviceReq(soap, "ns1:nullifyDeviceReq", id, (const struct _ns1__nullifyDeviceReq *)ptr, NULL);
	case SOAP_TYPE__ns1__addDeviceRes:
		return soap_out__ns1__addDeviceRes(soap, "ns1:addDeviceRes", id, (const struct _ns1__addDeviceRes *)ptr, NULL);
	case SOAP_TYPE__ns1__addDeviceReq:
		return soap_out__ns1__addDeviceReq(soap, "ns1:addDeviceReq", id, (const struct _ns1__addDeviceReq *)ptr, NULL);
	case SOAP_TYPE__ns1__updateChannelNameRes:
		return soap_out__ns1__updateChannelNameRes(soap, "ns1:updateChannelNameRes", id, (const struct _ns1__updateChannelNameRes *)ptr, NULL);
	case SOAP_TYPE__ns1__updateChannelNameReq:
		return soap_out__ns1__updateChannelNameReq(soap, "ns1:updateChannelNameReq", id, (const struct _ns1__updateChannelNameReq *)ptr, NULL);
	case SOAP_TYPE__ns1__userLogoutRes:
		return soap_out__ns1__userLogoutRes(soap, "ns1:userLogoutRes", id, (const struct _ns1__userLogoutRes *)ptr, NULL);
	case SOAP_TYPE__ns1__userLogoutReq:
		return soap_out__ns1__userLogoutReq(soap, "ns1:userLogoutReq", id, (const struct _ns1__userLogoutReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDeviceBondedRes:
		return soap_out__ns1__queryDeviceBondedRes(soap, "ns1:queryDeviceBondedRes", id, (const struct _ns1__queryDeviceBondedRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDeviceBondedReq:
		return soap_out__ns1__queryDeviceBondedReq(soap, "ns1:queryDeviceBondedReq", id, (const struct _ns1__queryDeviceBondedReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryClientVersionRes:
		return soap_out__ns1__queryClientVersionRes(soap, "ns1:queryClientVersionRes", id, (const struct _ns1__queryClientVersionRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryClientVersionReq:
		return soap_out__ns1__queryClientVersionReq(soap, "ns1:queryClientVersionReq", id, (const struct _ns1__queryClientVersionReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryAndroidTokenRes:
		return soap_out__ns1__queryAndroidTokenRes(soap, "ns1:queryAndroidTokenRes", id, (const struct _ns1__queryAndroidTokenRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryAndroidTokenReq:
		return soap_out__ns1__queryAndroidTokenReq(soap, "ns1:queryAndroidTokenReq", id, (const struct _ns1__queryAndroidTokenReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryAppleTokenRes:
		return soap_out__ns1__queryAppleTokenRes(soap, "ns1:queryAppleTokenRes", id, (const struct _ns1__queryAppleTokenRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryAppleTokenReq:
		return soap_out__ns1__queryAppleTokenReq(soap, "ns1:queryAppleTokenReq", id, (const struct _ns1__queryAppleTokenReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDeviceSharingSourceRes:
		return soap_out__ns1__queryDeviceSharingSourceRes(soap, "ns1:queryDeviceSharingSourceRes", id, (const struct _ns1__queryDeviceSharingSourceRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDeviceSharingSourceReq:
		return soap_out__ns1__queryDeviceSharingSourceReq(soap, "ns1:queryDeviceSharingSourceReq", id, (const struct _ns1__queryDeviceSharingSourceReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDeviceSharerRes:
		return soap_out__ns1__queryDeviceSharerRes(soap, "ns1:queryDeviceSharerRes", id, (const struct _ns1__queryDeviceSharerRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDeviceSharerReq:
		return soap_out__ns1__queryDeviceSharerReq(soap, "ns1:queryDeviceSharerReq", id, (const struct _ns1__queryDeviceSharerReq *)ptr, NULL);
	case SOAP_TYPE__ns1__nullifyDeviceSharerRes:
		return soap_out__ns1__nullifyDeviceSharerRes(soap, "ns1:nullifyDeviceSharerRes", id, (const struct _ns1__nullifyDeviceSharerRes *)ptr, NULL);
	case SOAP_TYPE__ns1__nullifyDeviceSharerReq:
		return soap_out__ns1__nullifyDeviceSharerReq(soap, "ns1:nullifyDeviceSharerReq", id, (const struct _ns1__nullifyDeviceSharerReq *)ptr, NULL);
	case SOAP_TYPE__ns1__addDeviceSharerRes:
		return soap_out__ns1__addDeviceSharerRes(soap, "ns1:addDeviceSharerRes", id, (const struct _ns1__addDeviceSharerRes *)ptr, NULL);
	case SOAP_TYPE__ns1__addDeviceSharerReq:
		return soap_out__ns1__addDeviceSharerReq(soap, "ns1:addDeviceSharerReq", id, (const struct _ns1__addDeviceSharerReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDeviceStatusRes:
		return soap_out__ns1__queryDeviceStatusRes(soap, "ns1:queryDeviceStatusRes", id, (const struct _ns1__queryDeviceStatusRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDeviceStatusReq:
		return soap_out__ns1__queryDeviceStatusReq(soap, "ns1:queryDeviceStatusReq", id, (const struct _ns1__queryDeviceStatusReq *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAndroidTokenRes:
		return soap_out__ns1__updateAndroidTokenRes(soap, "ns1:updateAndroidTokenRes", id, (const struct _ns1__updateAndroidTokenRes *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAndroidTokenReq:
		return soap_out__ns1__updateAndroidTokenReq(soap, "ns1:updateAndroidTokenReq", id, (const struct _ns1__updateAndroidTokenReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryPUEventLogRes:
		return soap_out__ns1__queryPUEventLogRes(soap, "ns1:queryPUEventLogRes", id, (const struct _ns1__queryPUEventLogRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryPUEventLogReq:
		return soap_out__ns1__queryPUEventLogReq(soap, "ns1:queryPUEventLogReq", id, (const struct _ns1__queryPUEventLogReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryPUOnOffLogRes:
		return soap_out__ns1__queryPUOnOffLogRes(soap, "ns1:queryPUOnOffLogRes", id, (const struct _ns1__queryPUOnOffLogRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryPUOnOffLogReq:
		return soap_out__ns1__queryPUOnOffLogReq(soap, "ns1:queryPUOnOffLogReq", id, (const struct _ns1__queryPUOnOffLogReq *)ptr, NULL);
	case SOAP_TYPE__ns1__inviteKeepAliveRes:
		return soap_out__ns1__inviteKeepAliveRes(soap, "ns1:inviteKeepAliveRes", id, (const struct _ns1__inviteKeepAliveRes *)ptr, NULL);
	case SOAP_TYPE__ns1__inviteKeepAliveReq:
		return soap_out__ns1__inviteKeepAliveReq(soap, "ns1:inviteKeepAliveReq", id, (const struct _ns1__inviteKeepAliveReq *)ptr, NULL);
	case SOAP_TYPE__ns1__notifyNATResultRes:
		return soap_out__ns1__notifyNATResultRes(soap, "ns1:notifyNATResultRes", id, (const struct _ns1__notifyNATResultRes *)ptr, NULL);
	case SOAP_TYPE__ns1__notifyNATResultReq:
		return soap_out__ns1__notifyNATResultReq(soap, "ns1:notifyNATResultReq", id, (const struct _ns1__notifyNATResultReq *)ptr, NULL);
	case SOAP_TYPE__ns1__subscribeEMailRes:
		return soap_out__ns1__subscribeEMailRes(soap, "ns1:subscribeEMailRes", id, (const struct _ns1__subscribeEMailRes *)ptr, NULL);
	case SOAP_TYPE__ns1__subscribeEMailReq:
		return soap_out__ns1__subscribeEMailReq(soap, "ns1:subscribeEMailReq", id, (const struct _ns1__subscribeEMailReq *)ptr, NULL);
	case SOAP_TYPE__ns1__subscribeSMSRes:
		return soap_out__ns1__subscribeSMSRes(soap, "ns1:subscribeSMSRes", id, (const struct _ns1__subscribeSMSRes *)ptr, NULL);
	case SOAP_TYPE__ns1__subscribeSMSReq:
		return soap_out__ns1__subscribeSMSReq(soap, "ns1:subscribeSMSReq", id, (const struct _ns1__subscribeSMSReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getNATServerRes:
		return soap_out__ns1__getNATServerRes(soap, "ns1:getNATServerRes", id, (const struct _ns1__getNATServerRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getNATServerReq:
		return soap_out__ns1__getNATServerReq(soap, "ns1:getNATServerReq", id, (const struct _ns1__getNATServerReq *)ptr, NULL);
	case SOAP_TYPE__ns1__byeRes:
		return soap_out__ns1__byeRes(soap, "ns1:byeRes", id, (const struct _ns1__byeRes *)ptr, NULL);
	case SOAP_TYPE__ns1__byeReq:
		return soap_out__ns1__byeReq(soap, "ns1:byeReq", id, (const struct _ns1__byeReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setAuxiliaryRes:
		return soap_out__ns1__setAuxiliaryRes(soap, "ns1:setAuxiliaryRes", id, (const struct _ns1__setAuxiliaryRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setAuxiliaryReq:
		return soap_out__ns1__setAuxiliaryReq(soap, "ns1:setAuxiliaryReq", id, (const struct _ns1__setAuxiliaryReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getAuxiliaryRes:
		return soap_out__ns1__getAuxiliaryRes(soap, "ns1:getAuxiliaryRes", id, (const struct _ns1__getAuxiliaryRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getAuxiliaryReq:
		return soap_out__ns1__getAuxiliaryReq(soap, "ns1:getAuxiliaryReq", id, (const struct _ns1__getAuxiliaryReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getBackPasswordRes:
		return soap_out__ns1__getBackPasswordRes(soap, "ns1:getBackPasswordRes", id, (const struct _ns1__getBackPasswordRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getBackPasswordReq:
		return soap_out__ns1__getBackPasswordReq(soap, "ns1:getBackPasswordReq", id, (const struct _ns1__getBackPasswordReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getAccountRes:
		return soap_out__ns1__getAccountRes(soap, "ns1:getAccountRes", id, (const struct _ns1__getAccountRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getAccountReq:
		return soap_out__ns1__getAccountReq(soap, "ns1:getAccountReq", id, (const struct _ns1__getAccountReq *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAppleTokenRes:
		return soap_out__ns1__updateAppleTokenRes(soap, "ns1:updateAppleTokenRes", id, (const struct _ns1__updateAppleTokenRes *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAppleTokenReq:
		return soap_out__ns1__updateAppleTokenReq(soap, "ns1:updateAppleTokenReq", id, (const struct _ns1__updateAppleTokenReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDeviceRes:
		return soap_out__ns1__queryDeviceRes(soap, "ns1:queryDeviceRes", id, (const struct _ns1__queryDeviceRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDeviceReq:
		return soap_out__ns1__queryDeviceReq(soap, "ns1:queryDeviceReq", id, (const struct _ns1__queryDeviceReq *)ptr, NULL);
	case SOAP_TYPE__ns1__updatePasswordRes:
		return soap_out__ns1__updatePasswordRes(soap, "ns1:updatePasswordRes", id, (const struct _ns1__updatePasswordRes *)ptr, NULL);
	case SOAP_TYPE__ns1__updatePasswordReq:
		return soap_out__ns1__updatePasswordReq(soap, "ns1:updatePasswordReq", id, (const struct _ns1__updatePasswordReq *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAccountRes:
		return soap_out__ns1__updateAccountRes(soap, "ns1:updateAccountRes", id, (const struct _ns1__updateAccountRes *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAccountReq:
		return soap_out__ns1__updateAccountReq(soap, "ns1:updateAccountReq", id, (const struct _ns1__updateAccountReq *)ptr, NULL);
	case SOAP_TYPE__ns1__createAccountRes:
		return soap_out__ns1__createAccountRes(soap, "ns1:createAccountRes", id, (const struct _ns1__createAccountRes *)ptr, NULL);
	case SOAP_TYPE__ns1__createAccountReq:
		return soap_out__ns1__createAccountReq(soap, "ns1:createAccountReq", id, (const struct _ns1__createAccountReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getPictureRes:
		return soap_out__ns1__getPictureRes(soap, "ns1:getPictureRes", id, (const struct _ns1__getPictureRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getPictureReq:
		return soap_out__ns1__getPictureReq(soap, "ns1:getPictureReq", id, (const struct _ns1__getPictureReq *)ptr, NULL);
	case SOAP_TYPE__ns1__flaggedNoticeStatusRes:
		return soap_out__ns1__flaggedNoticeStatusRes(soap, "ns1:flaggedNoticeStatusRes", id, (const struct _ns1__flaggedNoticeStatusRes *)ptr, NULL);
	case SOAP_TYPE__ns1__flaggedNoticeStatusReq:
		return soap_out__ns1__flaggedNoticeStatusReq(soap, "ns1:flaggedNoticeStatusReq", id, (const struct _ns1__flaggedNoticeStatusReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryNoticesRes:
		return soap_out__ns1__queryNoticesRes(soap, "ns1:queryNoticesRes", id, (const struct _ns1__queryNoticesRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryNoticesReq:
		return soap_out__ns1__queryNoticesReq(soap, "ns1:queryNoticesReq", id, (const struct _ns1__queryNoticesReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getDeviceMatchingResultRes:
		return soap_out__ns1__getDeviceMatchingResultRes(soap, "ns1:getDeviceMatchingResultRes", id, (const struct _ns1__getDeviceMatchingResultRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getDeviceMatchingResultReq:
		return soap_out__ns1__getDeviceMatchingResultReq(soap, "ns1:getDeviceMatchingResultReq", id, (const struct _ns1__getDeviceMatchingResultReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getDeviceMatchingCodeRes:
		return soap_out__ns1__getDeviceMatchingCodeRes(soap, "ns1:getDeviceMatchingCodeRes", id, (const struct _ns1__getDeviceMatchingCodeRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getDeviceMatchingCodeReq:
		return soap_out__ns1__getDeviceMatchingCodeReq(soap, "ns1:getDeviceMatchingCodeReq", id, (const struct _ns1__getDeviceMatchingCodeReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getDynamicPasswordRes:
		return soap_out__ns1__getDynamicPasswordRes(soap, "ns1:getDynamicPasswordRes", id, (const struct _ns1__getDynamicPasswordRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getDynamicPasswordReq:
		return soap_out__ns1__getDynamicPasswordReq(soap, "ns1:getDynamicPasswordReq", id, (const struct _ns1__getDynamicPasswordReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getWirelessNetworkRes:
		return soap_out__ns1__getWirelessNetworkRes(soap, "ns1:getWirelessNetworkRes", id, (const struct _ns1__getWirelessNetworkRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getWirelessNetworkReq:
		return soap_out__ns1__getWirelessNetworkReq(soap, "ns1:getWirelessNetworkReq", id, (const struct _ns1__getWirelessNetworkReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setRelayRes:
		return soap_out__ns1__setRelayRes(soap, "ns1:setRelayRes", id, (const struct _ns1__setRelayRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setRelayReq:
		return soap_out__ns1__setRelayReq(soap, "ns1:setRelayReq", id, (const struct _ns1__setRelayReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getRelayRes:
		return soap_out__ns1__getRelayRes(soap, "ns1:getRelayRes", id, (const struct _ns1__getRelayRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getRelayReq:
		return soap_out__ns1__getRelayReq(soap, "ns1:getRelayReq", id, (const struct _ns1__getRelayReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setRecordParamRes:
		return soap_out__ns1__setRecordParamRes(soap, "ns1:setRecordParamRes", id, (const struct _ns1__setRecordParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setRecordParamReq:
		return soap_out__ns1__setRecordParamReq(soap, "ns1:setRecordParamReq", id, (const struct _ns1__setRecordParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getRecordParamRes:
		return soap_out__ns1__getRecordParamRes(soap, "ns1:getRecordParamRes", id, (const struct _ns1__getRecordParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getRecordParamReq:
		return soap_out__ns1__getRecordParamReq(soap, "ns1:getRecordParamReq", id, (const struct _ns1__getRecordParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setPushWorkSheetRes:
		return soap_out__ns1__setPushWorkSheetRes(soap, "ns1:setPushWorkSheetRes", id, (const struct _ns1__setPushWorkSheetRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setPushWorkSheetReq:
		return soap_out__ns1__setPushWorkSheetReq(soap, "ns1:setPushWorkSheetReq", id, (const struct _ns1__setPushWorkSheetReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getPushWorkSheetRes:
		return soap_out__ns1__getPushWorkSheetRes(soap, "ns1:getPushWorkSheetRes", id, (const struct _ns1__getPushWorkSheetRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getPushWorkSheetReq:
		return soap_out__ns1__getPushWorkSheetReq(soap, "ns1:getPushWorkSheetReq", id, (const struct _ns1__getPushWorkSheetReq *)ptr, NULL);
	case SOAP_TYPE__ns1__subscribeAndroidPushRes:
		return soap_out__ns1__subscribeAndroidPushRes(soap, "ns1:subscribeAndroidPushRes", id, (const struct _ns1__subscribeAndroidPushRes *)ptr, NULL);
	case SOAP_TYPE__ns1__subscribeAndroidPushReq:
		return soap_out__ns1__subscribeAndroidPushReq(soap, "ns1:subscribeAndroidPushReq", id, (const struct _ns1__subscribeAndroidPushReq *)ptr, NULL);
	case SOAP_TYPE__ns1__subscribeApplePushRes:
		return soap_out__ns1__subscribeApplePushRes(soap, "ns1:subscribeApplePushRes", id, (const struct _ns1__subscribeApplePushRes *)ptr, NULL);
	case SOAP_TYPE__ns1__subscribeApplePushReq:
		return soap_out__ns1__subscribeApplePushReq(soap, "ns1:subscribeApplePushReq", id, (const struct _ns1__subscribeApplePushReq *)ptr, NULL);
	case SOAP_TYPE_ns1__VODRecord:
		return soap_out_ns1__VODRecord(soap, tag, id, (const struct ns1__VODRecord *)ptr, "ns1:VODRecord");
	case SOAP_TYPE_ns1__PrivacyMaskRegion:
		return soap_out_ns1__PrivacyMaskRegion(soap, tag, id, (const struct ns1__PrivacyMaskRegion *)ptr, "ns1:PrivacyMaskRegion");
	case SOAP_TYPE_ns1__VMDGrid:
		return soap_out_ns1__VMDGrid(soap, tag, id, (const struct ns1__VMDGrid *)ptr, "ns1:VMDGrid");
	case SOAP_TYPE_ns1__DevLog:
		return soap_out_ns1__DevLog(soap, tag, id, (const struct ns1__DevLog *)ptr, "ns1:DevLog");
	case SOAP_TYPE_ns1__ArrayOfDevLog:
		return soap_out_ns1__ArrayOfDevLog(soap, tag, id, (const struct ns1__ArrayOfDevLog *)ptr, "ns1:ArrayOfDevLog");
	case SOAP_TYPE_ns1__PuLog:
		return soap_out_ns1__PuLog(soap, tag, id, (const struct ns1__PuLog *)ptr, "ns1:PuLog");
	case SOAP_TYPE_ns1__ArrayOfPuLog:
		return soap_out_ns1__ArrayOfPuLog(soap, tag, id, (const struct ns1__ArrayOfPuLog *)ptr, "ns1:ArrayOfPuLog");
	case SOAP_TYPE_ns1__Device:
		return soap_out_ns1__Device(soap, tag, id, (const struct ns1__Device *)ptr, "ns1:Device");
	case SOAP_TYPE_ns1__ArrayOfDevice:
		return soap_out_ns1__ArrayOfDevice(soap, tag, id, (const struct ns1__ArrayOfDevice *)ptr, "ns1:ArrayOfDevice");
	case SOAP_TYPE_ns1__userLoginRes:
		return soap_out_ns1__userLoginRes(soap, tag, id, (const struct ns1__userLoginRes *)ptr, "ns1:userLoginRes");
	case SOAP_TYPE_ns1__userLoginReq:
		return soap_out_ns1__userLoginReq(soap, tag, id, (const struct ns1__userLoginReq *)ptr, "ns1:userLoginReq");
	case SOAP_TYPE_ns1__DeviceSharer:
		return soap_out_ns1__DeviceSharer(soap, tag, id, (const struct ns1__DeviceSharer *)ptr, "ns1:DeviceSharer");
	case SOAP_TYPE_ns1__ArrayOfDeviceSharer:
		return soap_out_ns1__ArrayOfDeviceSharer(soap, tag, id, (const struct ns1__ArrayOfDeviceSharer *)ptr, "ns1:ArrayOfDeviceSharer");
	case SOAP_TYPE_ns1__PUEventLog:
		return soap_out_ns1__PUEventLog(soap, tag, id, (const struct ns1__PUEventLog *)ptr, "ns1:PUEventLog");
	case SOAP_TYPE_ns1__ArrayOfPUEventLog:
		return soap_out_ns1__ArrayOfPUEventLog(soap, tag, id, (const struct ns1__ArrayOfPUEventLog *)ptr, "ns1:ArrayOfPUEventLog");
	case SOAP_TYPE_ns1__PUOnOffLog:
		return soap_out_ns1__PUOnOffLog(soap, tag, id, (const struct ns1__PUOnOffLog *)ptr, "ns1:PUOnOffLog");
	case SOAP_TYPE_ns1__ArrayOfPUOnOffLog:
		return soap_out_ns1__ArrayOfPUOnOffLog(soap, tag, id, (const struct ns1__ArrayOfPUOnOffLog *)ptr, "ns1:ArrayOfPUOnOffLog");
	case SOAP_TYPE_ns1__TURNServer:
		return soap_out_ns1__TURNServer(soap, tag, id, (const struct ns1__TURNServer *)ptr, "ns1:TURNServer");
	case SOAP_TYPE_ns1__ArrayOfTURNServer:
		return soap_out_ns1__ArrayOfTURNServer(soap, tag, id, (const struct ns1__ArrayOfTURNServer *)ptr, "ns1:ArrayOfTURNServer");
	case SOAP_TYPE_ns1__STUNServer:
		return soap_out_ns1__STUNServer(soap, tag, id, (const struct ns1__STUNServer *)ptr, "ns1:STUNServer");
	case SOAP_TYPE_ns1__ArrayOfSTUNServer:
		return soap_out_ns1__ArrayOfSTUNServer(soap, tag, id, (const struct ns1__ArrayOfSTUNServer *)ptr, "ns1:ArrayOfSTUNServer");
	case SOAP_TYPE_ns1__inviteRes:
		return soap_out_ns1__inviteRes(soap, tag, id, (const struct ns1__inviteRes *)ptr, "ns1:inviteRes");
	case SOAP_TYPE_ns1__inviteReq:
		return soap_out_ns1__inviteReq(soap, tag, id, (const struct ns1__inviteReq *)ptr, "ns1:inviteReq");
	case SOAP_TYPE_ns1__WirelessNetwork:
		return soap_out_ns1__WirelessNetwork(soap, tag, id, (const struct ns1__WirelessNetwork *)ptr, "ns1:WirelessNetwork");
	case SOAP_TYPE_ns1__NodeDetails:
		return soap_out_ns1__NodeDetails(soap, tag, id, (const struct ns1__NodeDetails *)ptr, "ns1:NodeDetails");
	case SOAP_TYPE_ns1__ArrayOfNodeDetails:
		return soap_out_ns1__ArrayOfNodeDetails(soap, tag, id, (const struct ns1__ArrayOfNodeDetails *)ptr, "ns1:ArrayOfNodeDetails");
	case SOAP_TYPE_ns1__ArrayOfString:
		return soap_out_ns1__ArrayOfString(soap, tag, id, (const struct ns1__ArrayOfString *)ptr, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__Notice:
		return soap_out_ns1__Notice(soap, tag, id, (const struct ns1__Notice *)ptr, "ns1:Notice");
	case SOAP_TYPE_ns1__ArrayOfNotice:
		return soap_out_ns1__ArrayOfNotice(soap, tag, id, (const struct ns1__ArrayOfNotice *)ptr, "ns1:ArrayOfNotice");
	case SOAP_TYPE_ns1__Dev:
		return soap_out_ns1__Dev(soap, tag, id, (const struct ns1__Dev *)ptr, "ns1:Dev");
	case SOAP_TYPE_ns1__ArrayOfDev:
		return soap_out_ns1__ArrayOfDev(soap, tag, id, (const struct ns1__ArrayOfDev *)ptr, "ns1:ArrayOfDev");
	case SOAP_TYPE_ns1__trustedAuthorityLoginRes:
		return soap_out_ns1__trustedAuthorityLoginRes(soap, tag, id, (const struct ns1__trustedAuthorityLoginRes *)ptr, "ns1:trustedAuthorityLoginRes");
	case SOAP_TYPE_ns1__MCUDev:
		return soap_out_ns1__MCUDev(soap, tag, id, (const struct ns1__MCUDev *)ptr, "ns1:MCUDev");
	case SOAP_TYPE_ns1__trustedAuthorityLoginReq:
		return soap_out_ns1__trustedAuthorityLoginReq(soap, tag, id, (const struct ns1__trustedAuthorityLoginReq *)ptr, "ns1:trustedAuthorityLoginReq");
	case SOAP_TYPE_ns1__Relay:
		return soap_out_ns1__Relay(soap, tag, id, (const struct ns1__Relay *)ptr, "ns1:Relay");
	case SOAP_TYPE_ns1__WorkSheet:
		return soap_out_ns1__WorkSheet(soap, tag, id, (const struct ns1__WorkSheet *)ptr, "ns1:WorkSheet");
	case SOAP_TYPE_PointerTo_ns1__vodSearchRes:
		return soap_out_PointerTo_ns1__vodSearchRes(soap, tag, id, (struct _ns1__vodSearchRes *const*)ptr, "ns1:vodSearchRes");
	case SOAP_TYPE_PointerTo_ns1__vodSearchReq:
		return soap_out_PointerTo_ns1__vodSearchReq(soap, tag, id, (struct _ns1__vodSearchReq *const*)ptr, "ns1:vodSearchReq");
	case SOAP_TYPE_PointerTo_ns1__getVODUrlRes:
		return soap_out_PointerTo_ns1__getVODUrlRes(soap, tag, id, (struct _ns1__getVODUrlRes *const*)ptr, "ns1:getVODUrlRes");
	case SOAP_TYPE_PointerTo_ns1__getVODUrlReq:
		return soap_out_PointerTo_ns1__getVODUrlReq(soap, tag, id, (struct _ns1__getVODUrlReq *const*)ptr, "ns1:getVODUrlReq");
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlRes:
		return soap_out_PointerTo_ns1__getPlayUrlRes(soap, tag, id, (struct _ns1__getPlayUrlRes *const*)ptr, "ns1:getPlayUrlRes");
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlReq:
		return soap_out_PointerTo_ns1__getPlayUrlReq(soap, tag, id, (struct _ns1__getPlayUrlReq *const*)ptr, "ns1:getPlayUrlReq");
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamRes:
		return soap_out_PointerTo_ns1__setPrivacyMaskParamRes(soap, tag, id, (struct _ns1__setPrivacyMaskParamRes *const*)ptr, "ns1:setPrivacyMaskParamRes");
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamReq:
		return soap_out_PointerTo_ns1__setPrivacyMaskParamReq(soap, tag, id, (struct _ns1__setPrivacyMaskParamReq *const*)ptr, "ns1:setPrivacyMaskParamReq");
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamRes:
		return soap_out_PointerTo_ns1__getPrivacyMaskParamRes(soap, tag, id, (struct _ns1__getPrivacyMaskParamRes *const*)ptr, "ns1:getPrivacyMaskParamRes");
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamReq:
		return soap_out_PointerTo_ns1__getPrivacyMaskParamReq(soap, tag, id, (struct _ns1__getPrivacyMaskParamReq *const*)ptr, "ns1:getPrivacyMaskParamReq");
	case SOAP_TYPE_PointerTo_ns1__setVMDParamRes:
		return soap_out_PointerTo_ns1__setVMDParamRes(soap, tag, id, (struct _ns1__setVMDParamRes *const*)ptr, "ns1:setVMDParamRes");
	case SOAP_TYPE_PointerTo_ns1__setVMDParamReq:
		return soap_out_PointerTo_ns1__setVMDParamReq(soap, tag, id, (struct _ns1__setVMDParamReq *const*)ptr, "ns1:setVMDParamReq");
	case SOAP_TYPE_PointerTo_ns1__getVMDParamRes:
		return soap_out_PointerTo_ns1__getVMDParamRes(soap, tag, id, (struct _ns1__getVMDParamRes *const*)ptr, "ns1:getVMDParamRes");
	case SOAP_TYPE_PointerTo_ns1__getVMDParamReq:
		return soap_out_PointerTo_ns1__getVMDParamReq(soap, tag, id, (struct _ns1__getVMDParamReq *const*)ptr, "ns1:getVMDParamReq");
	case SOAP_TYPE_PointerTo_ns1__setTimeRes:
		return soap_out_PointerTo_ns1__setTimeRes(soap, tag, id, (struct _ns1__setTimeRes *const*)ptr, "ns1:setTimeRes");
	case SOAP_TYPE_PointerTo_ns1__setTimeReq:
		return soap_out_PointerTo_ns1__setTimeReq(soap, tag, id, (struct _ns1__setTimeReq *const*)ptr, "ns1:setTimeReq");
	case SOAP_TYPE_PointerTo_ns1__getTimeRes:
		return soap_out_PointerTo_ns1__getTimeRes(soap, tag, id, (struct _ns1__getTimeRes *const*)ptr, "ns1:getTimeRes");
	case SOAP_TYPE_PointerTo_ns1__getTimeReq:
		return soap_out_PointerTo_ns1__getTimeReq(soap, tag, id, (struct _ns1__getTimeReq *const*)ptr, "ns1:getTimeReq");
	case SOAP_TYPE_PointerTo_ns1__setOSDParamRes:
		return soap_out_PointerTo_ns1__setOSDParamRes(soap, tag, id, (struct _ns1__setOSDParamRes *const*)ptr, "ns1:setOSDParamRes");
	case SOAP_TYPE_PointerTo_ns1__setOSDParamReq:
		return soap_out_PointerTo_ns1__setOSDParamReq(soap, tag, id, (struct _ns1__setOSDParamReq *const*)ptr, "ns1:setOSDParamReq");
	case SOAP_TYPE_PointerTo_ns1__getOSDParamRes:
		return soap_out_PointerTo_ns1__getOSDParamRes(soap, tag, id, (struct _ns1__getOSDParamRes *const*)ptr, "ns1:getOSDParamRes");
	case SOAP_TYPE_PointerTo_ns1__getOSDParamReq:
		return soap_out_PointerTo_ns1__getOSDParamReq(soap, tag, id, (struct _ns1__getOSDParamReq *const*)ptr, "ns1:getOSDParamReq");
	case SOAP_TYPE_PointerTo_ns1__setVideoParamRes:
		return soap_out_PointerTo_ns1__setVideoParamRes(soap, tag, id, (struct _ns1__setVideoParamRes *const*)ptr, "ns1:setVideoParamRes");
	case SOAP_TYPE_PointerTo_ns1__setVideoParamReq:
		return soap_out_PointerTo_ns1__setVideoParamReq(soap, tag, id, (struct _ns1__setVideoParamReq *const*)ptr, "ns1:setVideoParamReq");
	case SOAP_TYPE_PointerTo_ns1__getVideoParamRes:
		return soap_out_PointerTo_ns1__getVideoParamRes(soap, tag, id, (struct _ns1__getVideoParamRes *const*)ptr, "ns1:getVideoParamRes");
	case SOAP_TYPE_PointerTo_ns1__getVideoParamReq:
		return soap_out_PointerTo_ns1__getVideoParamReq(soap, tag, id, (struct _ns1__getVideoParamReq *const*)ptr, "ns1:getVideoParamReq");
	case SOAP_TYPE_PointerTo_ns1__queryDevLogRes:
		return soap_out_PointerTo_ns1__queryDevLogRes(soap, tag, id, (struct _ns1__queryDevLogRes *const*)ptr, "ns1:queryDevLogRes");
	case SOAP_TYPE_PointerTo_ns1__queryDevLogReq:
		return soap_out_PointerTo_ns1__queryDevLogReq(soap, tag, id, (struct _ns1__queryDevLogReq *const*)ptr, "ns1:queryDevLogReq");
	case SOAP_TYPE_PointerTo_ns1__queryLogRes:
		return soap_out_PointerTo_ns1__queryLogRes(soap, tag, id, (struct _ns1__queryLogRes *const*)ptr, "ns1:queryLogRes");
	case SOAP_TYPE_PointerTo_ns1__queryLogReq:
		return soap_out_PointerTo_ns1__queryLogReq(soap, tag, id, (struct _ns1__queryLogReq *const*)ptr, "ns1:queryLogReq");
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerRes:
		return soap_out_PointerTo_ns1__upgradeDevVerRes(soap, tag, id, (struct _ns1__upgradeDevVerRes *const*)ptr, "ns1:upgradeDevVerRes");
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerReq:
		return soap_out_PointerTo_ns1__upgradeDevVerReq(soap, tag, id, (struct _ns1__upgradeDevVerReq *const*)ptr, "ns1:upgradeDevVerReq");
	case SOAP_TYPE_PointerTo_ns1__getDevVerRes:
		return soap_out_PointerTo_ns1__getDevVerRes(soap, tag, id, (struct _ns1__getDevVerRes *const*)ptr, "ns1:getDevVerRes");
	case SOAP_TYPE_PointerTo_ns1__getDevVerReq:
		return soap_out_PointerTo_ns1__getDevVerReq(soap, tag, id, (struct _ns1__getDevVerReq *const*)ptr, "ns1:getDevVerReq");
	case SOAP_TYPE_PointerTo_ns1__rebootRes:
		return soap_out_PointerTo_ns1__rebootRes(soap, tag, id, (struct _ns1__rebootRes *const*)ptr, "ns1:rebootRes");
	case SOAP_TYPE_PointerTo_ns1__rebootReq:
		return soap_out_PointerTo_ns1__rebootReq(soap, tag, id, (struct _ns1__rebootReq *const*)ptr, "ns1:rebootReq");
	case SOAP_TYPE_PointerTo_ns1__setCodingParamRes:
		return soap_out_PointerTo_ns1__setCodingParamRes(soap, tag, id, (struct _ns1__setCodingParamRes *const*)ptr, "ns1:setCodingParamRes");
	case SOAP_TYPE_PointerTo_ns1__setCodingParamReq:
		return soap_out_PointerTo_ns1__setCodingParamReq(soap, tag, id, (struct _ns1__setCodingParamReq *const*)ptr, "ns1:setCodingParamReq");
	case SOAP_TYPE_PointerTo_ns1__getCodingParamRes:
		return soap_out_PointerTo_ns1__getCodingParamRes(soap, tag, id, (struct _ns1__getCodingParamRes *const*)ptr, "ns1:getCodingParamRes");
	case SOAP_TYPE_PointerTo_ns1__getCodingParamReq:
		return soap_out_PointerTo_ns1__getCodingParamReq(soap, tag, id, (struct _ns1__getCodingParamReq *const*)ptr, "ns1:getCodingParamReq");
	case SOAP_TYPE_PointerTo_ns1__presetControlRes:
		return soap_out_PointerTo_ns1__presetControlRes(soap, tag, id, (struct _ns1__presetControlRes *const*)ptr, "ns1:presetControlRes");
	case SOAP_TYPE_PointerTo_ns1__presetControlReq:
		return soap_out_PointerTo_ns1__presetControlReq(soap, tag, id, (struct _ns1__presetControlReq *const*)ptr, "ns1:presetControlReq");
	case SOAP_TYPE_PointerTo_ns1__lensControlRes:
		return soap_out_PointerTo_ns1__lensControlRes(soap, tag, id, (struct _ns1__lensControlRes *const*)ptr, "ns1:lensControlRes");
	case SOAP_TYPE_PointerTo_ns1__lensControlReq:
		return soap_out_PointerTo_ns1__lensControlReq(soap, tag, id, (struct _ns1__lensControlReq *const*)ptr, "ns1:lensControlReq");
	case SOAP_TYPE_PointerTo_ns1__ptzControlRes:
		return soap_out_PointerTo_ns1__ptzControlRes(soap, tag, id, (struct _ns1__ptzControlRes *const*)ptr, "ns1:ptzControlRes");
	case SOAP_TYPE_PointerTo_ns1__ptzControlReq:
		return soap_out_PointerTo_ns1__ptzControlReq(soap, tag, id, (struct _ns1__ptzControlReq *const*)ptr, "ns1:ptzControlReq");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceRes:
		return soap_out_PointerTo_ns1__nullifyDeviceRes(soap, tag, id, (struct _ns1__nullifyDeviceRes *const*)ptr, "ns1:nullifyDeviceRes");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceReq:
		return soap_out_PointerTo_ns1__nullifyDeviceReq(soap, tag, id, (struct _ns1__nullifyDeviceReq *const*)ptr, "ns1:nullifyDeviceReq");
	case SOAP_TYPE_PointerTo_ns1__addDeviceRes:
		return soap_out_PointerTo_ns1__addDeviceRes(soap, tag, id, (struct _ns1__addDeviceRes *const*)ptr, "ns1:addDeviceRes");
	case SOAP_TYPE_PointerTo_ns1__addDeviceReq:
		return soap_out_PointerTo_ns1__addDeviceReq(soap, tag, id, (struct _ns1__addDeviceReq *const*)ptr, "ns1:addDeviceReq");
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameRes:
		return soap_out_PointerTo_ns1__updateChannelNameRes(soap, tag, id, (struct _ns1__updateChannelNameRes *const*)ptr, "ns1:updateChannelNameRes");
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameReq:
		return soap_out_PointerTo_ns1__updateChannelNameReq(soap, tag, id, (struct _ns1__updateChannelNameReq *const*)ptr, "ns1:updateChannelNameReq");
	case SOAP_TYPE_PointerTo_ns1__userLogoutRes:
		return soap_out_PointerTo_ns1__userLogoutRes(soap, tag, id, (struct _ns1__userLogoutRes *const*)ptr, "ns1:userLogoutRes");
	case SOAP_TYPE_PointerTo_ns1__userLogoutReq:
		return soap_out_PointerTo_ns1__userLogoutReq(soap, tag, id, (struct _ns1__userLogoutReq *const*)ptr, "ns1:userLogoutReq");
	case SOAP_TYPE_PointerTons1__userLoginRes:
		return soap_out_PointerTons1__userLoginRes(soap, tag, id, (struct ns1__userLoginRes *const*)ptr, "ns1:userLoginRes");
	case SOAP_TYPE_PointerTons1__userLoginReq:
		return soap_out_PointerTons1__userLoginReq(soap, tag, id, (struct ns1__userLoginReq *const*)ptr, "ns1:userLoginReq");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceBondedRes:
		return soap_out_PointerTo_ns1__queryDeviceBondedRes(soap, tag, id, (struct _ns1__queryDeviceBondedRes *const*)ptr, "ns1:queryDeviceBondedRes");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceBondedReq:
		return soap_out_PointerTo_ns1__queryDeviceBondedReq(soap, tag, id, (struct _ns1__queryDeviceBondedReq *const*)ptr, "ns1:queryDeviceBondedReq");
	case SOAP_TYPE_PointerTo_ns1__queryClientVersionRes:
		return soap_out_PointerTo_ns1__queryClientVersionRes(soap, tag, id, (struct _ns1__queryClientVersionRes *const*)ptr, "ns1:queryClientVersionRes");
	case SOAP_TYPE_PointerTo_ns1__queryClientVersionReq:
		return soap_out_PointerTo_ns1__queryClientVersionReq(soap, tag, id, (struct _ns1__queryClientVersionReq *const*)ptr, "ns1:queryClientVersionReq");
	case SOAP_TYPE_PointerTo_ns1__queryAndroidTokenRes:
		return soap_out_PointerTo_ns1__queryAndroidTokenRes(soap, tag, id, (struct _ns1__queryAndroidTokenRes *const*)ptr, "ns1:queryAndroidTokenRes");
	case SOAP_TYPE_PointerTo_ns1__queryAndroidTokenReq:
		return soap_out_PointerTo_ns1__queryAndroidTokenReq(soap, tag, id, (struct _ns1__queryAndroidTokenReq *const*)ptr, "ns1:queryAndroidTokenReq");
	case SOAP_TYPE_PointerTo_ns1__queryAppleTokenRes:
		return soap_out_PointerTo_ns1__queryAppleTokenRes(soap, tag, id, (struct _ns1__queryAppleTokenRes *const*)ptr, "ns1:queryAppleTokenRes");
	case SOAP_TYPE_PointerTo_ns1__queryAppleTokenReq:
		return soap_out_PointerTo_ns1__queryAppleTokenReq(soap, tag, id, (struct _ns1__queryAppleTokenReq *const*)ptr, "ns1:queryAppleTokenReq");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceSharingSourceRes:
		return soap_out_PointerTo_ns1__queryDeviceSharingSourceRes(soap, tag, id, (struct _ns1__queryDeviceSharingSourceRes *const*)ptr, "ns1:queryDeviceSharingSourceRes");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceSharingSourceReq:
		return soap_out_PointerTo_ns1__queryDeviceSharingSourceReq(soap, tag, id, (struct _ns1__queryDeviceSharingSourceReq *const*)ptr, "ns1:queryDeviceSharingSourceReq");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceSharerRes:
		return soap_out_PointerTo_ns1__queryDeviceSharerRes(soap, tag, id, (struct _ns1__queryDeviceSharerRes *const*)ptr, "ns1:queryDeviceSharerRes");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceSharerReq:
		return soap_out_PointerTo_ns1__queryDeviceSharerReq(soap, tag, id, (struct _ns1__queryDeviceSharerReq *const*)ptr, "ns1:queryDeviceSharerReq");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceSharerRes:
		return soap_out_PointerTo_ns1__nullifyDeviceSharerRes(soap, tag, id, (struct _ns1__nullifyDeviceSharerRes *const*)ptr, "ns1:nullifyDeviceSharerRes");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceSharerReq:
		return soap_out_PointerTo_ns1__nullifyDeviceSharerReq(soap, tag, id, (struct _ns1__nullifyDeviceSharerReq *const*)ptr, "ns1:nullifyDeviceSharerReq");
	case SOAP_TYPE_PointerTo_ns1__addDeviceSharerRes:
		return soap_out_PointerTo_ns1__addDeviceSharerRes(soap, tag, id, (struct _ns1__addDeviceSharerRes *const*)ptr, "ns1:addDeviceSharerRes");
	case SOAP_TYPE_PointerTo_ns1__addDeviceSharerReq:
		return soap_out_PointerTo_ns1__addDeviceSharerReq(soap, tag, id, (struct _ns1__addDeviceSharerReq *const*)ptr, "ns1:addDeviceSharerReq");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceStatusRes:
		return soap_out_PointerTo_ns1__queryDeviceStatusRes(soap, tag, id, (struct _ns1__queryDeviceStatusRes *const*)ptr, "ns1:queryDeviceStatusRes");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceStatusReq:
		return soap_out_PointerTo_ns1__queryDeviceStatusReq(soap, tag, id, (struct _ns1__queryDeviceStatusReq *const*)ptr, "ns1:queryDeviceStatusReq");
	case SOAP_TYPE_PointerTo_ns1__updateAndroidTokenRes:
		return soap_out_PointerTo_ns1__updateAndroidTokenRes(soap, tag, id, (struct _ns1__updateAndroidTokenRes *const*)ptr, "ns1:updateAndroidTokenRes");
	case SOAP_TYPE_PointerTo_ns1__updateAndroidTokenReq:
		return soap_out_PointerTo_ns1__updateAndroidTokenReq(soap, tag, id, (struct _ns1__updateAndroidTokenReq *const*)ptr, "ns1:updateAndroidTokenReq");
	case SOAP_TYPE_PointerTo_ns1__queryPUEventLogRes:
		return soap_out_PointerTo_ns1__queryPUEventLogRes(soap, tag, id, (struct _ns1__queryPUEventLogRes *const*)ptr, "ns1:queryPUEventLogRes");
	case SOAP_TYPE_PointerTo_ns1__queryPUEventLogReq:
		return soap_out_PointerTo_ns1__queryPUEventLogReq(soap, tag, id, (struct _ns1__queryPUEventLogReq *const*)ptr, "ns1:queryPUEventLogReq");
	case SOAP_TYPE_PointerTo_ns1__queryPUOnOffLogRes:
		return soap_out_PointerTo_ns1__queryPUOnOffLogRes(soap, tag, id, (struct _ns1__queryPUOnOffLogRes *const*)ptr, "ns1:queryPUOnOffLogRes");
	case SOAP_TYPE_PointerTo_ns1__queryPUOnOffLogReq:
		return soap_out_PointerTo_ns1__queryPUOnOffLogReq(soap, tag, id, (struct _ns1__queryPUOnOffLogReq *const*)ptr, "ns1:queryPUOnOffLogReq");
	case SOAP_TYPE_PointerTo_ns1__inviteKeepAliveRes:
		return soap_out_PointerTo_ns1__inviteKeepAliveRes(soap, tag, id, (struct _ns1__inviteKeepAliveRes *const*)ptr, "ns1:inviteKeepAliveRes");
	case SOAP_TYPE_PointerTo_ns1__inviteKeepAliveReq:
		return soap_out_PointerTo_ns1__inviteKeepAliveReq(soap, tag, id, (struct _ns1__inviteKeepAliveReq *const*)ptr, "ns1:inviteKeepAliveReq");
	case SOAP_TYPE_PointerTo_ns1__notifyNATResultRes:
		return soap_out_PointerTo_ns1__notifyNATResultRes(soap, tag, id, (struct _ns1__notifyNATResultRes *const*)ptr, "ns1:notifyNATResultRes");
	case SOAP_TYPE_PointerTo_ns1__notifyNATResultReq:
		return soap_out_PointerTo_ns1__notifyNATResultReq(soap, tag, id, (struct _ns1__notifyNATResultReq *const*)ptr, "ns1:notifyNATResultReq");
	case SOAP_TYPE_PointerTo_ns1__subscribeEMailRes:
		return soap_out_PointerTo_ns1__subscribeEMailRes(soap, tag, id, (struct _ns1__subscribeEMailRes *const*)ptr, "ns1:subscribeEMailRes");
	case SOAP_TYPE_PointerTo_ns1__subscribeEMailReq:
		return soap_out_PointerTo_ns1__subscribeEMailReq(soap, tag, id, (struct _ns1__subscribeEMailReq *const*)ptr, "ns1:subscribeEMailReq");
	case SOAP_TYPE_PointerTo_ns1__subscribeSMSRes:
		return soap_out_PointerTo_ns1__subscribeSMSRes(soap, tag, id, (struct _ns1__subscribeSMSRes *const*)ptr, "ns1:subscribeSMSRes");
	case SOAP_TYPE_PointerTo_ns1__subscribeSMSReq:
		return soap_out_PointerTo_ns1__subscribeSMSReq(soap, tag, id, (struct _ns1__subscribeSMSReq *const*)ptr, "ns1:subscribeSMSReq");
	case SOAP_TYPE_PointerTo_ns1__getNATServerRes:
		return soap_out_PointerTo_ns1__getNATServerRes(soap, tag, id, (struct _ns1__getNATServerRes *const*)ptr, "ns1:getNATServerRes");
	case SOAP_TYPE_PointerTo_ns1__getNATServerReq:
		return soap_out_PointerTo_ns1__getNATServerReq(soap, tag, id, (struct _ns1__getNATServerReq *const*)ptr, "ns1:getNATServerReq");
	case SOAP_TYPE_PointerTo_ns1__byeRes:
		return soap_out_PointerTo_ns1__byeRes(soap, tag, id, (struct _ns1__byeRes *const*)ptr, "ns1:byeRes");
	case SOAP_TYPE_PointerTo_ns1__byeReq:
		return soap_out_PointerTo_ns1__byeReq(soap, tag, id, (struct _ns1__byeReq *const*)ptr, "ns1:byeReq");
	case SOAP_TYPE_PointerTons1__inviteRes:
		return soap_out_PointerTons1__inviteRes(soap, tag, id, (struct ns1__inviteRes *const*)ptr, "ns1:inviteRes");
	case SOAP_TYPE_PointerTons1__inviteReq:
		return soap_out_PointerTons1__inviteReq(soap, tag, id, (struct ns1__inviteReq *const*)ptr, "ns1:inviteReq");
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryRes:
		return soap_out_PointerTo_ns1__setAuxiliaryRes(soap, tag, id, (struct _ns1__setAuxiliaryRes *const*)ptr, "ns1:setAuxiliaryRes");
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryReq:
		return soap_out_PointerTo_ns1__setAuxiliaryReq(soap, tag, id, (struct _ns1__setAuxiliaryReq *const*)ptr, "ns1:setAuxiliaryReq");
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryRes:
		return soap_out_PointerTo_ns1__getAuxiliaryRes(soap, tag, id, (struct _ns1__getAuxiliaryRes *const*)ptr, "ns1:getAuxiliaryRes");
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryReq:
		return soap_out_PointerTo_ns1__getAuxiliaryReq(soap, tag, id, (struct _ns1__getAuxiliaryReq *const*)ptr, "ns1:getAuxiliaryReq");
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordRes:
		return soap_out_PointerTo_ns1__getBackPasswordRes(soap, tag, id, (struct _ns1__getBackPasswordRes *const*)ptr, "ns1:getBackPasswordRes");
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordReq:
		return soap_out_PointerTo_ns1__getBackPasswordReq(soap, tag, id, (struct _ns1__getBackPasswordReq *const*)ptr, "ns1:getBackPasswordReq");
	case SOAP_TYPE_PointerTo_ns1__getAccountRes:
		return soap_out_PointerTo_ns1__getAccountRes(soap, tag, id, (struct _ns1__getAccountRes *const*)ptr, "ns1:getAccountRes");
	case SOAP_TYPE_PointerTo_ns1__getAccountReq:
		return soap_out_PointerTo_ns1__getAccountReq(soap, tag, id, (struct _ns1__getAccountReq *const*)ptr, "ns1:getAccountReq");
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenRes:
		return soap_out_PointerTo_ns1__updateAppleTokenRes(soap, tag, id, (struct _ns1__updateAppleTokenRes *const*)ptr, "ns1:updateAppleTokenRes");
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenReq:
		return soap_out_PointerTo_ns1__updateAppleTokenReq(soap, tag, id, (struct _ns1__updateAppleTokenReq *const*)ptr, "ns1:updateAppleTokenReq");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceRes:
		return soap_out_PointerTo_ns1__queryDeviceRes(soap, tag, id, (struct _ns1__queryDeviceRes *const*)ptr, "ns1:queryDeviceRes");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceReq:
		return soap_out_PointerTo_ns1__queryDeviceReq(soap, tag, id, (struct _ns1__queryDeviceReq *const*)ptr, "ns1:queryDeviceReq");
	case SOAP_TYPE_PointerTo_ns1__updatePasswordRes:
		return soap_out_PointerTo_ns1__updatePasswordRes(soap, tag, id, (struct _ns1__updatePasswordRes *const*)ptr, "ns1:updatePasswordRes");
	case SOAP_TYPE_PointerTo_ns1__updatePasswordReq:
		return soap_out_PointerTo_ns1__updatePasswordReq(soap, tag, id, (struct _ns1__updatePasswordReq *const*)ptr, "ns1:updatePasswordReq");
	case SOAP_TYPE_PointerTo_ns1__updateAccountRes:
		return soap_out_PointerTo_ns1__updateAccountRes(soap, tag, id, (struct _ns1__updateAccountRes *const*)ptr, "ns1:updateAccountRes");
	case SOAP_TYPE_PointerTo_ns1__updateAccountReq:
		return soap_out_PointerTo_ns1__updateAccountReq(soap, tag, id, (struct _ns1__updateAccountReq *const*)ptr, "ns1:updateAccountReq");
	case SOAP_TYPE_PointerTo_ns1__createAccountRes:
		return soap_out_PointerTo_ns1__createAccountRes(soap, tag, id, (struct _ns1__createAccountRes *const*)ptr, "ns1:createAccountRes");
	case SOAP_TYPE_PointerTo_ns1__createAccountReq:
		return soap_out_PointerTo_ns1__createAccountReq(soap, tag, id, (struct _ns1__createAccountReq *const*)ptr, "ns1:createAccountReq");
	case SOAP_TYPE_PointerTo_ns1__getPictureRes:
		return soap_out_PointerTo_ns1__getPictureRes(soap, tag, id, (struct _ns1__getPictureRes *const*)ptr, "ns1:getPictureRes");
	case SOAP_TYPE_PointerTo_ns1__getPictureReq:
		return soap_out_PointerTo_ns1__getPictureReq(soap, tag, id, (struct _ns1__getPictureReq *const*)ptr, "ns1:getPictureReq");
	case SOAP_TYPE_PointerTo_ns1__flaggedNoticeStatusRes:
		return soap_out_PointerTo_ns1__flaggedNoticeStatusRes(soap, tag, id, (struct _ns1__flaggedNoticeStatusRes *const*)ptr, "ns1:flaggedNoticeStatusRes");
	case SOAP_TYPE_PointerTo_ns1__flaggedNoticeStatusReq:
		return soap_out_PointerTo_ns1__flaggedNoticeStatusReq(soap, tag, id, (struct _ns1__flaggedNoticeStatusReq *const*)ptr, "ns1:flaggedNoticeStatusReq");
	case SOAP_TYPE_PointerTo_ns1__queryNoticesRes:
		return soap_out_PointerTo_ns1__queryNoticesRes(soap, tag, id, (struct _ns1__queryNoticesRes *const*)ptr, "ns1:queryNoticesRes");
	case SOAP_TYPE_PointerTo_ns1__queryNoticesReq:
		return soap_out_PointerTo_ns1__queryNoticesReq(soap, tag, id, (struct _ns1__queryNoticesReq *const*)ptr, "ns1:queryNoticesReq");
	case SOAP_TYPE_PointerTons1__trustedAuthorityLoginRes:
		return soap_out_PointerTons1__trustedAuthorityLoginRes(soap, tag, id, (struct ns1__trustedAuthorityLoginRes *const*)ptr, "ns1:trustedAuthorityLoginRes");
	case SOAP_TYPE_PointerTons1__trustedAuthorityLoginReq:
		return soap_out_PointerTons1__trustedAuthorityLoginReq(soap, tag, id, (struct ns1__trustedAuthorityLoginReq *const*)ptr, "ns1:trustedAuthorityLoginReq");
	case SOAP_TYPE_PointerTo_ns1__getDeviceMatchingResultRes:
		return soap_out_PointerTo_ns1__getDeviceMatchingResultRes(soap, tag, id, (struct _ns1__getDeviceMatchingResultRes *const*)ptr, "ns1:getDeviceMatchingResultRes");
	case SOAP_TYPE_PointerTo_ns1__getDeviceMatchingResultReq:
		return soap_out_PointerTo_ns1__getDeviceMatchingResultReq(soap, tag, id, (struct _ns1__getDeviceMatchingResultReq *const*)ptr, "ns1:getDeviceMatchingResultReq");
	case SOAP_TYPE_PointerTo_ns1__getDeviceMatchingCodeRes:
		return soap_out_PointerTo_ns1__getDeviceMatchingCodeRes(soap, tag, id, (struct _ns1__getDeviceMatchingCodeRes *const*)ptr, "ns1:getDeviceMatchingCodeRes");
	case SOAP_TYPE_PointerTo_ns1__getDeviceMatchingCodeReq:
		return soap_out_PointerTo_ns1__getDeviceMatchingCodeReq(soap, tag, id, (struct _ns1__getDeviceMatchingCodeReq *const*)ptr, "ns1:getDeviceMatchingCodeReq");
	case SOAP_TYPE_PointerTo_ns1__getDynamicPasswordRes:
		return soap_out_PointerTo_ns1__getDynamicPasswordRes(soap, tag, id, (struct _ns1__getDynamicPasswordRes *const*)ptr, "ns1:getDynamicPasswordRes");
	case SOAP_TYPE_PointerTo_ns1__getDynamicPasswordReq:
		return soap_out_PointerTo_ns1__getDynamicPasswordReq(soap, tag, id, (struct _ns1__getDynamicPasswordReq *const*)ptr, "ns1:getDynamicPasswordReq");
	case SOAP_TYPE_PointerTo_ns1__getWirelessNetworkRes:
		return soap_out_PointerTo_ns1__getWirelessNetworkRes(soap, tag, id, (struct _ns1__getWirelessNetworkRes *const*)ptr, "ns1:getWirelessNetworkRes");
	case SOAP_TYPE_PointerTo_ns1__getWirelessNetworkReq:
		return soap_out_PointerTo_ns1__getWirelessNetworkReq(soap, tag, id, (struct _ns1__getWirelessNetworkReq *const*)ptr, "ns1:getWirelessNetworkReq");
	case SOAP_TYPE_PointerTo_ns1__setRelayRes:
		return soap_out_PointerTo_ns1__setRelayRes(soap, tag, id, (struct _ns1__setRelayRes *const*)ptr, "ns1:setRelayRes");
	case SOAP_TYPE_PointerTo_ns1__setRelayReq:
		return soap_out_PointerTo_ns1__setRelayReq(soap, tag, id, (struct _ns1__setRelayReq *const*)ptr, "ns1:setRelayReq");
	case SOAP_TYPE_PointerTo_ns1__getRelayRes:
		return soap_out_PointerTo_ns1__getRelayRes(soap, tag, id, (struct _ns1__getRelayRes *const*)ptr, "ns1:getRelayRes");
	case SOAP_TYPE_PointerTo_ns1__getRelayReq:
		return soap_out_PointerTo_ns1__getRelayReq(soap, tag, id, (struct _ns1__getRelayReq *const*)ptr, "ns1:getRelayReq");
	case SOAP_TYPE_PointerTo_ns1__setRecordParamRes:
		return soap_out_PointerTo_ns1__setRecordParamRes(soap, tag, id, (struct _ns1__setRecordParamRes *const*)ptr, "ns1:setRecordParamRes");
	case SOAP_TYPE_PointerTo_ns1__setRecordParamReq:
		return soap_out_PointerTo_ns1__setRecordParamReq(soap, tag, id, (struct _ns1__setRecordParamReq *const*)ptr, "ns1:setRecordParamReq");
	case SOAP_TYPE_PointerTo_ns1__getRecordParamRes:
		return soap_out_PointerTo_ns1__getRecordParamRes(soap, tag, id, (struct _ns1__getRecordParamRes *const*)ptr, "ns1:getRecordParamRes");
	case SOAP_TYPE_PointerTo_ns1__getRecordParamReq:
		return soap_out_PointerTo_ns1__getRecordParamReq(soap, tag, id, (struct _ns1__getRecordParamReq *const*)ptr, "ns1:getRecordParamReq");
	case SOAP_TYPE_PointerTo_ns1__setPushWorkSheetRes:
		return soap_out_PointerTo_ns1__setPushWorkSheetRes(soap, tag, id, (struct _ns1__setPushWorkSheetRes *const*)ptr, "ns1:setPushWorkSheetRes");
	case SOAP_TYPE_PointerTo_ns1__setPushWorkSheetReq:
		return soap_out_PointerTo_ns1__setPushWorkSheetReq(soap, tag, id, (struct _ns1__setPushWorkSheetReq *const*)ptr, "ns1:setPushWorkSheetReq");
	case SOAP_TYPE_PointerTo_ns1__getPushWorkSheetRes:
		return soap_out_PointerTo_ns1__getPushWorkSheetRes(soap, tag, id, (struct _ns1__getPushWorkSheetRes *const*)ptr, "ns1:getPushWorkSheetRes");
	case SOAP_TYPE_PointerTo_ns1__getPushWorkSheetReq:
		return soap_out_PointerTo_ns1__getPushWorkSheetReq(soap, tag, id, (struct _ns1__getPushWorkSheetReq *const*)ptr, "ns1:getPushWorkSheetReq");
	case SOAP_TYPE_PointerTo_ns1__subscribeAndroidPushRes:
		return soap_out_PointerTo_ns1__subscribeAndroidPushRes(soap, tag, id, (struct _ns1__subscribeAndroidPushRes *const*)ptr, "ns1:subscribeAndroidPushRes");
	case SOAP_TYPE_PointerTo_ns1__subscribeAndroidPushReq:
		return soap_out_PointerTo_ns1__subscribeAndroidPushReq(soap, tag, id, (struct _ns1__subscribeAndroidPushReq *const*)ptr, "ns1:subscribeAndroidPushReq");
	case SOAP_TYPE_PointerTo_ns1__subscribeApplePushRes:
		return soap_out_PointerTo_ns1__subscribeApplePushRes(soap, tag, id, (struct _ns1__subscribeApplePushRes *const*)ptr, "ns1:subscribeApplePushRes");
	case SOAP_TYPE_PointerTo_ns1__subscribeApplePushReq:
		return soap_out_PointerTo_ns1__subscribeApplePushReq(soap, tag, id, (struct _ns1__subscribeApplePushReq *const*)ptr, "ns1:subscribeApplePushReq");
	case SOAP_TYPE_PointerTons1__VODRecord:
		return soap_out_PointerTons1__VODRecord(soap, tag, id, (struct ns1__VODRecord *const*)ptr, "ns1:VODRecord");
	case SOAP_TYPE_PointerTons1__PrivacyMaskRegion:
		return soap_out_PointerTons1__PrivacyMaskRegion(soap, tag, id, (struct ns1__PrivacyMaskRegion *const*)ptr, "ns1:PrivacyMaskRegion");
	case SOAP_TYPE_PointerTons1__VMDGrid:
		return soap_out_PointerTons1__VMDGrid(soap, tag, id, (struct ns1__VMDGrid *const*)ptr, "ns1:VMDGrid");
	case SOAP_TYPE_PointerTons1__VideoStandard:
		return soap_out_PointerTons1__VideoStandard(soap, tag, id, (enum ns1__VideoStandard *const*)ptr, "ns1:VideoStandard");
	case SOAP_TYPE_PointerTons1__ArrayOfDevLog:
		return soap_out_PointerTons1__ArrayOfDevLog(soap, tag, id, (struct ns1__ArrayOfDevLog *const*)ptr, "ns1:ArrayOfDevLog");
	case SOAP_TYPE_PointerTons1__ArrayOfPuLog:
		return soap_out_PointerTons1__ArrayOfPuLog(soap, tag, id, (struct ns1__ArrayOfPuLog *const*)ptr, "ns1:ArrayOfPuLog");
	case SOAP_TYPE_PointerTons1__RateType:
		return soap_out_PointerTons1__RateType(soap, tag, id, (enum ns1__RateType *const*)ptr, "ns1:RateType");
	case SOAP_TYPE_PointerTons1__FrameSize:
		return soap_out_PointerTons1__FrameSize(soap, tag, id, (enum ns1__FrameSize *const*)ptr, "ns1:FrameSize");
	case SOAP_TYPE_PointerTons1__ArrayOfDevice:
		return soap_out_PointerTons1__ArrayOfDevice(soap, tag, id, (struct ns1__ArrayOfDevice *const*)ptr, "ns1:ArrayOfDevice");
	case SOAP_TYPE_PointerTons1__ArrayOfDeviceSharer:
		return soap_out_PointerTons1__ArrayOfDeviceSharer(soap, tag, id, (struct ns1__ArrayOfDeviceSharer *const*)ptr, "ns1:ArrayOfDeviceSharer");
	case SOAP_TYPE_PointerTons1__ArrayOfPUEventLog:
		return soap_out_PointerTons1__ArrayOfPUEventLog(soap, tag, id, (struct ns1__ArrayOfPUEventLog *const*)ptr, "ns1:ArrayOfPUEventLog");
	case SOAP_TYPE_PointerTons1__EventState:
		return soap_out_PointerTons1__EventState(soap, tag, id, (enum ns1__EventState *const*)ptr, "ns1:EventState");
	case SOAP_TYPE_PointerTons1__EventType:
		return soap_out_PointerTons1__EventType(soap, tag, id, (enum ns1__EventType *const*)ptr, "ns1:EventType");
	case SOAP_TYPE_PointerTons1__ArrayOfPUOnOffLog:
		return soap_out_PointerTons1__ArrayOfPUOnOffLog(soap, tag, id, (struct ns1__ArrayOfPUOnOffLog *const*)ptr, "ns1:ArrayOfPUOnOffLog");
	case SOAP_TYPE_PointerTons1__ArrayOfTURNServer:
		return soap_out_PointerTons1__ArrayOfTURNServer(soap, tag, id, (struct ns1__ArrayOfTURNServer *const*)ptr, "ns1:ArrayOfTURNServer");
	case SOAP_TYPE_PointerTons1__ArrayOfSTUNServer:
		return soap_out_PointerTons1__ArrayOfSTUNServer(soap, tag, id, (struct ns1__ArrayOfSTUNServer *const*)ptr, "ns1:ArrayOfSTUNServer");
	case SOAP_TYPE_PointerTons1__AuxiliaryType:
		return soap_out_PointerTons1__AuxiliaryType(soap, tag, id, (enum ns1__AuxiliaryType *const*)ptr, "ns1:AuxiliaryType");
	case SOAP_TYPE_PointerTons1__AuxiliaryState:
		return soap_out_PointerTons1__AuxiliaryState(soap, tag, id, (enum ns1__AuxiliaryState *const*)ptr, "ns1:AuxiliaryState");
	case SOAP_TYPE_PointerTons1__ArrayOfNodeDetails:
		return soap_out_PointerTons1__ArrayOfNodeDetails(soap, tag, id, (struct ns1__ArrayOfNodeDetails *const*)ptr, "ns1:ArrayOfNodeDetails");
	case SOAP_TYPE_PointerTons1__CountryAbbr2ISO3166:
		return soap_out_PointerTons1__CountryAbbr2ISO3166(soap, tag, id, (enum ns1__CountryAbbr2ISO3166 *const*)ptr, "ns1:CountryAbbr2ISO3166");
	case SOAP_TYPE_PointerTons1__ArrayOfNotice:
		return soap_out_PointerTons1__ArrayOfNotice(soap, tag, id, (struct ns1__ArrayOfNotice *const*)ptr, "ns1:ArrayOfNotice");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__NoticeStatus:
		return soap_out_PointerTons1__NoticeStatus(soap, tag, id, (enum ns1__NoticeStatus *const*)ptr, "ns1:NoticeStatus");
	case SOAP_TYPE_PointerTons1__Relay:
		return soap_out_PointerTons1__Relay(soap, tag, id, (struct ns1__Relay *const*)ptr, "ns1:Relay");
	case SOAP_TYPE_PointerTons1__WorkSheet:
		return soap_out_PointerTons1__WorkSheet(soap, tag, id, (struct ns1__WorkSheet *const*)ptr, "ns1:WorkSheet");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerTons1__DevLog:
		return soap_out_PointerTons1__DevLog(soap, tag, id, (struct ns1__DevLog *const*)ptr, "ns1:DevLog");
	case SOAP_TYPE_PointerTons1__PuLog:
		return soap_out_PointerTons1__PuLog(soap, tag, id, (struct ns1__PuLog *const*)ptr, "ns1:PuLog");
	case SOAP_TYPE_PointerTons1__Device:
		return soap_out_PointerTons1__Device(soap, tag, id, (struct ns1__Device *const*)ptr, "ns1:Device");
	case SOAP_TYPE_PointerTons1__DeviceSharer:
		return soap_out_PointerTons1__DeviceSharer(soap, tag, id, (struct ns1__DeviceSharer *const*)ptr, "ns1:DeviceSharer");
	case SOAP_TYPE_PointerTons1__PUEventLog:
		return soap_out_PointerTons1__PUEventLog(soap, tag, id, (struct ns1__PUEventLog *const*)ptr, "ns1:PUEventLog");
	case SOAP_TYPE_PointerTons1__PUOnOffLog:
		return soap_out_PointerTons1__PUOnOffLog(soap, tag, id, (struct ns1__PUOnOffLog *const*)ptr, "ns1:PUOnOffLog");
	case SOAP_TYPE_PointerTons1__TURNServer:
		return soap_out_PointerTons1__TURNServer(soap, tag, id, (struct ns1__TURNServer *const*)ptr, "ns1:TURNServer");
	case SOAP_TYPE_PointerTons1__STUNServer:
		return soap_out_PointerTons1__STUNServer(soap, tag, id, (struct ns1__STUNServer *const*)ptr, "ns1:STUNServer");
	case SOAP_TYPE_PointerTons1__WirelessNetwork:
		return soap_out_PointerTons1__WirelessNetwork(soap, tag, id, (struct ns1__WirelessNetwork *const*)ptr, "ns1:WirelessNetwork");
	case SOAP_TYPE_PointerTons1__NodeDetails:
		return soap_out_PointerTons1__NodeDetails(soap, tag, id, (struct ns1__NodeDetails *const*)ptr, "ns1:NodeDetails");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_out_PointerTons1__ArrayOfString(soap, tag, id, (struct ns1__ArrayOfString *const*)ptr, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTons1__Notice:
		return soap_out_PointerTons1__Notice(soap, tag, id, (struct ns1__Notice *const*)ptr, "ns1:Notice");
	case SOAP_TYPE_PointerTons1__Dev:
		return soap_out_PointerTons1__Dev(soap, tag, id, (struct ns1__Dev *const*)ptr, "ns1:Dev");
	case SOAP_TYPE_PointerTons1__ArrayOfDev:
		return soap_out_PointerTons1__ArrayOfDev(soap, tag, id, (struct ns1__ArrayOfDev *const*)ptr, "ns1:ArrayOfDev");
	case SOAP_TYPE_PointerTons1__MCUDev:
		return soap_out_PointerTons1__MCUDev(soap, tag, id, (struct ns1__MCUDev *const*)ptr, "ns1:MCUDev");
	case SOAP_TYPE_PointerTons1__RelayState:
		return soap_out_PointerTons1__RelayState(soap, tag, id, (enum ns1__RelayState *const*)ptr, "ns1:RelayState");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_out_PointerToxsd__boolean(soap, tag, id, (enum xsd__boolean *const*)ptr, "xsd:boolean");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns1__vodSearch:
		soap_serialize___ns1__vodSearch(soap, (const struct __ns1__vodSearch *)ptr);
		break;
	case SOAP_TYPE___ns1__getVODUrl:
		soap_serialize___ns1__getVODUrl(soap, (const struct __ns1__getVODUrl *)ptr);
		break;
	case SOAP_TYPE___ns1__getPlayUrl:
		soap_serialize___ns1__getPlayUrl(soap, (const struct __ns1__getPlayUrl *)ptr);
		break;
	case SOAP_TYPE___ns1__setPrivacyMaskParam:
		soap_serialize___ns1__setPrivacyMaskParam(soap, (const struct __ns1__setPrivacyMaskParam *)ptr);
		break;
	case SOAP_TYPE___ns1__getPrivacyMaskParam:
		soap_serialize___ns1__getPrivacyMaskParam(soap, (const struct __ns1__getPrivacyMaskParam *)ptr);
		break;
	case SOAP_TYPE___ns1__setVMDParam:
		soap_serialize___ns1__setVMDParam(soap, (const struct __ns1__setVMDParam *)ptr);
		break;
	case SOAP_TYPE___ns1__getVMDParam:
		soap_serialize___ns1__getVMDParam(soap, (const struct __ns1__getVMDParam *)ptr);
		break;
	case SOAP_TYPE___ns1__setTime:
		soap_serialize___ns1__setTime(soap, (const struct __ns1__setTime *)ptr);
		break;
	case SOAP_TYPE___ns1__getTime:
		soap_serialize___ns1__getTime(soap, (const struct __ns1__getTime *)ptr);
		break;
	case SOAP_TYPE___ns1__setOSDParam:
		soap_serialize___ns1__setOSDParam(soap, (const struct __ns1__setOSDParam *)ptr);
		break;
	case SOAP_TYPE___ns1__getOSDParam:
		soap_serialize___ns1__getOSDParam(soap, (const struct __ns1__getOSDParam *)ptr);
		break;
	case SOAP_TYPE___ns1__setVideoParam:
		soap_serialize___ns1__setVideoParam(soap, (const struct __ns1__setVideoParam *)ptr);
		break;
	case SOAP_TYPE___ns1__getVideoParam:
		soap_serialize___ns1__getVideoParam(soap, (const struct __ns1__getVideoParam *)ptr);
		break;
	case SOAP_TYPE___ns1__queryDevLog:
		soap_serialize___ns1__queryDevLog(soap, (const struct __ns1__queryDevLog *)ptr);
		break;
	case SOAP_TYPE___ns1__queryLog:
		soap_serialize___ns1__queryLog(soap, (const struct __ns1__queryLog *)ptr);
		break;
	case SOAP_TYPE___ns1__upgradeDevVer:
		soap_serialize___ns1__upgradeDevVer(soap, (const struct __ns1__upgradeDevVer *)ptr);
		break;
	case SOAP_TYPE___ns1__getDevVer:
		soap_serialize___ns1__getDevVer(soap, (const struct __ns1__getDevVer *)ptr);
		break;
	case SOAP_TYPE___ns1__reboot:
		soap_serialize___ns1__reboot(soap, (const struct __ns1__reboot *)ptr);
		break;
	case SOAP_TYPE___ns1__setCodingParam:
		soap_serialize___ns1__setCodingParam(soap, (const struct __ns1__setCodingParam *)ptr);
		break;
	case SOAP_TYPE___ns1__getCodingParam:
		soap_serialize___ns1__getCodingParam(soap, (const struct __ns1__getCodingParam *)ptr);
		break;
	case SOAP_TYPE___ns1__presetControl:
		soap_serialize___ns1__presetControl(soap, (const struct __ns1__presetControl *)ptr);
		break;
	case SOAP_TYPE___ns1__lensControl:
		soap_serialize___ns1__lensControl(soap, (const struct __ns1__lensControl *)ptr);
		break;
	case SOAP_TYPE___ns1__ptzControl:
		soap_serialize___ns1__ptzControl(soap, (const struct __ns1__ptzControl *)ptr);
		break;
	case SOAP_TYPE___ns1__nullifyDevice:
		soap_serialize___ns1__nullifyDevice(soap, (const struct __ns1__nullifyDevice *)ptr);
		break;
	case SOAP_TYPE___ns1__addDevice:
		soap_serialize___ns1__addDevice(soap, (const struct __ns1__addDevice *)ptr);
		break;
	case SOAP_TYPE___ns1__updateChannelName:
		soap_serialize___ns1__updateChannelName(soap, (const struct __ns1__updateChannelName *)ptr);
		break;
	case SOAP_TYPE___ns1__userLogout:
		soap_serialize___ns1__userLogout(soap, (const struct __ns1__userLogout *)ptr);
		break;
	case SOAP_TYPE___ns1__userLogin:
		soap_serialize___ns1__userLogin(soap, (const struct __ns1__userLogin *)ptr);
		break;
	case SOAP_TYPE___ns1__queryDeviceBonded:
		soap_serialize___ns1__queryDeviceBonded(soap, (const struct __ns1__queryDeviceBonded *)ptr);
		break;
	case SOAP_TYPE___ns1__queryClientVersion:
		soap_serialize___ns1__queryClientVersion(soap, (const struct __ns1__queryClientVersion *)ptr);
		break;
	case SOAP_TYPE___ns1__queryAndroidToken:
		soap_serialize___ns1__queryAndroidToken(soap, (const struct __ns1__queryAndroidToken *)ptr);
		break;
	case SOAP_TYPE___ns1__queryAppleToken:
		soap_serialize___ns1__queryAppleToken(soap, (const struct __ns1__queryAppleToken *)ptr);
		break;
	case SOAP_TYPE___ns1__queryDeviceSharingSource:
		soap_serialize___ns1__queryDeviceSharingSource(soap, (const struct __ns1__queryDeviceSharingSource *)ptr);
		break;
	case SOAP_TYPE___ns1__queryDeviceSharer:
		soap_serialize___ns1__queryDeviceSharer(soap, (const struct __ns1__queryDeviceSharer *)ptr);
		break;
	case SOAP_TYPE___ns1__nullifyDeviceSharer:
		soap_serialize___ns1__nullifyDeviceSharer(soap, (const struct __ns1__nullifyDeviceSharer *)ptr);
		break;
	case SOAP_TYPE___ns1__addDeviceSharer:
		soap_serialize___ns1__addDeviceSharer(soap, (const struct __ns1__addDeviceSharer *)ptr);
		break;
	case SOAP_TYPE___ns1__queryDeviceStatus:
		soap_serialize___ns1__queryDeviceStatus(soap, (const struct __ns1__queryDeviceStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__updateAndroidToken:
		soap_serialize___ns1__updateAndroidToken(soap, (const struct __ns1__updateAndroidToken *)ptr);
		break;
	case SOAP_TYPE___ns1__queryPUEventLog:
		soap_serialize___ns1__queryPUEventLog(soap, (const struct __ns1__queryPUEventLog *)ptr);
		break;
	case SOAP_TYPE___ns1__queryPUOnOffLog:
		soap_serialize___ns1__queryPUOnOffLog(soap, (const struct __ns1__queryPUOnOffLog *)ptr);
		break;
	case SOAP_TYPE___ns1__inviteKeepAlive:
		soap_serialize___ns1__inviteKeepAlive(soap, (const struct __ns1__inviteKeepAlive *)ptr);
		break;
	case SOAP_TYPE___ns1__notifyNATResult:
		soap_serialize___ns1__notifyNATResult(soap, (const struct __ns1__notifyNATResult *)ptr);
		break;
	case SOAP_TYPE___ns1__subscribeEMail:
		soap_serialize___ns1__subscribeEMail(soap, (const struct __ns1__subscribeEMail *)ptr);
		break;
	case SOAP_TYPE___ns1__subscribeSMS:
		soap_serialize___ns1__subscribeSMS(soap, (const struct __ns1__subscribeSMS *)ptr);
		break;
	case SOAP_TYPE___ns1__getNATServer:
		soap_serialize___ns1__getNATServer(soap, (const struct __ns1__getNATServer *)ptr);
		break;
	case SOAP_TYPE___ns1__bye:
		soap_serialize___ns1__bye(soap, (const struct __ns1__bye *)ptr);
		break;
	case SOAP_TYPE___ns1__invite:
		soap_serialize___ns1__invite(soap, (const struct __ns1__invite *)ptr);
		break;
	case SOAP_TYPE___ns1__setAuxiliary:
		soap_serialize___ns1__setAuxiliary(soap, (const struct __ns1__setAuxiliary *)ptr);
		break;
	case SOAP_TYPE___ns1__getAuxiliary:
		soap_serialize___ns1__getAuxiliary(soap, (const struct __ns1__getAuxiliary *)ptr);
		break;
	case SOAP_TYPE___ns1__getBackPassword:
		soap_serialize___ns1__getBackPassword(soap, (const struct __ns1__getBackPassword *)ptr);
		break;
	case SOAP_TYPE___ns1__getAccount:
		soap_serialize___ns1__getAccount(soap, (const struct __ns1__getAccount *)ptr);
		break;
	case SOAP_TYPE___ns1__updateAppleToken:
		soap_serialize___ns1__updateAppleToken(soap, (const struct __ns1__updateAppleToken *)ptr);
		break;
	case SOAP_TYPE___ns1__queryDevice:
		soap_serialize___ns1__queryDevice(soap, (const struct __ns1__queryDevice *)ptr);
		break;
	case SOAP_TYPE___ns1__updatePassword:
		soap_serialize___ns1__updatePassword(soap, (const struct __ns1__updatePassword *)ptr);
		break;
	case SOAP_TYPE___ns1__updateAccount:
		soap_serialize___ns1__updateAccount(soap, (const struct __ns1__updateAccount *)ptr);
		break;
	case SOAP_TYPE___ns1__createAccount:
		soap_serialize___ns1__createAccount(soap, (const struct __ns1__createAccount *)ptr);
		break;
	case SOAP_TYPE___ns1__getPicture:
		soap_serialize___ns1__getPicture(soap, (const struct __ns1__getPicture *)ptr);
		break;
	case SOAP_TYPE___ns1__flaggedNoticeStatus:
		soap_serialize___ns1__flaggedNoticeStatus(soap, (const struct __ns1__flaggedNoticeStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__queryNotices:
		soap_serialize___ns1__queryNotices(soap, (const struct __ns1__queryNotices *)ptr);
		break;
	case SOAP_TYPE___ns1__trustedAuthorityLogin:
		soap_serialize___ns1__trustedAuthorityLogin(soap, (const struct __ns1__trustedAuthorityLogin *)ptr);
		break;
	case SOAP_TYPE___ns1__getDeviceMatchingResult:
		soap_serialize___ns1__getDeviceMatchingResult(soap, (const struct __ns1__getDeviceMatchingResult *)ptr);
		break;
	case SOAP_TYPE___ns1__getDeviceMatchingCode:
		soap_serialize___ns1__getDeviceMatchingCode(soap, (const struct __ns1__getDeviceMatchingCode *)ptr);
		break;
	case SOAP_TYPE___ns1__getDynamicPassword:
		soap_serialize___ns1__getDynamicPassword(soap, (const struct __ns1__getDynamicPassword *)ptr);
		break;
	case SOAP_TYPE___ns1__getWirelessNetwork:
		soap_serialize___ns1__getWirelessNetwork(soap, (const struct __ns1__getWirelessNetwork *)ptr);
		break;
	case SOAP_TYPE___ns1__setRelay:
		soap_serialize___ns1__setRelay(soap, (const struct __ns1__setRelay *)ptr);
		break;
	case SOAP_TYPE___ns1__getRelay:
		soap_serialize___ns1__getRelay(soap, (const struct __ns1__getRelay *)ptr);
		break;
	case SOAP_TYPE___ns1__setRecordParam:
		soap_serialize___ns1__setRecordParam(soap, (const struct __ns1__setRecordParam *)ptr);
		break;
	case SOAP_TYPE___ns1__getRecordParam:
		soap_serialize___ns1__getRecordParam(soap, (const struct __ns1__getRecordParam *)ptr);
		break;
	case SOAP_TYPE___ns1__setPushWorkSheet:
		soap_serialize___ns1__setPushWorkSheet(soap, (const struct __ns1__setPushWorkSheet *)ptr);
		break;
	case SOAP_TYPE___ns1__getPushWorkSheet:
		soap_serialize___ns1__getPushWorkSheet(soap, (const struct __ns1__getPushWorkSheet *)ptr);
		break;
	case SOAP_TYPE___ns1__subscribeAndroidPush:
		soap_serialize___ns1__subscribeAndroidPush(soap, (const struct __ns1__subscribeAndroidPush *)ptr);
		break;
	case SOAP_TYPE___ns1__subscribeApplePush:
		soap_serialize___ns1__subscribeApplePush(soap, (const struct __ns1__subscribeApplePush *)ptr);
		break;
	case SOAP_TYPE__ns1__vodSearchRes:
		soap_serialize__ns1__vodSearchRes(soap, (const struct _ns1__vodSearchRes *)ptr);
		break;
	case SOAP_TYPE__ns1__vodSearchReq:
		soap_serialize__ns1__vodSearchReq(soap, (const struct _ns1__vodSearchReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getVODUrlRes:
		soap_serialize__ns1__getVODUrlRes(soap, (const struct _ns1__getVODUrlRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getVODUrlReq:
		soap_serialize__ns1__getVODUrlReq(soap, (const struct _ns1__getVODUrlReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getPlayUrlRes:
		soap_serialize__ns1__getPlayUrlRes(soap, (const struct _ns1__getPlayUrlRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getPlayUrlReq:
		soap_serialize__ns1__getPlayUrlReq(soap, (const struct _ns1__getPlayUrlReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setPrivacyMaskParamRes:
		soap_serialize__ns1__setPrivacyMaskParamRes(soap, (const struct _ns1__setPrivacyMaskParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setPrivacyMaskParamReq:
		soap_serialize__ns1__setPrivacyMaskParamReq(soap, (const struct _ns1__setPrivacyMaskParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getPrivacyMaskParamRes:
		soap_serialize__ns1__getPrivacyMaskParamRes(soap, (const struct _ns1__getPrivacyMaskParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getPrivacyMaskParamReq:
		soap_serialize__ns1__getPrivacyMaskParamReq(soap, (const struct _ns1__getPrivacyMaskParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setVMDParamRes:
		soap_serialize__ns1__setVMDParamRes(soap, (const struct _ns1__setVMDParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setVMDParamReq:
		soap_serialize__ns1__setVMDParamReq(soap, (const struct _ns1__setVMDParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getVMDParamRes:
		soap_serialize__ns1__getVMDParamRes(soap, (const struct _ns1__getVMDParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getVMDParamReq:
		soap_serialize__ns1__getVMDParamReq(soap, (const struct _ns1__getVMDParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setTimeRes:
		soap_serialize__ns1__setTimeRes(soap, (const struct _ns1__setTimeRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setTimeReq:
		soap_serialize__ns1__setTimeReq(soap, (const struct _ns1__setTimeReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getTimeRes:
		soap_serialize__ns1__getTimeRes(soap, (const struct _ns1__getTimeRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getTimeReq:
		soap_serialize__ns1__getTimeReq(soap, (const struct _ns1__getTimeReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setOSDParamRes:
		soap_serialize__ns1__setOSDParamRes(soap, (const struct _ns1__setOSDParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setOSDParamReq:
		soap_serialize__ns1__setOSDParamReq(soap, (const struct _ns1__setOSDParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getOSDParamRes:
		soap_serialize__ns1__getOSDParamRes(soap, (const struct _ns1__getOSDParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getOSDParamReq:
		soap_serialize__ns1__getOSDParamReq(soap, (const struct _ns1__getOSDParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setVideoParamRes:
		soap_serialize__ns1__setVideoParamRes(soap, (const struct _ns1__setVideoParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setVideoParamReq:
		soap_serialize__ns1__setVideoParamReq(soap, (const struct _ns1__setVideoParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getVideoParamRes:
		soap_serialize__ns1__getVideoParamRes(soap, (const struct _ns1__getVideoParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getVideoParamReq:
		soap_serialize__ns1__getVideoParamReq(soap, (const struct _ns1__getVideoParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDevLogRes:
		soap_serialize__ns1__queryDevLogRes(soap, (const struct _ns1__queryDevLogRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDevLogReq:
		soap_serialize__ns1__queryDevLogReq(soap, (const struct _ns1__queryDevLogReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryLogRes:
		soap_serialize__ns1__queryLogRes(soap, (const struct _ns1__queryLogRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryLogReq:
		soap_serialize__ns1__queryLogReq(soap, (const struct _ns1__queryLogReq *)ptr);
		break;
	case SOAP_TYPE__ns1__upgradeDevVerRes:
		soap_serialize__ns1__upgradeDevVerRes(soap, (const struct _ns1__upgradeDevVerRes *)ptr);
		break;
	case SOAP_TYPE__ns1__upgradeDevVerReq:
		soap_serialize__ns1__upgradeDevVerReq(soap, (const struct _ns1__upgradeDevVerReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getDevVerRes:
		soap_serialize__ns1__getDevVerRes(soap, (const struct _ns1__getDevVerRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getDevVerReq:
		soap_serialize__ns1__getDevVerReq(soap, (const struct _ns1__getDevVerReq *)ptr);
		break;
	case SOAP_TYPE__ns1__rebootRes:
		soap_serialize__ns1__rebootRes(soap, (const struct _ns1__rebootRes *)ptr);
		break;
	case SOAP_TYPE__ns1__rebootReq:
		soap_serialize__ns1__rebootReq(soap, (const struct _ns1__rebootReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setCodingParamRes:
		soap_serialize__ns1__setCodingParamRes(soap, (const struct _ns1__setCodingParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setCodingParamReq:
		soap_serialize__ns1__setCodingParamReq(soap, (const struct _ns1__setCodingParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getCodingParamRes:
		soap_serialize__ns1__getCodingParamRes(soap, (const struct _ns1__getCodingParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getCodingParamReq:
		soap_serialize__ns1__getCodingParamReq(soap, (const struct _ns1__getCodingParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__presetControlRes:
		soap_serialize__ns1__presetControlRes(soap, (const struct _ns1__presetControlRes *)ptr);
		break;
	case SOAP_TYPE__ns1__presetControlReq:
		soap_serialize__ns1__presetControlReq(soap, (const struct _ns1__presetControlReq *)ptr);
		break;
	case SOAP_TYPE__ns1__lensControlRes:
		soap_serialize__ns1__lensControlRes(soap, (const struct _ns1__lensControlRes *)ptr);
		break;
	case SOAP_TYPE__ns1__lensControlReq:
		soap_serialize__ns1__lensControlReq(soap, (const struct _ns1__lensControlReq *)ptr);
		break;
	case SOAP_TYPE__ns1__ptzControlRes:
		soap_serialize__ns1__ptzControlRes(soap, (const struct _ns1__ptzControlRes *)ptr);
		break;
	case SOAP_TYPE__ns1__ptzControlReq:
		soap_serialize__ns1__ptzControlReq(soap, (const struct _ns1__ptzControlReq *)ptr);
		break;
	case SOAP_TYPE__ns1__nullifyDeviceRes:
		soap_serialize__ns1__nullifyDeviceRes(soap, (const struct _ns1__nullifyDeviceRes *)ptr);
		break;
	case SOAP_TYPE__ns1__nullifyDeviceReq:
		soap_serialize__ns1__nullifyDeviceReq(soap, (const struct _ns1__nullifyDeviceReq *)ptr);
		break;
	case SOAP_TYPE__ns1__addDeviceRes:
		soap_serialize__ns1__addDeviceRes(soap, (const struct _ns1__addDeviceRes *)ptr);
		break;
	case SOAP_TYPE__ns1__addDeviceReq:
		soap_serialize__ns1__addDeviceReq(soap, (const struct _ns1__addDeviceReq *)ptr);
		break;
	case SOAP_TYPE__ns1__updateChannelNameRes:
		soap_serialize__ns1__updateChannelNameRes(soap, (const struct _ns1__updateChannelNameRes *)ptr);
		break;
	case SOAP_TYPE__ns1__updateChannelNameReq:
		soap_serialize__ns1__updateChannelNameReq(soap, (const struct _ns1__updateChannelNameReq *)ptr);
		break;
	case SOAP_TYPE__ns1__userLogoutRes:
		soap_serialize__ns1__userLogoutRes(soap, (const struct _ns1__userLogoutRes *)ptr);
		break;
	case SOAP_TYPE__ns1__userLogoutReq:
		soap_serialize__ns1__userLogoutReq(soap, (const struct _ns1__userLogoutReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDeviceBondedRes:
		soap_serialize__ns1__queryDeviceBondedRes(soap, (const struct _ns1__queryDeviceBondedRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDeviceBondedReq:
		soap_serialize__ns1__queryDeviceBondedReq(soap, (const struct _ns1__queryDeviceBondedReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryClientVersionRes:
		soap_serialize__ns1__queryClientVersionRes(soap, (const struct _ns1__queryClientVersionRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryClientVersionReq:
		soap_serialize__ns1__queryClientVersionReq(soap, (const struct _ns1__queryClientVersionReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryAndroidTokenRes:
		soap_serialize__ns1__queryAndroidTokenRes(soap, (const struct _ns1__queryAndroidTokenRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryAndroidTokenReq:
		soap_serialize__ns1__queryAndroidTokenReq(soap, (const struct _ns1__queryAndroidTokenReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryAppleTokenRes:
		soap_serialize__ns1__queryAppleTokenRes(soap, (const struct _ns1__queryAppleTokenRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryAppleTokenReq:
		soap_serialize__ns1__queryAppleTokenReq(soap, (const struct _ns1__queryAppleTokenReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDeviceSharingSourceRes:
		soap_serialize__ns1__queryDeviceSharingSourceRes(soap, (const struct _ns1__queryDeviceSharingSourceRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDeviceSharingSourceReq:
		soap_serialize__ns1__queryDeviceSharingSourceReq(soap, (const struct _ns1__queryDeviceSharingSourceReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDeviceSharerRes:
		soap_serialize__ns1__queryDeviceSharerRes(soap, (const struct _ns1__queryDeviceSharerRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDeviceSharerReq:
		soap_serialize__ns1__queryDeviceSharerReq(soap, (const struct _ns1__queryDeviceSharerReq *)ptr);
		break;
	case SOAP_TYPE__ns1__nullifyDeviceSharerRes:
		soap_serialize__ns1__nullifyDeviceSharerRes(soap, (const struct _ns1__nullifyDeviceSharerRes *)ptr);
		break;
	case SOAP_TYPE__ns1__nullifyDeviceSharerReq:
		soap_serialize__ns1__nullifyDeviceSharerReq(soap, (const struct _ns1__nullifyDeviceSharerReq *)ptr);
		break;
	case SOAP_TYPE__ns1__addDeviceSharerRes:
		soap_serialize__ns1__addDeviceSharerRes(soap, (const struct _ns1__addDeviceSharerRes *)ptr);
		break;
	case SOAP_TYPE__ns1__addDeviceSharerReq:
		soap_serialize__ns1__addDeviceSharerReq(soap, (const struct _ns1__addDeviceSharerReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDeviceStatusRes:
		soap_serialize__ns1__queryDeviceStatusRes(soap, (const struct _ns1__queryDeviceStatusRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDeviceStatusReq:
		soap_serialize__ns1__queryDeviceStatusReq(soap, (const struct _ns1__queryDeviceStatusReq *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAndroidTokenRes:
		soap_serialize__ns1__updateAndroidTokenRes(soap, (const struct _ns1__updateAndroidTokenRes *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAndroidTokenReq:
		soap_serialize__ns1__updateAndroidTokenReq(soap, (const struct _ns1__updateAndroidTokenReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryPUEventLogRes:
		soap_serialize__ns1__queryPUEventLogRes(soap, (const struct _ns1__queryPUEventLogRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryPUEventLogReq:
		soap_serialize__ns1__queryPUEventLogReq(soap, (const struct _ns1__queryPUEventLogReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryPUOnOffLogRes:
		soap_serialize__ns1__queryPUOnOffLogRes(soap, (const struct _ns1__queryPUOnOffLogRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryPUOnOffLogReq:
		soap_serialize__ns1__queryPUOnOffLogReq(soap, (const struct _ns1__queryPUOnOffLogReq *)ptr);
		break;
	case SOAP_TYPE__ns1__inviteKeepAliveRes:
		soap_serialize__ns1__inviteKeepAliveRes(soap, (const struct _ns1__inviteKeepAliveRes *)ptr);
		break;
	case SOAP_TYPE__ns1__inviteKeepAliveReq:
		soap_serialize__ns1__inviteKeepAliveReq(soap, (const struct _ns1__inviteKeepAliveReq *)ptr);
		break;
	case SOAP_TYPE__ns1__notifyNATResultRes:
		soap_serialize__ns1__notifyNATResultRes(soap, (const struct _ns1__notifyNATResultRes *)ptr);
		break;
	case SOAP_TYPE__ns1__notifyNATResultReq:
		soap_serialize__ns1__notifyNATResultReq(soap, (const struct _ns1__notifyNATResultReq *)ptr);
		break;
	case SOAP_TYPE__ns1__subscribeEMailRes:
		soap_serialize__ns1__subscribeEMailRes(soap, (const struct _ns1__subscribeEMailRes *)ptr);
		break;
	case SOAP_TYPE__ns1__subscribeEMailReq:
		soap_serialize__ns1__subscribeEMailReq(soap, (const struct _ns1__subscribeEMailReq *)ptr);
		break;
	case SOAP_TYPE__ns1__subscribeSMSRes:
		soap_serialize__ns1__subscribeSMSRes(soap, (const struct _ns1__subscribeSMSRes *)ptr);
		break;
	case SOAP_TYPE__ns1__subscribeSMSReq:
		soap_serialize__ns1__subscribeSMSReq(soap, (const struct _ns1__subscribeSMSReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getNATServerRes:
		soap_serialize__ns1__getNATServerRes(soap, (const struct _ns1__getNATServerRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getNATServerReq:
		soap_serialize__ns1__getNATServerReq(soap, (const struct _ns1__getNATServerReq *)ptr);
		break;
	case SOAP_TYPE__ns1__byeRes:
		soap_serialize__ns1__byeRes(soap, (const struct _ns1__byeRes *)ptr);
		break;
	case SOAP_TYPE__ns1__byeReq:
		soap_serialize__ns1__byeReq(soap, (const struct _ns1__byeReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setAuxiliaryRes:
		soap_serialize__ns1__setAuxiliaryRes(soap, (const struct _ns1__setAuxiliaryRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setAuxiliaryReq:
		soap_serialize__ns1__setAuxiliaryReq(soap, (const struct _ns1__setAuxiliaryReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getAuxiliaryRes:
		soap_serialize__ns1__getAuxiliaryRes(soap, (const struct _ns1__getAuxiliaryRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getAuxiliaryReq:
		soap_serialize__ns1__getAuxiliaryReq(soap, (const struct _ns1__getAuxiliaryReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getBackPasswordRes:
		soap_serialize__ns1__getBackPasswordRes(soap, (const struct _ns1__getBackPasswordRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getBackPasswordReq:
		soap_serialize__ns1__getBackPasswordReq(soap, (const struct _ns1__getBackPasswordReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getAccountRes:
		soap_serialize__ns1__getAccountRes(soap, (const struct _ns1__getAccountRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getAccountReq:
		soap_serialize__ns1__getAccountReq(soap, (const struct _ns1__getAccountReq *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAppleTokenRes:
		soap_serialize__ns1__updateAppleTokenRes(soap, (const struct _ns1__updateAppleTokenRes *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAppleTokenReq:
		soap_serialize__ns1__updateAppleTokenReq(soap, (const struct _ns1__updateAppleTokenReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDeviceRes:
		soap_serialize__ns1__queryDeviceRes(soap, (const struct _ns1__queryDeviceRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDeviceReq:
		soap_serialize__ns1__queryDeviceReq(soap, (const struct _ns1__queryDeviceReq *)ptr);
		break;
	case SOAP_TYPE__ns1__updatePasswordRes:
		soap_serialize__ns1__updatePasswordRes(soap, (const struct _ns1__updatePasswordRes *)ptr);
		break;
	case SOAP_TYPE__ns1__updatePasswordReq:
		soap_serialize__ns1__updatePasswordReq(soap, (const struct _ns1__updatePasswordReq *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAccountRes:
		soap_serialize__ns1__updateAccountRes(soap, (const struct _ns1__updateAccountRes *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAccountReq:
		soap_serialize__ns1__updateAccountReq(soap, (const struct _ns1__updateAccountReq *)ptr);
		break;
	case SOAP_TYPE__ns1__createAccountRes:
		soap_serialize__ns1__createAccountRes(soap, (const struct _ns1__createAccountRes *)ptr);
		break;
	case SOAP_TYPE__ns1__createAccountReq:
		soap_serialize__ns1__createAccountReq(soap, (const struct _ns1__createAccountReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getPictureRes:
		soap_serialize__ns1__getPictureRes(soap, (const struct _ns1__getPictureRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getPictureReq:
		soap_serialize__ns1__getPictureReq(soap, (const struct _ns1__getPictureReq *)ptr);
		break;
	case SOAP_TYPE__ns1__flaggedNoticeStatusRes:
		soap_serialize__ns1__flaggedNoticeStatusRes(soap, (const struct _ns1__flaggedNoticeStatusRes *)ptr);
		break;
	case SOAP_TYPE__ns1__flaggedNoticeStatusReq:
		soap_serialize__ns1__flaggedNoticeStatusReq(soap, (const struct _ns1__flaggedNoticeStatusReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryNoticesRes:
		soap_serialize__ns1__queryNoticesRes(soap, (const struct _ns1__queryNoticesRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryNoticesReq:
		soap_serialize__ns1__queryNoticesReq(soap, (const struct _ns1__queryNoticesReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getDeviceMatchingResultRes:
		soap_serialize__ns1__getDeviceMatchingResultRes(soap, (const struct _ns1__getDeviceMatchingResultRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getDeviceMatchingResultReq:
		soap_serialize__ns1__getDeviceMatchingResultReq(soap, (const struct _ns1__getDeviceMatchingResultReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getDeviceMatchingCodeRes:
		soap_serialize__ns1__getDeviceMatchingCodeRes(soap, (const struct _ns1__getDeviceMatchingCodeRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getDeviceMatchingCodeReq:
		soap_serialize__ns1__getDeviceMatchingCodeReq(soap, (const struct _ns1__getDeviceMatchingCodeReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getDynamicPasswordRes:
		soap_serialize__ns1__getDynamicPasswordRes(soap, (const struct _ns1__getDynamicPasswordRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getDynamicPasswordReq:
		soap_serialize__ns1__getDynamicPasswordReq(soap, (const struct _ns1__getDynamicPasswordReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getWirelessNetworkRes:
		soap_serialize__ns1__getWirelessNetworkRes(soap, (const struct _ns1__getWirelessNetworkRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getWirelessNetworkReq:
		soap_serialize__ns1__getWirelessNetworkReq(soap, (const struct _ns1__getWirelessNetworkReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setRelayRes:
		soap_serialize__ns1__setRelayRes(soap, (const struct _ns1__setRelayRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setRelayReq:
		soap_serialize__ns1__setRelayReq(soap, (const struct _ns1__setRelayReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getRelayRes:
		soap_serialize__ns1__getRelayRes(soap, (const struct _ns1__getRelayRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getRelayReq:
		soap_serialize__ns1__getRelayReq(soap, (const struct _ns1__getRelayReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setRecordParamRes:
		soap_serialize__ns1__setRecordParamRes(soap, (const struct _ns1__setRecordParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setRecordParamReq:
		soap_serialize__ns1__setRecordParamReq(soap, (const struct _ns1__setRecordParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getRecordParamRes:
		soap_serialize__ns1__getRecordParamRes(soap, (const struct _ns1__getRecordParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getRecordParamReq:
		soap_serialize__ns1__getRecordParamReq(soap, (const struct _ns1__getRecordParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setPushWorkSheetRes:
		soap_serialize__ns1__setPushWorkSheetRes(soap, (const struct _ns1__setPushWorkSheetRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setPushWorkSheetReq:
		soap_serialize__ns1__setPushWorkSheetReq(soap, (const struct _ns1__setPushWorkSheetReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getPushWorkSheetRes:
		soap_serialize__ns1__getPushWorkSheetRes(soap, (const struct _ns1__getPushWorkSheetRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getPushWorkSheetReq:
		soap_serialize__ns1__getPushWorkSheetReq(soap, (const struct _ns1__getPushWorkSheetReq *)ptr);
		break;
	case SOAP_TYPE__ns1__subscribeAndroidPushRes:
		soap_serialize__ns1__subscribeAndroidPushRes(soap, (const struct _ns1__subscribeAndroidPushRes *)ptr);
		break;
	case SOAP_TYPE__ns1__subscribeAndroidPushReq:
		soap_serialize__ns1__subscribeAndroidPushReq(soap, (const struct _ns1__subscribeAndroidPushReq *)ptr);
		break;
	case SOAP_TYPE__ns1__subscribeApplePushRes:
		soap_serialize__ns1__subscribeApplePushRes(soap, (const struct _ns1__subscribeApplePushRes *)ptr);
		break;
	case SOAP_TYPE__ns1__subscribeApplePushReq:
		soap_serialize__ns1__subscribeApplePushReq(soap, (const struct _ns1__subscribeApplePushReq *)ptr);
		break;
	case SOAP_TYPE_ns1__VODRecord:
		soap_serialize_ns1__VODRecord(soap, (const struct ns1__VODRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__PrivacyMaskRegion:
		soap_serialize_ns1__PrivacyMaskRegion(soap, (const struct ns1__PrivacyMaskRegion *)ptr);
		break;
	case SOAP_TYPE_ns1__VMDGrid:
		soap_serialize_ns1__VMDGrid(soap, (const struct ns1__VMDGrid *)ptr);
		break;
	case SOAP_TYPE_ns1__DevLog:
		soap_serialize_ns1__DevLog(soap, (const struct ns1__DevLog *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfDevLog:
		soap_serialize_ns1__ArrayOfDevLog(soap, (const struct ns1__ArrayOfDevLog *)ptr);
		break;
	case SOAP_TYPE_ns1__PuLog:
		soap_serialize_ns1__PuLog(soap, (const struct ns1__PuLog *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfPuLog:
		soap_serialize_ns1__ArrayOfPuLog(soap, (const struct ns1__ArrayOfPuLog *)ptr);
		break;
	case SOAP_TYPE_ns1__Device:
		soap_serialize_ns1__Device(soap, (const struct ns1__Device *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfDevice:
		soap_serialize_ns1__ArrayOfDevice(soap, (const struct ns1__ArrayOfDevice *)ptr);
		break;
	case SOAP_TYPE_ns1__userLoginRes:
		soap_serialize_ns1__userLoginRes(soap, (const struct ns1__userLoginRes *)ptr);
		break;
	case SOAP_TYPE_ns1__userLoginReq:
		soap_serialize_ns1__userLoginReq(soap, (const struct ns1__userLoginReq *)ptr);
		break;
	case SOAP_TYPE_ns1__DeviceSharer:
		soap_serialize_ns1__DeviceSharer(soap, (const struct ns1__DeviceSharer *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfDeviceSharer:
		soap_serialize_ns1__ArrayOfDeviceSharer(soap, (const struct ns1__ArrayOfDeviceSharer *)ptr);
		break;
	case SOAP_TYPE_ns1__PUEventLog:
		soap_serialize_ns1__PUEventLog(soap, (const struct ns1__PUEventLog *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfPUEventLog:
		soap_serialize_ns1__ArrayOfPUEventLog(soap, (const struct ns1__ArrayOfPUEventLog *)ptr);
		break;
	case SOAP_TYPE_ns1__PUOnOffLog:
		soap_serialize_ns1__PUOnOffLog(soap, (const struct ns1__PUOnOffLog *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfPUOnOffLog:
		soap_serialize_ns1__ArrayOfPUOnOffLog(soap, (const struct ns1__ArrayOfPUOnOffLog *)ptr);
		break;
	case SOAP_TYPE_ns1__TURNServer:
		soap_serialize_ns1__TURNServer(soap, (const struct ns1__TURNServer *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfTURNServer:
		soap_serialize_ns1__ArrayOfTURNServer(soap, (const struct ns1__ArrayOfTURNServer *)ptr);
		break;
	case SOAP_TYPE_ns1__STUNServer:
		soap_serialize_ns1__STUNServer(soap, (const struct ns1__STUNServer *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSTUNServer:
		soap_serialize_ns1__ArrayOfSTUNServer(soap, (const struct ns1__ArrayOfSTUNServer *)ptr);
		break;
	case SOAP_TYPE_ns1__inviteRes:
		soap_serialize_ns1__inviteRes(soap, (const struct ns1__inviteRes *)ptr);
		break;
	case SOAP_TYPE_ns1__inviteReq:
		soap_serialize_ns1__inviteReq(soap, (const struct ns1__inviteReq *)ptr);
		break;
	case SOAP_TYPE_ns1__WirelessNetwork:
		soap_serialize_ns1__WirelessNetwork(soap, (const struct ns1__WirelessNetwork *)ptr);
		break;
	case SOAP_TYPE_ns1__NodeDetails:
		soap_serialize_ns1__NodeDetails(soap, (const struct ns1__NodeDetails *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfNodeDetails:
		soap_serialize_ns1__ArrayOfNodeDetails(soap, (const struct ns1__ArrayOfNodeDetails *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		soap_serialize_ns1__ArrayOfString(soap, (const struct ns1__ArrayOfString *)ptr);
		break;
	case SOAP_TYPE_ns1__Notice:
		soap_serialize_ns1__Notice(soap, (const struct ns1__Notice *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfNotice:
		soap_serialize_ns1__ArrayOfNotice(soap, (const struct ns1__ArrayOfNotice *)ptr);
		break;
	case SOAP_TYPE_ns1__Dev:
		soap_serialize_ns1__Dev(soap, (const struct ns1__Dev *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfDev:
		soap_serialize_ns1__ArrayOfDev(soap, (const struct ns1__ArrayOfDev *)ptr);
		break;
	case SOAP_TYPE_ns1__trustedAuthorityLoginRes:
		soap_serialize_ns1__trustedAuthorityLoginRes(soap, (const struct ns1__trustedAuthorityLoginRes *)ptr);
		break;
	case SOAP_TYPE_ns1__MCUDev:
		soap_serialize_ns1__MCUDev(soap, (const struct ns1__MCUDev *)ptr);
		break;
	case SOAP_TYPE_ns1__trustedAuthorityLoginReq:
		soap_serialize_ns1__trustedAuthorityLoginReq(soap, (const struct ns1__trustedAuthorityLoginReq *)ptr);
		break;
	case SOAP_TYPE_ns1__Relay:
		soap_serialize_ns1__Relay(soap, (const struct ns1__Relay *)ptr);
		break;
	case SOAP_TYPE_ns1__WorkSheet:
		soap_serialize_ns1__WorkSheet(soap, (const struct ns1__WorkSheet *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__vodSearchRes:
		soap_serialize_PointerTo_ns1__vodSearchRes(soap, (struct _ns1__vodSearchRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__vodSearchReq:
		soap_serialize_PointerTo_ns1__vodSearchReq(soap, (struct _ns1__vodSearchReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVODUrlRes:
		soap_serialize_PointerTo_ns1__getVODUrlRes(soap, (struct _ns1__getVODUrlRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVODUrlReq:
		soap_serialize_PointerTo_ns1__getVODUrlReq(soap, (struct _ns1__getVODUrlReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlRes:
		soap_serialize_PointerTo_ns1__getPlayUrlRes(soap, (struct _ns1__getPlayUrlRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlReq:
		soap_serialize_PointerTo_ns1__getPlayUrlReq(soap, (struct _ns1__getPlayUrlReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamRes:
		soap_serialize_PointerTo_ns1__setPrivacyMaskParamRes(soap, (struct _ns1__setPrivacyMaskParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamReq:
		soap_serialize_PointerTo_ns1__setPrivacyMaskParamReq(soap, (struct _ns1__setPrivacyMaskParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamRes:
		soap_serialize_PointerTo_ns1__getPrivacyMaskParamRes(soap, (struct _ns1__getPrivacyMaskParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamReq:
		soap_serialize_PointerTo_ns1__getPrivacyMaskParamReq(soap, (struct _ns1__getPrivacyMaskParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setVMDParamRes:
		soap_serialize_PointerTo_ns1__setVMDParamRes(soap, (struct _ns1__setVMDParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setVMDParamReq:
		soap_serialize_PointerTo_ns1__setVMDParamReq(soap, (struct _ns1__setVMDParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVMDParamRes:
		soap_serialize_PointerTo_ns1__getVMDParamRes(soap, (struct _ns1__getVMDParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVMDParamReq:
		soap_serialize_PointerTo_ns1__getVMDParamReq(soap, (struct _ns1__getVMDParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setTimeRes:
		soap_serialize_PointerTo_ns1__setTimeRes(soap, (struct _ns1__setTimeRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setTimeReq:
		soap_serialize_PointerTo_ns1__setTimeReq(soap, (struct _ns1__setTimeReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTimeRes:
		soap_serialize_PointerTo_ns1__getTimeRes(soap, (struct _ns1__getTimeRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTimeReq:
		soap_serialize_PointerTo_ns1__getTimeReq(soap, (struct _ns1__getTimeReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setOSDParamRes:
		soap_serialize_PointerTo_ns1__setOSDParamRes(soap, (struct _ns1__setOSDParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setOSDParamReq:
		soap_serialize_PointerTo_ns1__setOSDParamReq(soap, (struct _ns1__setOSDParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getOSDParamRes:
		soap_serialize_PointerTo_ns1__getOSDParamRes(soap, (struct _ns1__getOSDParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getOSDParamReq:
		soap_serialize_PointerTo_ns1__getOSDParamReq(soap, (struct _ns1__getOSDParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setVideoParamRes:
		soap_serialize_PointerTo_ns1__setVideoParamRes(soap, (struct _ns1__setVideoParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setVideoParamReq:
		soap_serialize_PointerTo_ns1__setVideoParamReq(soap, (struct _ns1__setVideoParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVideoParamRes:
		soap_serialize_PointerTo_ns1__getVideoParamRes(soap, (struct _ns1__getVideoParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVideoParamReq:
		soap_serialize_PointerTo_ns1__getVideoParamReq(soap, (struct _ns1__getVideoParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDevLogRes:
		soap_serialize_PointerTo_ns1__queryDevLogRes(soap, (struct _ns1__queryDevLogRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDevLogReq:
		soap_serialize_PointerTo_ns1__queryDevLogReq(soap, (struct _ns1__queryDevLogReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryLogRes:
		soap_serialize_PointerTo_ns1__queryLogRes(soap, (struct _ns1__queryLogRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryLogReq:
		soap_serialize_PointerTo_ns1__queryLogReq(soap, (struct _ns1__queryLogReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerRes:
		soap_serialize_PointerTo_ns1__upgradeDevVerRes(soap, (struct _ns1__upgradeDevVerRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerReq:
		soap_serialize_PointerTo_ns1__upgradeDevVerReq(soap, (struct _ns1__upgradeDevVerReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDevVerRes:
		soap_serialize_PointerTo_ns1__getDevVerRes(soap, (struct _ns1__getDevVerRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDevVerReq:
		soap_serialize_PointerTo_ns1__getDevVerReq(soap, (struct _ns1__getDevVerReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__rebootRes:
		soap_serialize_PointerTo_ns1__rebootRes(soap, (struct _ns1__rebootRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__rebootReq:
		soap_serialize_PointerTo_ns1__rebootReq(soap, (struct _ns1__rebootReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setCodingParamRes:
		soap_serialize_PointerTo_ns1__setCodingParamRes(soap, (struct _ns1__setCodingParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setCodingParamReq:
		soap_serialize_PointerTo_ns1__setCodingParamReq(soap, (struct _ns1__setCodingParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getCodingParamRes:
		soap_serialize_PointerTo_ns1__getCodingParamRes(soap, (struct _ns1__getCodingParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getCodingParamReq:
		soap_serialize_PointerTo_ns1__getCodingParamReq(soap, (struct _ns1__getCodingParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__presetControlRes:
		soap_serialize_PointerTo_ns1__presetControlRes(soap, (struct _ns1__presetControlRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__presetControlReq:
		soap_serialize_PointerTo_ns1__presetControlReq(soap, (struct _ns1__presetControlReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__lensControlRes:
		soap_serialize_PointerTo_ns1__lensControlRes(soap, (struct _ns1__lensControlRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__lensControlReq:
		soap_serialize_PointerTo_ns1__lensControlReq(soap, (struct _ns1__lensControlReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ptzControlRes:
		soap_serialize_PointerTo_ns1__ptzControlRes(soap, (struct _ns1__ptzControlRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ptzControlReq:
		soap_serialize_PointerTo_ns1__ptzControlReq(soap, (struct _ns1__ptzControlReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceRes:
		soap_serialize_PointerTo_ns1__nullifyDeviceRes(soap, (struct _ns1__nullifyDeviceRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceReq:
		soap_serialize_PointerTo_ns1__nullifyDeviceReq(soap, (struct _ns1__nullifyDeviceReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addDeviceRes:
		soap_serialize_PointerTo_ns1__addDeviceRes(soap, (struct _ns1__addDeviceRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addDeviceReq:
		soap_serialize_PointerTo_ns1__addDeviceReq(soap, (struct _ns1__addDeviceReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameRes:
		soap_serialize_PointerTo_ns1__updateChannelNameRes(soap, (struct _ns1__updateChannelNameRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameReq:
		soap_serialize_PointerTo_ns1__updateChannelNameReq(soap, (struct _ns1__updateChannelNameReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__userLogoutRes:
		soap_serialize_PointerTo_ns1__userLogoutRes(soap, (struct _ns1__userLogoutRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__userLogoutReq:
		soap_serialize_PointerTo_ns1__userLogoutReq(soap, (struct _ns1__userLogoutReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__userLoginRes:
		soap_serialize_PointerTons1__userLoginRes(soap, (struct ns1__userLoginRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__userLoginReq:
		soap_serialize_PointerTons1__userLoginReq(soap, (struct ns1__userLoginReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDeviceBondedRes:
		soap_serialize_PointerTo_ns1__queryDeviceBondedRes(soap, (struct _ns1__queryDeviceBondedRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDeviceBondedReq:
		soap_serialize_PointerTo_ns1__queryDeviceBondedReq(soap, (struct _ns1__queryDeviceBondedReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryClientVersionRes:
		soap_serialize_PointerTo_ns1__queryClientVersionRes(soap, (struct _ns1__queryClientVersionRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryClientVersionReq:
		soap_serialize_PointerTo_ns1__queryClientVersionReq(soap, (struct _ns1__queryClientVersionReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryAndroidTokenRes:
		soap_serialize_PointerTo_ns1__queryAndroidTokenRes(soap, (struct _ns1__queryAndroidTokenRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryAndroidTokenReq:
		soap_serialize_PointerTo_ns1__queryAndroidTokenReq(soap, (struct _ns1__queryAndroidTokenReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryAppleTokenRes:
		soap_serialize_PointerTo_ns1__queryAppleTokenRes(soap, (struct _ns1__queryAppleTokenRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryAppleTokenReq:
		soap_serialize_PointerTo_ns1__queryAppleTokenReq(soap, (struct _ns1__queryAppleTokenReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDeviceSharingSourceRes:
		soap_serialize_PointerTo_ns1__queryDeviceSharingSourceRes(soap, (struct _ns1__queryDeviceSharingSourceRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDeviceSharingSourceReq:
		soap_serialize_PointerTo_ns1__queryDeviceSharingSourceReq(soap, (struct _ns1__queryDeviceSharingSourceReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDeviceSharerRes:
		soap_serialize_PointerTo_ns1__queryDeviceSharerRes(soap, (struct _ns1__queryDeviceSharerRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDeviceSharerReq:
		soap_serialize_PointerTo_ns1__queryDeviceSharerReq(soap, (struct _ns1__queryDeviceSharerReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceSharerRes:
		soap_serialize_PointerTo_ns1__nullifyDeviceSharerRes(soap, (struct _ns1__nullifyDeviceSharerRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceSharerReq:
		soap_serialize_PointerTo_ns1__nullifyDeviceSharerReq(soap, (struct _ns1__nullifyDeviceSharerReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addDeviceSharerRes:
		soap_serialize_PointerTo_ns1__addDeviceSharerRes(soap, (struct _ns1__addDeviceSharerRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addDeviceSharerReq:
		soap_serialize_PointerTo_ns1__addDeviceSharerReq(soap, (struct _ns1__addDeviceSharerReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDeviceStatusRes:
		soap_serialize_PointerTo_ns1__queryDeviceStatusRes(soap, (struct _ns1__queryDeviceStatusRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDeviceStatusReq:
		soap_serialize_PointerTo_ns1__queryDeviceStatusReq(soap, (struct _ns1__queryDeviceStatusReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAndroidTokenRes:
		soap_serialize_PointerTo_ns1__updateAndroidTokenRes(soap, (struct _ns1__updateAndroidTokenRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAndroidTokenReq:
		soap_serialize_PointerTo_ns1__updateAndroidTokenReq(soap, (struct _ns1__updateAndroidTokenReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryPUEventLogRes:
		soap_serialize_PointerTo_ns1__queryPUEventLogRes(soap, (struct _ns1__queryPUEventLogRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryPUEventLogReq:
		soap_serialize_PointerTo_ns1__queryPUEventLogReq(soap, (struct _ns1__queryPUEventLogReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryPUOnOffLogRes:
		soap_serialize_PointerTo_ns1__queryPUOnOffLogRes(soap, (struct _ns1__queryPUOnOffLogRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryPUOnOffLogReq:
		soap_serialize_PointerTo_ns1__queryPUOnOffLogReq(soap, (struct _ns1__queryPUOnOffLogReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__inviteKeepAliveRes:
		soap_serialize_PointerTo_ns1__inviteKeepAliveRes(soap, (struct _ns1__inviteKeepAliveRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__inviteKeepAliveReq:
		soap_serialize_PointerTo_ns1__inviteKeepAliveReq(soap, (struct _ns1__inviteKeepAliveReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__notifyNATResultRes:
		soap_serialize_PointerTo_ns1__notifyNATResultRes(soap, (struct _ns1__notifyNATResultRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__notifyNATResultReq:
		soap_serialize_PointerTo_ns1__notifyNATResultReq(soap, (struct _ns1__notifyNATResultReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__subscribeEMailRes:
		soap_serialize_PointerTo_ns1__subscribeEMailRes(soap, (struct _ns1__subscribeEMailRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__subscribeEMailReq:
		soap_serialize_PointerTo_ns1__subscribeEMailReq(soap, (struct _ns1__subscribeEMailReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__subscribeSMSRes:
		soap_serialize_PointerTo_ns1__subscribeSMSRes(soap, (struct _ns1__subscribeSMSRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__subscribeSMSReq:
		soap_serialize_PointerTo_ns1__subscribeSMSReq(soap, (struct _ns1__subscribeSMSReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getNATServerRes:
		soap_serialize_PointerTo_ns1__getNATServerRes(soap, (struct _ns1__getNATServerRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getNATServerReq:
		soap_serialize_PointerTo_ns1__getNATServerReq(soap, (struct _ns1__getNATServerReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__byeRes:
		soap_serialize_PointerTo_ns1__byeRes(soap, (struct _ns1__byeRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__byeReq:
		soap_serialize_PointerTo_ns1__byeReq(soap, (struct _ns1__byeReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__inviteRes:
		soap_serialize_PointerTons1__inviteRes(soap, (struct ns1__inviteRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__inviteReq:
		soap_serialize_PointerTons1__inviteReq(soap, (struct ns1__inviteReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryRes:
		soap_serialize_PointerTo_ns1__setAuxiliaryRes(soap, (struct _ns1__setAuxiliaryRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryReq:
		soap_serialize_PointerTo_ns1__setAuxiliaryReq(soap, (struct _ns1__setAuxiliaryReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryRes:
		soap_serialize_PointerTo_ns1__getAuxiliaryRes(soap, (struct _ns1__getAuxiliaryRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryReq:
		soap_serialize_PointerTo_ns1__getAuxiliaryReq(soap, (struct _ns1__getAuxiliaryReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordRes:
		soap_serialize_PointerTo_ns1__getBackPasswordRes(soap, (struct _ns1__getBackPasswordRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordReq:
		soap_serialize_PointerTo_ns1__getBackPasswordReq(soap, (struct _ns1__getBackPasswordReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAccountRes:
		soap_serialize_PointerTo_ns1__getAccountRes(soap, (struct _ns1__getAccountRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAccountReq:
		soap_serialize_PointerTo_ns1__getAccountReq(soap, (struct _ns1__getAccountReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenRes:
		soap_serialize_PointerTo_ns1__updateAppleTokenRes(soap, (struct _ns1__updateAppleTokenRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenReq:
		soap_serialize_PointerTo_ns1__updateAppleTokenReq(soap, (struct _ns1__updateAppleTokenReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDeviceRes:
		soap_serialize_PointerTo_ns1__queryDeviceRes(soap, (struct _ns1__queryDeviceRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDeviceReq:
		soap_serialize_PointerTo_ns1__queryDeviceReq(soap, (struct _ns1__queryDeviceReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updatePasswordRes:
		soap_serialize_PointerTo_ns1__updatePasswordRes(soap, (struct _ns1__updatePasswordRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updatePasswordReq:
		soap_serialize_PointerTo_ns1__updatePasswordReq(soap, (struct _ns1__updatePasswordReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAccountRes:
		soap_serialize_PointerTo_ns1__updateAccountRes(soap, (struct _ns1__updateAccountRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAccountReq:
		soap_serialize_PointerTo_ns1__updateAccountReq(soap, (struct _ns1__updateAccountReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__createAccountRes:
		soap_serialize_PointerTo_ns1__createAccountRes(soap, (struct _ns1__createAccountRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__createAccountReq:
		soap_serialize_PointerTo_ns1__createAccountReq(soap, (struct _ns1__createAccountReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPictureRes:
		soap_serialize_PointerTo_ns1__getPictureRes(soap, (struct _ns1__getPictureRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPictureReq:
		soap_serialize_PointerTo_ns1__getPictureReq(soap, (struct _ns1__getPictureReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__flaggedNoticeStatusRes:
		soap_serialize_PointerTo_ns1__flaggedNoticeStatusRes(soap, (struct _ns1__flaggedNoticeStatusRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__flaggedNoticeStatusReq:
		soap_serialize_PointerTo_ns1__flaggedNoticeStatusReq(soap, (struct _ns1__flaggedNoticeStatusReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryNoticesRes:
		soap_serialize_PointerTo_ns1__queryNoticesRes(soap, (struct _ns1__queryNoticesRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryNoticesReq:
		soap_serialize_PointerTo_ns1__queryNoticesReq(soap, (struct _ns1__queryNoticesReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__trustedAuthorityLoginRes:
		soap_serialize_PointerTons1__trustedAuthorityLoginRes(soap, (struct ns1__trustedAuthorityLoginRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__trustedAuthorityLoginReq:
		soap_serialize_PointerTons1__trustedAuthorityLoginReq(soap, (struct ns1__trustedAuthorityLoginReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDeviceMatchingResultRes:
		soap_serialize_PointerTo_ns1__getDeviceMatchingResultRes(soap, (struct _ns1__getDeviceMatchingResultRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDeviceMatchingResultReq:
		soap_serialize_PointerTo_ns1__getDeviceMatchingResultReq(soap, (struct _ns1__getDeviceMatchingResultReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDeviceMatchingCodeRes:
		soap_serialize_PointerTo_ns1__getDeviceMatchingCodeRes(soap, (struct _ns1__getDeviceMatchingCodeRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDeviceMatchingCodeReq:
		soap_serialize_PointerTo_ns1__getDeviceMatchingCodeReq(soap, (struct _ns1__getDeviceMatchingCodeReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDynamicPasswordRes:
		soap_serialize_PointerTo_ns1__getDynamicPasswordRes(soap, (struct _ns1__getDynamicPasswordRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDynamicPasswordReq:
		soap_serialize_PointerTo_ns1__getDynamicPasswordReq(soap, (struct _ns1__getDynamicPasswordReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getWirelessNetworkRes:
		soap_serialize_PointerTo_ns1__getWirelessNetworkRes(soap, (struct _ns1__getWirelessNetworkRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getWirelessNetworkReq:
		soap_serialize_PointerTo_ns1__getWirelessNetworkReq(soap, (struct _ns1__getWirelessNetworkReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setRelayRes:
		soap_serialize_PointerTo_ns1__setRelayRes(soap, (struct _ns1__setRelayRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setRelayReq:
		soap_serialize_PointerTo_ns1__setRelayReq(soap, (struct _ns1__setRelayReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRelayRes:
		soap_serialize_PointerTo_ns1__getRelayRes(soap, (struct _ns1__getRelayRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRelayReq:
		soap_serialize_PointerTo_ns1__getRelayReq(soap, (struct _ns1__getRelayReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setRecordParamRes:
		soap_serialize_PointerTo_ns1__setRecordParamRes(soap, (struct _ns1__setRecordParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setRecordParamReq:
		soap_serialize_PointerTo_ns1__setRecordParamReq(soap, (struct _ns1__setRecordParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRecordParamRes:
		soap_serialize_PointerTo_ns1__getRecordParamRes(soap, (struct _ns1__getRecordParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRecordParamReq:
		soap_serialize_PointerTo_ns1__getRecordParamReq(soap, (struct _ns1__getRecordParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setPushWorkSheetRes:
		soap_serialize_PointerTo_ns1__setPushWorkSheetRes(soap, (struct _ns1__setPushWorkSheetRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setPushWorkSheetReq:
		soap_serialize_PointerTo_ns1__setPushWorkSheetReq(soap, (struct _ns1__setPushWorkSheetReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPushWorkSheetRes:
		soap_serialize_PointerTo_ns1__getPushWorkSheetRes(soap, (struct _ns1__getPushWorkSheetRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPushWorkSheetReq:
		soap_serialize_PointerTo_ns1__getPushWorkSheetReq(soap, (struct _ns1__getPushWorkSheetReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__subscribeAndroidPushRes:
		soap_serialize_PointerTo_ns1__subscribeAndroidPushRes(soap, (struct _ns1__subscribeAndroidPushRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__subscribeAndroidPushReq:
		soap_serialize_PointerTo_ns1__subscribeAndroidPushReq(soap, (struct _ns1__subscribeAndroidPushReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__subscribeApplePushRes:
		soap_serialize_PointerTo_ns1__subscribeApplePushRes(soap, (struct _ns1__subscribeApplePushRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__subscribeApplePushReq:
		soap_serialize_PointerTo_ns1__subscribeApplePushReq(soap, (struct _ns1__subscribeApplePushReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__VODRecord:
		soap_serialize_PointerTons1__VODRecord(soap, (struct ns1__VODRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PrivacyMaskRegion:
		soap_serialize_PointerTons1__PrivacyMaskRegion(soap, (struct ns1__PrivacyMaskRegion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__VMDGrid:
		soap_serialize_PointerTons1__VMDGrid(soap, (struct ns1__VMDGrid *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__VideoStandard:
		soap_serialize_PointerTons1__VideoStandard(soap, (enum ns1__VideoStandard *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfDevLog:
		soap_serialize_PointerTons1__ArrayOfDevLog(soap, (struct ns1__ArrayOfDevLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfPuLog:
		soap_serialize_PointerTons1__ArrayOfPuLog(soap, (struct ns1__ArrayOfPuLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RateType:
		soap_serialize_PointerTons1__RateType(soap, (enum ns1__RateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FrameSize:
		soap_serialize_PointerTons1__FrameSize(soap, (enum ns1__FrameSize *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfDevice:
		soap_serialize_PointerTons1__ArrayOfDevice(soap, (struct ns1__ArrayOfDevice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfDeviceSharer:
		soap_serialize_PointerTons1__ArrayOfDeviceSharer(soap, (struct ns1__ArrayOfDeviceSharer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfPUEventLog:
		soap_serialize_PointerTons1__ArrayOfPUEventLog(soap, (struct ns1__ArrayOfPUEventLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EventState:
		soap_serialize_PointerTons1__EventState(soap, (enum ns1__EventState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EventType:
		soap_serialize_PointerTons1__EventType(soap, (enum ns1__EventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfPUOnOffLog:
		soap_serialize_PointerTons1__ArrayOfPUOnOffLog(soap, (struct ns1__ArrayOfPUOnOffLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfTURNServer:
		soap_serialize_PointerTons1__ArrayOfTURNServer(soap, (struct ns1__ArrayOfTURNServer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSTUNServer:
		soap_serialize_PointerTons1__ArrayOfSTUNServer(soap, (struct ns1__ArrayOfSTUNServer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AuxiliaryType:
		soap_serialize_PointerTons1__AuxiliaryType(soap, (enum ns1__AuxiliaryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AuxiliaryState:
		soap_serialize_PointerTons1__AuxiliaryState(soap, (enum ns1__AuxiliaryState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfNodeDetails:
		soap_serialize_PointerTons1__ArrayOfNodeDetails(soap, (struct ns1__ArrayOfNodeDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CountryAbbr2ISO3166:
		soap_serialize_PointerTons1__CountryAbbr2ISO3166(soap, (enum ns1__CountryAbbr2ISO3166 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfNotice:
		soap_serialize_PointerTons1__ArrayOfNotice(soap, (struct ns1__ArrayOfNotice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NoticeStatus:
		soap_serialize_PointerTons1__NoticeStatus(soap, (enum ns1__NoticeStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Relay:
		soap_serialize_PointerTons1__Relay(soap, (struct ns1__Relay *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__WorkSheet:
		soap_serialize_PointerTons1__WorkSheet(soap, (struct ns1__WorkSheet *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DevLog:
		soap_serialize_PointerTons1__DevLog(soap, (struct ns1__DevLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PuLog:
		soap_serialize_PointerTons1__PuLog(soap, (struct ns1__PuLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Device:
		soap_serialize_PointerTons1__Device(soap, (struct ns1__Device *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DeviceSharer:
		soap_serialize_PointerTons1__DeviceSharer(soap, (struct ns1__DeviceSharer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PUEventLog:
		soap_serialize_PointerTons1__PUEventLog(soap, (struct ns1__PUEventLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PUOnOffLog:
		soap_serialize_PointerTons1__PUOnOffLog(soap, (struct ns1__PUOnOffLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TURNServer:
		soap_serialize_PointerTons1__TURNServer(soap, (struct ns1__TURNServer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__STUNServer:
		soap_serialize_PointerTons1__STUNServer(soap, (struct ns1__STUNServer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__WirelessNetwork:
		soap_serialize_PointerTons1__WirelessNetwork(soap, (struct ns1__WirelessNetwork *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NodeDetails:
		soap_serialize_PointerTons1__NodeDetails(soap, (struct ns1__NodeDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		soap_serialize_PointerTons1__ArrayOfString(soap, (struct ns1__ArrayOfString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Notice:
		soap_serialize_PointerTons1__Notice(soap, (struct ns1__Notice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Dev:
		soap_serialize_PointerTons1__Dev(soap, (struct ns1__Dev *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfDev:
		soap_serialize_PointerTons1__ArrayOfDev(soap, (struct ns1__ArrayOfDev *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MCUDev:
		soap_serialize_PointerTons1__MCUDev(soap, (struct ns1__MCUDev *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RelayState:
		soap_serialize_PointerTons1__RelayState(soap, (enum ns1__RelayState *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__boolean:
		soap_serialize_PointerToxsd__boolean(soap, (enum xsd__boolean *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__VideoStandard(struct soap *soap, enum ns1__VideoStandard *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__VideoStandard
	*a = SOAP_DEFAULT_ns1__VideoStandard;
#else
	*a = (enum ns1__VideoStandard)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__VideoStandard[] =
{	{ (long)ns1__VideoStandard__PAL, "PAL" },
	{ (long)ns1__VideoStandard__NTSC, "NTSC" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__VideoStandard2s(struct soap *soap, enum ns1__VideoStandard n)
{	const char *s = soap_code_str(soap_codes_ns1__VideoStandard, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__VideoStandard(struct soap *soap, const char *tag, int id, const enum ns1__VideoStandard *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__VideoStandard), type) || soap_send(soap, soap_ns1__VideoStandard2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__VideoStandard(struct soap *soap, const char *s, enum ns1__VideoStandard *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__VideoStandard, s);
	if (map)
		*a = (enum ns1__VideoStandard)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__VideoStandard)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__VideoStandard * SOAP_FMAC4 soap_in_ns1__VideoStandard(struct soap *soap, const char *tag, enum ns1__VideoStandard *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__VideoStandard *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__VideoStandard, sizeof(enum ns1__VideoStandard), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__VideoStandard(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__VideoStandard *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__VideoStandard, 0, sizeof(enum ns1__VideoStandard), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__VideoStandard(struct soap *soap, const enum ns1__VideoStandard *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__VideoStandard);
	if (soap_out_ns1__VideoStandard(soap, tag?tag:"ns1:VideoStandard", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__VideoStandard * SOAP_FMAC4 soap_get_ns1__VideoStandard(struct soap *soap, enum ns1__VideoStandard *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__VideoStandard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__RateType(struct soap *soap, enum ns1__RateType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__RateType
	*a = SOAP_DEFAULT_ns1__RateType;
#else
	*a = (enum ns1__RateType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__RateType[] =
{	{ (long)ns1__RateType__CBR, "CBR" },
	{ (long)ns1__RateType__VBR, "VBR" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__RateType2s(struct soap *soap, enum ns1__RateType n)
{	const char *s = soap_code_str(soap_codes_ns1__RateType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RateType(struct soap *soap, const char *tag, int id, const enum ns1__RateType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RateType), type) || soap_send(soap, soap_ns1__RateType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__RateType(struct soap *soap, const char *s, enum ns1__RateType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__RateType, s);
	if (map)
		*a = (enum ns1__RateType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__RateType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__RateType * SOAP_FMAC4 soap_in_ns1__RateType(struct soap *soap, const char *tag, enum ns1__RateType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__RateType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RateType, sizeof(enum ns1__RateType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__RateType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__RateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RateType, 0, sizeof(enum ns1__RateType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__RateType(struct soap *soap, const enum ns1__RateType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__RateType);
	if (soap_out_ns1__RateType(soap, tag?tag:"ns1:RateType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__RateType * SOAP_FMAC4 soap_get_ns1__RateType(struct soap *soap, enum ns1__RateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__FrameSize(struct soap *soap, enum ns1__FrameSize *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__FrameSize
	*a = SOAP_DEFAULT_ns1__FrameSize;
#else
	*a = (enum ns1__FrameSize)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__FrameSize[] =
{	{ (long)ns1__FrameSize__HD720P, "HD720P" },
	{ (long)ns1__FrameSize__VGA, "VGA" },
	{ (long)ns1__FrameSize__D1, "D1" },
	{ (long)ns1__FrameSize__CIF, "CIF" },
	{ (long)ns1__FrameSize__QVGA, "QVGA" },
	{ (long)ns1__FrameSize__HD1080P, "HD1080P" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__FrameSize2s(struct soap *soap, enum ns1__FrameSize n)
{	const char *s = soap_code_str(soap_codes_ns1__FrameSize, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FrameSize(struct soap *soap, const char *tag, int id, const enum ns1__FrameSize *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FrameSize), type) || soap_send(soap, soap_ns1__FrameSize2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__FrameSize(struct soap *soap, const char *s, enum ns1__FrameSize *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__FrameSize, s);
	if (map)
		*a = (enum ns1__FrameSize)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__FrameSize)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__FrameSize * SOAP_FMAC4 soap_in_ns1__FrameSize(struct soap *soap, const char *tag, enum ns1__FrameSize *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__FrameSize *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FrameSize, sizeof(enum ns1__FrameSize), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__FrameSize(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__FrameSize *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FrameSize, 0, sizeof(enum ns1__FrameSize), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__FrameSize(struct soap *soap, const enum ns1__FrameSize *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__FrameSize);
	if (soap_out_ns1__FrameSize(soap, tag?tag:"ns1:FrameSize", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__FrameSize * SOAP_FMAC4 soap_get_ns1__FrameSize(struct soap *soap, enum ns1__FrameSize *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FrameSize(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PTZPreset(struct soap *soap, enum ns1__PTZPreset *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__PTZPreset
	*a = SOAP_DEFAULT_ns1__PTZPreset;
#else
	*a = (enum ns1__PTZPreset)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__PTZPreset[] =
{	{ (long)ns1__PTZPreset__Clear, "Clear" },
	{ (long)ns1__PTZPreset__Set, "Set" },
	{ (long)ns1__PTZPreset__Goto, "Goto" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__PTZPreset2s(struct soap *soap, enum ns1__PTZPreset n)
{	const char *s = soap_code_str(soap_codes_ns1__PTZPreset, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PTZPreset(struct soap *soap, const char *tag, int id, const enum ns1__PTZPreset *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PTZPreset), type) || soap_send(soap, soap_ns1__PTZPreset2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__PTZPreset(struct soap *soap, const char *s, enum ns1__PTZPreset *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__PTZPreset, s);
	if (map)
		*a = (enum ns1__PTZPreset)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__PTZPreset)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__PTZPreset * SOAP_FMAC4 soap_in_ns1__PTZPreset(struct soap *soap, const char *tag, enum ns1__PTZPreset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__PTZPreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PTZPreset, sizeof(enum ns1__PTZPreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__PTZPreset(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__PTZPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PTZPreset, 0, sizeof(enum ns1__PTZPreset), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PTZPreset(struct soap *soap, const enum ns1__PTZPreset *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PTZPreset);
	if (soap_out_ns1__PTZPreset(soap, tag?tag:"ns1:PTZPreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__PTZPreset * SOAP_FMAC4 soap_get_ns1__PTZPreset(struct soap *soap, enum ns1__PTZPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PTZPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PTZLens(struct soap *soap, enum ns1__PTZLens *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__PTZLens
	*a = SOAP_DEFAULT_ns1__PTZLens;
#else
	*a = (enum ns1__PTZLens)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__PTZLens[] =
{	{ (long)ns1__PTZLens__Stop, "Stop" },
	{ (long)ns1__PTZLens__IrisOpen, "IrisOpen" },
	{ (long)ns1__PTZLens__IrisClose, "IrisClose" },
	{ (long)ns1__PTZLens__ZoomTele, "ZoomTele" },
	{ (long)ns1__PTZLens__ZoomWide, "ZoomWide" },
	{ (long)ns1__PTZLens__FocusFar, "FocusFar" },
	{ (long)ns1__PTZLens__FocusNear, "FocusNear" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__PTZLens2s(struct soap *soap, enum ns1__PTZLens n)
{	const char *s = soap_code_str(soap_codes_ns1__PTZLens, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PTZLens(struct soap *soap, const char *tag, int id, const enum ns1__PTZLens *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PTZLens), type) || soap_send(soap, soap_ns1__PTZLens2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__PTZLens(struct soap *soap, const char *s, enum ns1__PTZLens *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__PTZLens, s);
	if (map)
		*a = (enum ns1__PTZLens)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__PTZLens)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__PTZLens * SOAP_FMAC4 soap_in_ns1__PTZLens(struct soap *soap, const char *tag, enum ns1__PTZLens *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__PTZLens *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PTZLens, sizeof(enum ns1__PTZLens), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__PTZLens(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__PTZLens *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PTZLens, 0, sizeof(enum ns1__PTZLens), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PTZLens(struct soap *soap, const enum ns1__PTZLens *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PTZLens);
	if (soap_out_ns1__PTZLens(soap, tag?tag:"ns1:PTZLens", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__PTZLens * SOAP_FMAC4 soap_get_ns1__PTZLens(struct soap *soap, enum ns1__PTZLens *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PTZLens(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PTZDirection(struct soap *soap, enum ns1__PTZDirection *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__PTZDirection
	*a = SOAP_DEFAULT_ns1__PTZDirection;
#else
	*a = (enum ns1__PTZDirection)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__PTZDirection[] =
{	{ (long)ns1__PTZDirection__Stop, "Stop" },
	{ (long)ns1__PTZDirection__Up, "Up" },
	{ (long)ns1__PTZDirection__Down, "Down" },
	{ (long)ns1__PTZDirection__Left, "Left" },
	{ (long)ns1__PTZDirection__Right, "Right" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__PTZDirection2s(struct soap *soap, enum ns1__PTZDirection n)
{	const char *s = soap_code_str(soap_codes_ns1__PTZDirection, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PTZDirection(struct soap *soap, const char *tag, int id, const enum ns1__PTZDirection *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PTZDirection), type) || soap_send(soap, soap_ns1__PTZDirection2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__PTZDirection(struct soap *soap, const char *s, enum ns1__PTZDirection *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__PTZDirection, s);
	if (map)
		*a = (enum ns1__PTZDirection)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__PTZDirection)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__PTZDirection * SOAP_FMAC4 soap_in_ns1__PTZDirection(struct soap *soap, const char *tag, enum ns1__PTZDirection *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__PTZDirection *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PTZDirection, sizeof(enum ns1__PTZDirection), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__PTZDirection(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__PTZDirection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PTZDirection, 0, sizeof(enum ns1__PTZDirection), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PTZDirection(struct soap *soap, const enum ns1__PTZDirection *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PTZDirection);
	if (soap_out_ns1__PTZDirection(soap, tag?tag:"ns1:PTZDirection", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__PTZDirection * SOAP_FMAC4 soap_get_ns1__PTZDirection(struct soap *soap, enum ns1__PTZDirection *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PTZDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PwdType(struct soap *soap, enum ns1__PwdType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__PwdType
	*a = SOAP_DEFAULT_ns1__PwdType;
#else
	*a = (enum ns1__PwdType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__PwdType[] =
{	{ (long)ns1__PwdType__Common, "Common" },
	{ (long)ns1__PwdType__Dynamic, "Dynamic" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__PwdType2s(struct soap *soap, enum ns1__PwdType n)
{	const char *s = soap_code_str(soap_codes_ns1__PwdType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PwdType(struct soap *soap, const char *tag, int id, const enum ns1__PwdType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PwdType), type) || soap_send(soap, soap_ns1__PwdType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__PwdType(struct soap *soap, const char *s, enum ns1__PwdType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__PwdType, s);
	if (map)
		*a = (enum ns1__PwdType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__PwdType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__PwdType * SOAP_FMAC4 soap_in_ns1__PwdType(struct soap *soap, const char *tag, enum ns1__PwdType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__PwdType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PwdType, sizeof(enum ns1__PwdType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__PwdType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__PwdType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PwdType, 0, sizeof(enum ns1__PwdType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PwdType(struct soap *soap, const enum ns1__PwdType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PwdType);
	if (soap_out_ns1__PwdType(soap, tag?tag:"ns1:PwdType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__PwdType * SOAP_FMAC4 soap_get_ns1__PwdType(struct soap *soap, enum ns1__PwdType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PwdType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__MCUClientType(struct soap *soap, enum ns1__MCUClientType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__MCUClientType
	*a = SOAP_DEFAULT_ns1__MCUClientType;
#else
	*a = (enum ns1__MCUClientType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__MCUClientType[] =
{	{ (long)ns1__MCUClientType__IPhone, "IPhone" },
	{ (long)ns1__MCUClientType__Android, "Android" },
	{ (long)ns1__MCUClientType__Windows, "Windows" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__MCUClientType2s(struct soap *soap, enum ns1__MCUClientType n)
{	const char *s = soap_code_str(soap_codes_ns1__MCUClientType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MCUClientType(struct soap *soap, const char *tag, int id, const enum ns1__MCUClientType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MCUClientType), type) || soap_send(soap, soap_ns1__MCUClientType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__MCUClientType(struct soap *soap, const char *s, enum ns1__MCUClientType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__MCUClientType, s);
	if (map)
		*a = (enum ns1__MCUClientType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__MCUClientType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__MCUClientType * SOAP_FMAC4 soap_in_ns1__MCUClientType(struct soap *soap, const char *tag, enum ns1__MCUClientType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__MCUClientType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MCUClientType, sizeof(enum ns1__MCUClientType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__MCUClientType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__MCUClientType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MCUClientType, 0, sizeof(enum ns1__MCUClientType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MCUClientType(struct soap *soap, const enum ns1__MCUClientType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__MCUClientType);
	if (soap_out_ns1__MCUClientType(soap, tag?tag:"ns1:MCUClientType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__MCUClientType * SOAP_FMAC4 soap_get_ns1__MCUClientType(struct soap *soap, enum ns1__MCUClientType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MCUClientType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__EventState(struct soap *soap, enum ns1__EventState *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__EventState
	*a = SOAP_DEFAULT_ns1__EventState;
#else
	*a = (enum ns1__EventState)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__EventState[] =
{	{ (long)ns1__EventState__Inactive, "Inactive" },
	{ (long)ns1__EventState__Active, "Active" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__EventState2s(struct soap *soap, enum ns1__EventState n)
{	const char *s = soap_code_str(soap_codes_ns1__EventState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EventState(struct soap *soap, const char *tag, int id, const enum ns1__EventState *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EventState), type) || soap_send(soap, soap_ns1__EventState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__EventState(struct soap *soap, const char *s, enum ns1__EventState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__EventState, s);
	if (map)
		*a = (enum ns1__EventState)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__EventState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__EventState * SOAP_FMAC4 soap_in_ns1__EventState(struct soap *soap, const char *tag, enum ns1__EventState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__EventState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EventState, sizeof(enum ns1__EventState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__EventState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__EventState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EventState, 0, sizeof(enum ns1__EventState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__EventState(struct soap *soap, const enum ns1__EventState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__EventState);
	if (soap_out_ns1__EventState(soap, tag?tag:"ns1:EventState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__EventState * SOAP_FMAC4 soap_get_ns1__EventState(struct soap *soap, enum ns1__EventState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EventState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__EventType(struct soap *soap, enum ns1__EventType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__EventType
	*a = SOAP_DEFAULT_ns1__EventType;
#else
	*a = (enum ns1__EventType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__EventType[] =
{	{ (long)ns1__EventType__VMD, "VMD" },
	{ (long)ns1__EventType__IO, "IO" },
	{ (long)ns1__EventType__Videoloss, "Videoloss" },
	{ (long)ns1__EventType__VideoShelter, "VideoShelter" },
	{ (long)ns1__EventType__DoorBell, "DoorBell" },
	{ (long)ns1__EventType__Infrared, "Infrared" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__EventType2s(struct soap *soap, enum ns1__EventType n)
{	const char *s = soap_code_str(soap_codes_ns1__EventType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EventType(struct soap *soap, const char *tag, int id, const enum ns1__EventType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EventType), type) || soap_send(soap, soap_ns1__EventType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__EventType(struct soap *soap, const char *s, enum ns1__EventType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__EventType, s);
	if (map)
		*a = (enum ns1__EventType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__EventType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__EventType * SOAP_FMAC4 soap_in_ns1__EventType(struct soap *soap, const char *tag, enum ns1__EventType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__EventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EventType, sizeof(enum ns1__EventType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__EventType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__EventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EventType, 0, sizeof(enum ns1__EventType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__EventType(struct soap *soap, const enum ns1__EventType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__EventType);
	if (soap_out_ns1__EventType(soap, tag?tag:"ns1:EventType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__EventType * SOAP_FMAC4 soap_get_ns1__EventType(struct soap *soap, enum ns1__EventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__NATType(struct soap *soap, enum ns1__NATType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__NATType
	*a = SOAP_DEFAULT_ns1__NATType;
#else
	*a = (enum ns1__NATType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__NATType[] =
{	{ (long)ns1__NATType__Other, "Other" },
	{ (long)ns1__NATType__TURN, "TURN" },
	{ (long)ns1__NATType__STUN, "STUN" },
	{ (long)ns1__NATType__UPnP, "UPnP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__NATType2s(struct soap *soap, enum ns1__NATType n)
{	const char *s = soap_code_str(soap_codes_ns1__NATType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NATType(struct soap *soap, const char *tag, int id, const enum ns1__NATType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NATType), type) || soap_send(soap, soap_ns1__NATType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__NATType(struct soap *soap, const char *s, enum ns1__NATType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__NATType, s);
	if (map)
		*a = (enum ns1__NATType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__NATType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__NATType * SOAP_FMAC4 soap_in_ns1__NATType(struct soap *soap, const char *tag, enum ns1__NATType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__NATType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NATType, sizeof(enum ns1__NATType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__NATType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__NATType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NATType, 0, sizeof(enum ns1__NATType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__NATType(struct soap *soap, const enum ns1__NATType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__NATType);
	if (soap_out_ns1__NATType(soap, tag?tag:"ns1:NATType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__NATType * SOAP_FMAC4 soap_get_ns1__NATType(struct soap *soap, enum ns1__NATType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NATType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__StreamType(struct soap *soap, enum ns1__StreamType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__StreamType
	*a = SOAP_DEFAULT_ns1__StreamType;
#else
	*a = (enum ns1__StreamType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__StreamType[] =
{	{ (long)ns1__StreamType__Main, "Main" },
	{ (long)ns1__StreamType__Sub, "Sub" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__StreamType2s(struct soap *soap, enum ns1__StreamType n)
{	const char *s = soap_code_str(soap_codes_ns1__StreamType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StreamType(struct soap *soap, const char *tag, int id, const enum ns1__StreamType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StreamType), type) || soap_send(soap, soap_ns1__StreamType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__StreamType(struct soap *soap, const char *s, enum ns1__StreamType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__StreamType, s);
	if (map)
		*a = (enum ns1__StreamType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__StreamType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__StreamType * SOAP_FMAC4 soap_in_ns1__StreamType(struct soap *soap, const char *tag, enum ns1__StreamType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__StreamType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StreamType, sizeof(enum ns1__StreamType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__StreamType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__StreamType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StreamType, 0, sizeof(enum ns1__StreamType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__StreamType(struct soap *soap, const enum ns1__StreamType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__StreamType);
	if (soap_out_ns1__StreamType(soap, tag?tag:"ns1:StreamType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__StreamType * SOAP_FMAC4 soap_get_ns1__StreamType(struct soap *soap, enum ns1__StreamType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StreamType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AuxiliaryState(struct soap *soap, enum ns1__AuxiliaryState *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__AuxiliaryState
	*a = SOAP_DEFAULT_ns1__AuxiliaryState;
#else
	*a = (enum ns1__AuxiliaryState)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__AuxiliaryState[] =
{	{ (long)ns1__AuxiliaryState__Inactive, "Inactive" },
	{ (long)ns1__AuxiliaryState__Active, "Active" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__AuxiliaryState2s(struct soap *soap, enum ns1__AuxiliaryState n)
{	const char *s = soap_code_str(soap_codes_ns1__AuxiliaryState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AuxiliaryState(struct soap *soap, const char *tag, int id, const enum ns1__AuxiliaryState *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AuxiliaryState), type) || soap_send(soap, soap_ns1__AuxiliaryState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__AuxiliaryState(struct soap *soap, const char *s, enum ns1__AuxiliaryState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__AuxiliaryState, s);
	if (map)
		*a = (enum ns1__AuxiliaryState)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__AuxiliaryState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__AuxiliaryState * SOAP_FMAC4 soap_in_ns1__AuxiliaryState(struct soap *soap, const char *tag, enum ns1__AuxiliaryState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__AuxiliaryState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AuxiliaryState, sizeof(enum ns1__AuxiliaryState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__AuxiliaryState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__AuxiliaryState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AuxiliaryState, 0, sizeof(enum ns1__AuxiliaryState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AuxiliaryState(struct soap *soap, const enum ns1__AuxiliaryState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__AuxiliaryState);
	if (soap_out_ns1__AuxiliaryState(soap, tag?tag:"ns1:AuxiliaryState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__AuxiliaryState * SOAP_FMAC4 soap_get_ns1__AuxiliaryState(struct soap *soap, enum ns1__AuxiliaryState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AuxiliaryState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AuxiliaryType(struct soap *soap, enum ns1__AuxiliaryType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__AuxiliaryType
	*a = SOAP_DEFAULT_ns1__AuxiliaryType;
#else
	*a = (enum ns1__AuxiliaryType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__AuxiliaryType[] =
{	{ (long)ns1__AuxiliaryType__Lighting, "Lighting" },
	{ (long)ns1__AuxiliaryType__SignalLamp, "SignalLamp" },
	{ (long)ns1__AuxiliaryType__MonitorMode, "MonitorMode" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__AuxiliaryType2s(struct soap *soap, enum ns1__AuxiliaryType n)
{	const char *s = soap_code_str(soap_codes_ns1__AuxiliaryType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AuxiliaryType(struct soap *soap, const char *tag, int id, const enum ns1__AuxiliaryType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AuxiliaryType), type) || soap_send(soap, soap_ns1__AuxiliaryType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__AuxiliaryType(struct soap *soap, const char *s, enum ns1__AuxiliaryType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__AuxiliaryType, s);
	if (map)
		*a = (enum ns1__AuxiliaryType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__AuxiliaryType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__AuxiliaryType * SOAP_FMAC4 soap_in_ns1__AuxiliaryType(struct soap *soap, const char *tag, enum ns1__AuxiliaryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__AuxiliaryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AuxiliaryType, sizeof(enum ns1__AuxiliaryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__AuxiliaryType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__AuxiliaryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AuxiliaryType, 0, sizeof(enum ns1__AuxiliaryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AuxiliaryType(struct soap *soap, const enum ns1__AuxiliaryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__AuxiliaryType);
	if (soap_out_ns1__AuxiliaryType(soap, tag?tag:"ns1:AuxiliaryType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__AuxiliaryType * SOAP_FMAC4 soap_get_ns1__AuxiliaryType(struct soap *soap, enum ns1__AuxiliaryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AuxiliaryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeliveryType(struct soap *soap, enum ns1__DeliveryType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__DeliveryType
	*a = SOAP_DEFAULT_ns1__DeliveryType;
#else
	*a = (enum ns1__DeliveryType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__DeliveryType[] =
{	{ (long)ns1__DeliveryType__Email, "Email" },
	{ (long)ns1__DeliveryType__Mobile, "Mobile" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__DeliveryType2s(struct soap *soap, enum ns1__DeliveryType n)
{	const char *s = soap_code_str(soap_codes_ns1__DeliveryType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeliveryType(struct soap *soap, const char *tag, int id, const enum ns1__DeliveryType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeliveryType), type) || soap_send(soap, soap_ns1__DeliveryType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__DeliveryType(struct soap *soap, const char *s, enum ns1__DeliveryType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__DeliveryType, s);
	if (map)
		*a = (enum ns1__DeliveryType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__DeliveryType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__DeliveryType * SOAP_FMAC4 soap_in_ns1__DeliveryType(struct soap *soap, const char *tag, enum ns1__DeliveryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__DeliveryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeliveryType, sizeof(enum ns1__DeliveryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__DeliveryType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__DeliveryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeliveryType, 0, sizeof(enum ns1__DeliveryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeliveryType(struct soap *soap, const enum ns1__DeliveryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DeliveryType);
	if (soap_out_ns1__DeliveryType(soap, tag?tag:"ns1:DeliveryType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__DeliveryType * SOAP_FMAC4 soap_get_ns1__DeliveryType(struct soap *soap, enum ns1__DeliveryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeliveryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__CountryAbbr2ISO3166(struct soap *soap, enum ns1__CountryAbbr2ISO3166 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__CountryAbbr2ISO3166
	*a = SOAP_DEFAULT_ns1__CountryAbbr2ISO3166;
#else
	*a = (enum ns1__CountryAbbr2ISO3166)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__CountryAbbr2ISO3166[] =
{	{ (long)ns1__CountryAbbr2ISO3166__AF, "AF" },
	{ (long)ns1__CountryAbbr2ISO3166__AL, "AL" },
	{ (long)ns1__CountryAbbr2ISO3166__DZ, "DZ" },
	{ (long)ns1__CountryAbbr2ISO3166__AS, "AS" },
	{ (long)ns1__CountryAbbr2ISO3166__AD, "AD" },
	{ (long)ns1__CountryAbbr2ISO3166__AO, "AO" },
	{ (long)ns1__CountryAbbr2ISO3166__AI, "AI" },
	{ (long)ns1__CountryAbbr2ISO3166__AG, "AG" },
	{ (long)ns1__CountryAbbr2ISO3166__AR, "AR" },
	{ (long)ns1__CountryAbbr2ISO3166__AM, "AM" },
	{ (long)ns1__CountryAbbr2ISO3166__AW, "AW" },
	{ (long)ns1__CountryAbbr2ISO3166__AU, "AU" },
	{ (long)ns1__CountryAbbr2ISO3166__AT, "AT" },
	{ (long)ns1__CountryAbbr2ISO3166__AZ, "AZ" },
	{ (long)ns1__CountryAbbr2ISO3166__BH, "BH" },
	{ (long)ns1__CountryAbbr2ISO3166__BD, "BD" },
	{ (long)ns1__CountryAbbr2ISO3166__BB, "BB" },
	{ (long)ns1__CountryAbbr2ISO3166__BY, "BY" },
	{ (long)ns1__CountryAbbr2ISO3166__BE, "BE" },
	{ (long)ns1__CountryAbbr2ISO3166__BZ, "BZ" },
	{ (long)ns1__CountryAbbr2ISO3166__BJ, "BJ" },
	{ (long)ns1__CountryAbbr2ISO3166__BM, "BM" },
	{ (long)ns1__CountryAbbr2ISO3166__BT, "BT" },
	{ (long)ns1__CountryAbbr2ISO3166__BO, "BO" },
	{ (long)ns1__CountryAbbr2ISO3166__BA, "BA" },
	{ (long)ns1__CountryAbbr2ISO3166__BW, "BW" },
	{ (long)ns1__CountryAbbr2ISO3166__BR, "BR" },
	{ (long)ns1__CountryAbbr2ISO3166__BN, "BN" },
	{ (long)ns1__CountryAbbr2ISO3166__BG, "BG" },
	{ (long)ns1__CountryAbbr2ISO3166__BF, "BF" },
	{ (long)ns1__CountryAbbr2ISO3166__BI, "BI" },
	{ (long)ns1__CountryAbbr2ISO3166__KH, "KH" },
	{ (long)ns1__CountryAbbr2ISO3166__CM, "CM" },
	{ (long)ns1__CountryAbbr2ISO3166__CA, "CA" },
	{ (long)ns1__CountryAbbr2ISO3166__CV, "CV" },
	{ (long)ns1__CountryAbbr2ISO3166__KY, "KY" },
	{ (long)ns1__CountryAbbr2ISO3166__CF, "CF" },
	{ (long)ns1__CountryAbbr2ISO3166__TD, "TD" },
	{ (long)ns1__CountryAbbr2ISO3166__CL, "CL" },
	{ (long)ns1__CountryAbbr2ISO3166__CN, "CN" },
	{ (long)ns1__CountryAbbr2ISO3166__CX, "CX" },
	{ (long)ns1__CountryAbbr2ISO3166__CO, "CO" },
	{ (long)ns1__CountryAbbr2ISO3166__CK, "CK" },
	{ (long)ns1__CountryAbbr2ISO3166__CR, "CR" },
	{ (long)ns1__CountryAbbr2ISO3166__HR, "HR" },
	{ (long)ns1__CountryAbbr2ISO3166__CU, "CU" },
	{ (long)ns1__CountryAbbr2ISO3166__CY, "CY" },
	{ (long)ns1__CountryAbbr2ISO3166__CZ, "CZ" },
	{ (long)ns1__CountryAbbr2ISO3166__CI, "CI" },
	{ (long)ns1__CountryAbbr2ISO3166__CD, "CD" },
	{ (long)ns1__CountryAbbr2ISO3166__DK, "DK" },
	{ (long)ns1__CountryAbbr2ISO3166__DJ, "DJ" },
	{ (long)ns1__CountryAbbr2ISO3166__DM, "DM" },
	{ (long)ns1__CountryAbbr2ISO3166__DO, "DO" },
	{ (long)ns1__CountryAbbr2ISO3166__EC, "EC" },
	{ (long)ns1__CountryAbbr2ISO3166__EG, "EG" },
	{ (long)ns1__CountryAbbr2ISO3166__SV, "SV" },
	{ (long)ns1__CountryAbbr2ISO3166__GQ, "GQ" },
	{ (long)ns1__CountryAbbr2ISO3166__ER, "ER" },
	{ (long)ns1__CountryAbbr2ISO3166__EE, "EE" },
	{ (long)ns1__CountryAbbr2ISO3166__ET, "ET" },
	{ (long)ns1__CountryAbbr2ISO3166__FK, "FK" },
	{ (long)ns1__CountryAbbr2ISO3166__FO, "FO" },
	{ (long)ns1__CountryAbbr2ISO3166__FM, "FM" },
	{ (long)ns1__CountryAbbr2ISO3166__FJ, "FJ" },
	{ (long)ns1__CountryAbbr2ISO3166__FI, "FI" },
	{ (long)ns1__CountryAbbr2ISO3166__FR, "FR" },
	{ (long)ns1__CountryAbbr2ISO3166__GF, "GF" },
	{ (long)ns1__CountryAbbr2ISO3166__PF, "PF" },
	{ (long)ns1__CountryAbbr2ISO3166__GA, "GA" },
	{ (long)ns1__CountryAbbr2ISO3166__GM, "GM" },
	{ (long)ns1__CountryAbbr2ISO3166__GE, "GE" },
	{ (long)ns1__CountryAbbr2ISO3166__DE, "DE" },
	{ (long)ns1__CountryAbbr2ISO3166__GH, "GH" },
	{ (long)ns1__CountryAbbr2ISO3166__GI, "GI" },
	{ (long)ns1__CountryAbbr2ISO3166__GB, "GB" },
	{ (long)ns1__CountryAbbr2ISO3166__GR, "GR" },
	{ (long)ns1__CountryAbbr2ISO3166__GL, "GL" },
	{ (long)ns1__CountryAbbr2ISO3166__GD, "GD" },
	{ (long)ns1__CountryAbbr2ISO3166__GP, "GP" },
	{ (long)ns1__CountryAbbr2ISO3166__GU, "GU" },
	{ (long)ns1__CountryAbbr2ISO3166__GT, "GT" },
	{ (long)ns1__CountryAbbr2ISO3166__GN, "GN" },
	{ (long)ns1__CountryAbbr2ISO3166__GW, "GW" },
	{ (long)ns1__CountryAbbr2ISO3166__GY, "GY" },
	{ (long)ns1__CountryAbbr2ISO3166__HT, "HT" },
	{ (long)ns1__CountryAbbr2ISO3166__HN, "HN" },
	{ (long)ns1__CountryAbbr2ISO3166__HK, "HK" },
	{ (long)ns1__CountryAbbr2ISO3166__HU, "HU" },
	{ (long)ns1__CountryAbbr2ISO3166__ID, "ID" },
	{ (long)ns1__CountryAbbr2ISO3166__IE, "IE" },
	{ (long)ns1__CountryAbbr2ISO3166__IL, "IL" },
	{ (long)ns1__CountryAbbr2ISO3166__IN, "IN" },
	{ (long)ns1__CountryAbbr2ISO3166__IQ, "IQ" },
	{ (long)ns1__CountryAbbr2ISO3166__IR, "IR" },
	{ (long)ns1__CountryAbbr2ISO3166__IS, "IS" },
	{ (long)ns1__CountryAbbr2ISO3166__IT, "IT" },
	{ (long)ns1__CountryAbbr2ISO3166__JM, "JM" },
	{ (long)ns1__CountryAbbr2ISO3166__JO, "JO" },
	{ (long)ns1__CountryAbbr2ISO3166__JP, "JP" },
	{ (long)ns1__CountryAbbr2ISO3166__KE, "KE" },
	{ (long)ns1__CountryAbbr2ISO3166__KG, "KG" },
	{ (long)ns1__CountryAbbr2ISO3166__KI, "KI" },
	{ (long)ns1__CountryAbbr2ISO3166__KM, "KM" },
	{ (long)ns1__CountryAbbr2ISO3166__KN, "KN" },
	{ (long)ns1__CountryAbbr2ISO3166__KP, "KP" },
	{ (long)ns1__CountryAbbr2ISO3166__KR, "KR" },
	{ (long)ns1__CountryAbbr2ISO3166__KW, "KW" },
	{ (long)ns1__CountryAbbr2ISO3166__KZ, "KZ" },
	{ (long)ns1__CountryAbbr2ISO3166__LA, "LA" },
	{ (long)ns1__CountryAbbr2ISO3166__LB, "LB" },
	{ (long)ns1__CountryAbbr2ISO3166__LC, "LC" },
	{ (long)ns1__CountryAbbr2ISO3166__LI, "LI" },
	{ (long)ns1__CountryAbbr2ISO3166__LK, "LK" },
	{ (long)ns1__CountryAbbr2ISO3166__LR, "LR" },
	{ (long)ns1__CountryAbbr2ISO3166__LS, "LS" },
	{ (long)ns1__CountryAbbr2ISO3166__LT, "LT" },
	{ (long)ns1__CountryAbbr2ISO3166__LU, "LU" },
	{ (long)ns1__CountryAbbr2ISO3166__LV, "LV" },
	{ (long)ns1__CountryAbbr2ISO3166__LY, "LY" },
	{ (long)ns1__CountryAbbr2ISO3166__MA, "MA" },
	{ (long)ns1__CountryAbbr2ISO3166__MC, "MC" },
	{ (long)ns1__CountryAbbr2ISO3166__MD, "MD" },
	{ (long)ns1__CountryAbbr2ISO3166__ME, "ME" },
	{ (long)ns1__CountryAbbr2ISO3166__MG, "MG" },
	{ (long)ns1__CountryAbbr2ISO3166__MH, "MH" },
	{ (long)ns1__CountryAbbr2ISO3166__MK, "MK" },
	{ (long)ns1__CountryAbbr2ISO3166__ML, "ML" },
	{ (long)ns1__CountryAbbr2ISO3166__MM, "MM" },
	{ (long)ns1__CountryAbbr2ISO3166__MN, "MN" },
	{ (long)ns1__CountryAbbr2ISO3166__MO, "MO" },
	{ (long)ns1__CountryAbbr2ISO3166__MP, "MP" },
	{ (long)ns1__CountryAbbr2ISO3166__MQ, "MQ" },
	{ (long)ns1__CountryAbbr2ISO3166__MR, "MR" },
	{ (long)ns1__CountryAbbr2ISO3166__MT, "MT" },
	{ (long)ns1__CountryAbbr2ISO3166__MU, "MU" },
	{ (long)ns1__CountryAbbr2ISO3166__MV, "MV" },
	{ (long)ns1__CountryAbbr2ISO3166__MW, "MW" },
	{ (long)ns1__CountryAbbr2ISO3166__MX, "MX" },
	{ (long)ns1__CountryAbbr2ISO3166__MY, "MY" },
	{ (long)ns1__CountryAbbr2ISO3166__MZ, "MZ" },
	{ (long)ns1__CountryAbbr2ISO3166__NA, "NA" },
	{ (long)ns1__CountryAbbr2ISO3166__NC, "NC" },
	{ (long)ns1__CountryAbbr2ISO3166__NE, "NE" },
	{ (long)ns1__CountryAbbr2ISO3166__NG, "NG" },
	{ (long)ns1__CountryAbbr2ISO3166__NI, "NI" },
	{ (long)ns1__CountryAbbr2ISO3166__NL, "NL" },
	{ (long)ns1__CountryAbbr2ISO3166__NO, "NO" },
	{ (long)ns1__CountryAbbr2ISO3166__NP, "NP" },
	{ (long)ns1__CountryAbbr2ISO3166__NR, "NR" },
	{ (long)ns1__CountryAbbr2ISO3166__NU, "NU" },
	{ (long)ns1__CountryAbbr2ISO3166__NZ, "NZ" },
	{ (long)ns1__CountryAbbr2ISO3166__OM, "OM" },
	{ (long)ns1__CountryAbbr2ISO3166__PA, "PA" },
	{ (long)ns1__CountryAbbr2ISO3166__PE, "PE" },
	{ (long)ns1__CountryAbbr2ISO3166__PG, "PG" },
	{ (long)ns1__CountryAbbr2ISO3166__PH, "PH" },
	{ (long)ns1__CountryAbbr2ISO3166__PK, "PK" },
	{ (long)ns1__CountryAbbr2ISO3166__PL, "PL" },
	{ (long)ns1__CountryAbbr2ISO3166__PM, "PM" },
	{ (long)ns1__CountryAbbr2ISO3166__PR, "PR" },
	{ (long)ns1__CountryAbbr2ISO3166__PS, "PS" },
	{ (long)ns1__CountryAbbr2ISO3166__PT, "PT" },
	{ (long)ns1__CountryAbbr2ISO3166__PW, "PW" },
	{ (long)ns1__CountryAbbr2ISO3166__PY, "PY" },
	{ (long)ns1__CountryAbbr2ISO3166__QA, "QA" },
	{ (long)ns1__CountryAbbr2ISO3166__RE, "RE" },
	{ (long)ns1__CountryAbbr2ISO3166__RO, "RO" },
	{ (long)ns1__CountryAbbr2ISO3166__RS, "RS" },
	{ (long)ns1__CountryAbbr2ISO3166__RU, "RU" },
	{ (long)ns1__CountryAbbr2ISO3166__RW, "RW" },
	{ (long)ns1__CountryAbbr2ISO3166__SA, "SA" },
	{ (long)ns1__CountryAbbr2ISO3166__SB, "SB" },
	{ (long)ns1__CountryAbbr2ISO3166__SC, "SC" },
	{ (long)ns1__CountryAbbr2ISO3166__SD, "SD" },
	{ (long)ns1__CountryAbbr2ISO3166__SE, "SE" },
	{ (long)ns1__CountryAbbr2ISO3166__SG, "SG" },
	{ (long)ns1__CountryAbbr2ISO3166__SH, "SH" },
	{ (long)ns1__CountryAbbr2ISO3166__SI, "SI" },
	{ (long)ns1__CountryAbbr2ISO3166__SK, "SK" },
	{ (long)ns1__CountryAbbr2ISO3166__SL, "SL" },
	{ (long)ns1__CountryAbbr2ISO3166__SM, "SM" },
	{ (long)ns1__CountryAbbr2ISO3166__SN, "SN" },
	{ (long)ns1__CountryAbbr2ISO3166__SO, "SO" },
	{ (long)ns1__CountryAbbr2ISO3166__SR, "SR" },
	{ (long)ns1__CountryAbbr2ISO3166__SS, "SS" },
	{ (long)ns1__CountryAbbr2ISO3166__ST, "ST" },
	{ (long)ns1__CountryAbbr2ISO3166__SY, "SY" },
	{ (long)ns1__CountryAbbr2ISO3166__SZ, "SZ" },
	{ (long)ns1__CountryAbbr2ISO3166__TC, "TC" },
	{ (long)ns1__CountryAbbr2ISO3166__TG, "TG" },
	{ (long)ns1__CountryAbbr2ISO3166__TH, "TH" },
	{ (long)ns1__CountryAbbr2ISO3166__TJ, "TJ" },
	{ (long)ns1__CountryAbbr2ISO3166__TK, "TK" },
	{ (long)ns1__CountryAbbr2ISO3166__TL, "TL" },
	{ (long)ns1__CountryAbbr2ISO3166__TM, "TM" },
	{ (long)ns1__CountryAbbr2ISO3166__TN, "TN" },
	{ (long)ns1__CountryAbbr2ISO3166__TO, "TO" },
	{ (long)ns1__CountryAbbr2ISO3166__TR, "TR" },
	{ (long)ns1__CountryAbbr2ISO3166__TT, "TT" },
	{ (long)ns1__CountryAbbr2ISO3166__TV, "TV" },
	{ (long)ns1__CountryAbbr2ISO3166__TW, "TW" },
	{ (long)ns1__CountryAbbr2ISO3166__TZ, "TZ" },
	{ (long)ns1__CountryAbbr2ISO3166__UA, "UA" },
	{ (long)ns1__CountryAbbr2ISO3166__UG, "UG" },
	{ (long)ns1__CountryAbbr2ISO3166__US, "US" },
	{ (long)ns1__CountryAbbr2ISO3166__UY, "UY" },
	{ (long)ns1__CountryAbbr2ISO3166__UZ, "UZ" },
	{ (long)ns1__CountryAbbr2ISO3166__VE, "VE" },
	{ (long)ns1__CountryAbbr2ISO3166__VN, "VN" },
	{ (long)ns1__CountryAbbr2ISO3166__VU, "VU" },
	{ (long)ns1__CountryAbbr2ISO3166__WF, "WF" },
	{ (long)ns1__CountryAbbr2ISO3166__WS, "WS" },
	{ (long)ns1__CountryAbbr2ISO3166__YE, "YE" },
	{ (long)ns1__CountryAbbr2ISO3166__YT, "YT" },
	{ (long)ns1__CountryAbbr2ISO3166__ZA, "ZA" },
	{ (long)ns1__CountryAbbr2ISO3166__ZM, "ZM" },
	{ (long)ns1__CountryAbbr2ISO3166__ZW, "ZW" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__CountryAbbr2ISO31662s(struct soap *soap, enum ns1__CountryAbbr2ISO3166 n)
{	const char *s = soap_code_str(soap_codes_ns1__CountryAbbr2ISO3166, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CountryAbbr2ISO3166(struct soap *soap, const char *tag, int id, const enum ns1__CountryAbbr2ISO3166 *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CountryAbbr2ISO3166), type) || soap_send(soap, soap_ns1__CountryAbbr2ISO31662s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__CountryAbbr2ISO3166(struct soap *soap, const char *s, enum ns1__CountryAbbr2ISO3166 *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__CountryAbbr2ISO3166, s);
	if (map)
		*a = (enum ns1__CountryAbbr2ISO3166)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 217)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__CountryAbbr2ISO3166)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__CountryAbbr2ISO3166 * SOAP_FMAC4 soap_in_ns1__CountryAbbr2ISO3166(struct soap *soap, const char *tag, enum ns1__CountryAbbr2ISO3166 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__CountryAbbr2ISO3166 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CountryAbbr2ISO3166, sizeof(enum ns1__CountryAbbr2ISO3166), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__CountryAbbr2ISO3166(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__CountryAbbr2ISO3166 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CountryAbbr2ISO3166, 0, sizeof(enum ns1__CountryAbbr2ISO3166), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CountryAbbr2ISO3166(struct soap *soap, const enum ns1__CountryAbbr2ISO3166 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__CountryAbbr2ISO3166);
	if (soap_out_ns1__CountryAbbr2ISO3166(soap, tag?tag:"ns1:CountryAbbr2ISO3166", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__CountryAbbr2ISO3166 * SOAP_FMAC4 soap_get_ns1__CountryAbbr2ISO3166(struct soap *soap, enum ns1__CountryAbbr2ISO3166 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CountryAbbr2ISO3166(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__NoticeClassification(struct soap *soap, enum ns1__NoticeClassification *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__NoticeClassification
	*a = SOAP_DEFAULT_ns1__NoticeClassification;
#else
	*a = (enum ns1__NoticeClassification)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__NoticeClassification[] =
{	{ (long)ns1__NoticeClassification__None, "None" },
	{ (long)ns1__NoticeClassification__Emergency, "Emergency" },
	{ (long)ns1__NoticeClassification__Warning, "Warning" },
	{ (long)ns1__NoticeClassification__Info, "Info" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__NoticeClassification2s(struct soap *soap, enum ns1__NoticeClassification n)
{	const char *s = soap_code_str(soap_codes_ns1__NoticeClassification, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NoticeClassification(struct soap *soap, const char *tag, int id, const enum ns1__NoticeClassification *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NoticeClassification), type) || soap_send(soap, soap_ns1__NoticeClassification2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__NoticeClassification(struct soap *soap, const char *s, enum ns1__NoticeClassification *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__NoticeClassification, s);
	if (map)
		*a = (enum ns1__NoticeClassification)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__NoticeClassification)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__NoticeClassification * SOAP_FMAC4 soap_in_ns1__NoticeClassification(struct soap *soap, const char *tag, enum ns1__NoticeClassification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__NoticeClassification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NoticeClassification, sizeof(enum ns1__NoticeClassification), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__NoticeClassification(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__NoticeClassification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NoticeClassification, 0, sizeof(enum ns1__NoticeClassification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__NoticeClassification(struct soap *soap, const enum ns1__NoticeClassification *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__NoticeClassification);
	if (soap_out_ns1__NoticeClassification(soap, tag?tag:"ns1:NoticeClassification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__NoticeClassification * SOAP_FMAC4 soap_get_ns1__NoticeClassification(struct soap *soap, enum ns1__NoticeClassification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NoticeClassification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__NoticeStatus(struct soap *soap, enum ns1__NoticeStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__NoticeStatus
	*a = SOAP_DEFAULT_ns1__NoticeStatus;
#else
	*a = (enum ns1__NoticeStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__NoticeStatus[] =
{	{ (long)ns1__NoticeStatus__Unread, "Unread" },
	{ (long)ns1__NoticeStatus__Read, "Read" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__NoticeStatus2s(struct soap *soap, enum ns1__NoticeStatus n)
{	const char *s = soap_code_str(soap_codes_ns1__NoticeStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NoticeStatus(struct soap *soap, const char *tag, int id, const enum ns1__NoticeStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NoticeStatus), type) || soap_send(soap, soap_ns1__NoticeStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__NoticeStatus(struct soap *soap, const char *s, enum ns1__NoticeStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__NoticeStatus, s);
	if (map)
		*a = (enum ns1__NoticeStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__NoticeStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__NoticeStatus * SOAP_FMAC4 soap_in_ns1__NoticeStatus(struct soap *soap, const char *tag, enum ns1__NoticeStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__NoticeStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NoticeStatus, sizeof(enum ns1__NoticeStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__NoticeStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__NoticeStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NoticeStatus, 0, sizeof(enum ns1__NoticeStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__NoticeStatus(struct soap *soap, const enum ns1__NoticeStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__NoticeStatus);
	if (soap_out_ns1__NoticeStatus(soap, tag?tag:"ns1:NoticeStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__NoticeStatus * SOAP_FMAC4 soap_get_ns1__NoticeStatus(struct soap *soap, enum ns1__NoticeStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NoticeStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__MCUOSType(struct soap *soap, enum ns1__MCUOSType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__MCUOSType
	*a = SOAP_DEFAULT_ns1__MCUOSType;
#else
	*a = (enum ns1__MCUOSType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__MCUOSType[] =
{	{ (long)ns1__MCUOSType__Other, "Other" },
	{ (long)ns1__MCUOSType__IOS, "IOS" },
	{ (long)ns1__MCUOSType__MacOS, "MacOS" },
	{ (long)ns1__MCUOSType__Android, "Android" },
	{ (long)ns1__MCUOSType__WP8, "WP8" },
	{ (long)ns1__MCUOSType__WIN7, "WIN7" },
	{ (long)ns1__MCUOSType__WIN8, "WIN8" },
	{ (long)ns1__MCUOSType__WINXP, "WINXP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__MCUOSType2s(struct soap *soap, enum ns1__MCUOSType n)
{	const char *s = soap_code_str(soap_codes_ns1__MCUOSType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MCUOSType(struct soap *soap, const char *tag, int id, const enum ns1__MCUOSType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MCUOSType), type) || soap_send(soap, soap_ns1__MCUOSType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__MCUOSType(struct soap *soap, const char *s, enum ns1__MCUOSType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__MCUOSType, s);
	if (map)
		*a = (enum ns1__MCUOSType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__MCUOSType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__MCUOSType * SOAP_FMAC4 soap_in_ns1__MCUOSType(struct soap *soap, const char *tag, enum ns1__MCUOSType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__MCUOSType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MCUOSType, sizeof(enum ns1__MCUOSType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__MCUOSType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__MCUOSType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MCUOSType, 0, sizeof(enum ns1__MCUOSType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MCUOSType(struct soap *soap, const enum ns1__MCUOSType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__MCUOSType);
	if (soap_out_ns1__MCUOSType(soap, tag?tag:"ns1:MCUOSType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__MCUOSType * SOAP_FMAC4 soap_get_ns1__MCUOSType(struct soap *soap, enum ns1__MCUOSType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MCUOSType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__MCUDevType(struct soap *soap, enum ns1__MCUDevType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__MCUDevType
	*a = SOAP_DEFAULT_ns1__MCUDevType;
#else
	*a = (enum ns1__MCUDevType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__MCUDevType[] =
{	{ (long)ns1__MCUDevType__Other, "Other" },
	{ (long)ns1__MCUDevType__CellPhone, "CellPhone" },
	{ (long)ns1__MCUDevType__Tablet, "Tablet" },
	{ (long)ns1__MCUDevType__PC, "PC" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__MCUDevType2s(struct soap *soap, enum ns1__MCUDevType n)
{	const char *s = soap_code_str(soap_codes_ns1__MCUDevType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MCUDevType(struct soap *soap, const char *tag, int id, const enum ns1__MCUDevType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MCUDevType), type) || soap_send(soap, soap_ns1__MCUDevType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__MCUDevType(struct soap *soap, const char *s, enum ns1__MCUDevType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__MCUDevType, s);
	if (map)
		*a = (enum ns1__MCUDevType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__MCUDevType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__MCUDevType * SOAP_FMAC4 soap_in_ns1__MCUDevType(struct soap *soap, const char *tag, enum ns1__MCUDevType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__MCUDevType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MCUDevType, sizeof(enum ns1__MCUDevType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__MCUDevType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__MCUDevType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MCUDevType, 0, sizeof(enum ns1__MCUDevType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MCUDevType(struct soap *soap, const enum ns1__MCUDevType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__MCUDevType);
	if (soap_out_ns1__MCUDevType(soap, tag?tag:"ns1:MCUDevType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__MCUDevType * SOAP_FMAC4 soap_get_ns1__MCUDevType(struct soap *soap, enum ns1__MCUDevType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MCUDevType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__NetType(struct soap *soap, enum ns1__NetType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__NetType
	*a = SOAP_DEFAULT_ns1__NetType;
#else
	*a = (enum ns1__NetType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__NetType[] =
{	{ (long)ns1__NetType__Other, "Other" },
	{ (long)ns1__NetType__WiFi, "WiFi" },
	{ (long)ns1__NetType__ThreeG, "ThreeG" },
	{ (long)ns1__NetType__FourG, "FourG" },
	{ (long)ns1__NetType__Wire, "Wire" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__NetType2s(struct soap *soap, enum ns1__NetType n)
{	const char *s = soap_code_str(soap_codes_ns1__NetType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NetType(struct soap *soap, const char *tag, int id, const enum ns1__NetType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NetType), type) || soap_send(soap, soap_ns1__NetType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__NetType(struct soap *soap, const char *s, enum ns1__NetType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__NetType, s);
	if (map)
		*a = (enum ns1__NetType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__NetType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__NetType * SOAP_FMAC4 soap_in_ns1__NetType(struct soap *soap, const char *tag, enum ns1__NetType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__NetType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NetType, sizeof(enum ns1__NetType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__NetType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__NetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NetType, 0, sizeof(enum ns1__NetType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__NetType(struct soap *soap, const enum ns1__NetType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__NetType);
	if (soap_out_ns1__NetType(soap, tag?tag:"ns1:NetType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__NetType * SOAP_FMAC4 soap_get_ns1__NetType(struct soap *soap, enum ns1__NetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__NetworkOperator(struct soap *soap, enum ns1__NetworkOperator *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__NetworkOperator
	*a = SOAP_DEFAULT_ns1__NetworkOperator;
#else
	*a = (enum ns1__NetworkOperator)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__NetworkOperator[] =
{	{ (long)ns1__NetworkOperator__Other, "Other" },
	{ (long)ns1__NetworkOperator__China_x0020Telecom, "China Telecom" },
	{ (long)ns1__NetworkOperator__China_x0020Netcom, "China Netcom" },
	{ (long)ns1__NetworkOperator__China_x0020Unicom, "China Unicom" },
	{ (long)ns1__NetworkOperator__China_x0020Mobile, "China Mobile" },
	{ (long)ns1__NetworkOperator__ATT, "ATT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__NetworkOperator2s(struct soap *soap, enum ns1__NetworkOperator n)
{	const char *s = soap_code_str(soap_codes_ns1__NetworkOperator, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NetworkOperator(struct soap *soap, const char *tag, int id, const enum ns1__NetworkOperator *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NetworkOperator), type) || soap_send(soap, soap_ns1__NetworkOperator2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__NetworkOperator(struct soap *soap, const char *s, enum ns1__NetworkOperator *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__NetworkOperator, s);
	if (map)
		*a = (enum ns1__NetworkOperator)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__NetworkOperator)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__NetworkOperator * SOAP_FMAC4 soap_in_ns1__NetworkOperator(struct soap *soap, const char *tag, enum ns1__NetworkOperator *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__NetworkOperator *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NetworkOperator, sizeof(enum ns1__NetworkOperator), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__NetworkOperator(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__NetworkOperator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NetworkOperator, 0, sizeof(enum ns1__NetworkOperator), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__NetworkOperator(struct soap *soap, const enum ns1__NetworkOperator *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__NetworkOperator);
	if (soap_out_ns1__NetworkOperator(soap, tag?tag:"ns1:NetworkOperator", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__NetworkOperator * SOAP_FMAC4 soap_get_ns1__NetworkOperator(struct soap *soap, enum ns1__NetworkOperator *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NetworkOperator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__WirelessType(struct soap *soap, enum ns1__WirelessType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__WirelessType
	*a = SOAP_DEFAULT_ns1__WirelessType;
#else
	*a = (enum ns1__WirelessType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__WirelessType[] =
{	{ (long)ns1__WirelessType__WIFI, "WIFI" },
	{ (long)ns1__WirelessType__ThreeG, "ThreeG" },
	{ (long)ns1__WirelessType__FourG, "FourG" },
	{ (long)ns1__WirelessType__LIFI, "LIFI" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__WirelessType2s(struct soap *soap, enum ns1__WirelessType n)
{	const char *s = soap_code_str(soap_codes_ns1__WirelessType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WirelessType(struct soap *soap, const char *tag, int id, const enum ns1__WirelessType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WirelessType), type) || soap_send(soap, soap_ns1__WirelessType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__WirelessType(struct soap *soap, const char *s, enum ns1__WirelessType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__WirelessType, s);
	if (map)
		*a = (enum ns1__WirelessType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__WirelessType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__WirelessType * SOAP_FMAC4 soap_in_ns1__WirelessType(struct soap *soap, const char *tag, enum ns1__WirelessType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__WirelessType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WirelessType, sizeof(enum ns1__WirelessType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__WirelessType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__WirelessType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__WirelessType, 0, sizeof(enum ns1__WirelessType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__WirelessType(struct soap *soap, const enum ns1__WirelessType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__WirelessType);
	if (soap_out_ns1__WirelessType(soap, tag?tag:"ns1:WirelessType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__WirelessType * SOAP_FMAC4 soap_get_ns1__WirelessType(struct soap *soap, enum ns1__WirelessType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WirelessType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__RelayState(struct soap *soap, enum ns1__RelayState *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__RelayState
	*a = SOAP_DEFAULT_ns1__RelayState;
#else
	*a = (enum ns1__RelayState)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__RelayState[] =
{	{ (long)ns1__RelayState__Inactive, "Inactive" },
	{ (long)ns1__RelayState__Active, "Active" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__RelayState2s(struct soap *soap, enum ns1__RelayState n)
{	const char *s = soap_code_str(soap_codes_ns1__RelayState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RelayState(struct soap *soap, const char *tag, int id, const enum ns1__RelayState *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RelayState), type) || soap_send(soap, soap_ns1__RelayState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__RelayState(struct soap *soap, const char *s, enum ns1__RelayState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__RelayState, s);
	if (map)
		*a = (enum ns1__RelayState)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__RelayState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__RelayState * SOAP_FMAC4 soap_in_ns1__RelayState(struct soap *soap, const char *tag, enum ns1__RelayState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__RelayState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RelayState, sizeof(enum ns1__RelayState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__RelayState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__RelayState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RelayState, 0, sizeof(enum ns1__RelayState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__RelayState(struct soap *soap, const enum ns1__RelayState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__RelayState);
	if (soap_out_ns1__RelayState(soap, tag?tag:"ns1:RelayState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__RelayState * SOAP_FMAC4 soap_get_ns1__RelayState(struct soap *soap, enum ns1__RelayState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RelayState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__MCUResult(struct soap *soap, enum ns1__MCUResult *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__MCUResult
	*a = SOAP_DEFAULT_ns1__MCUResult;
#else
	*a = (enum ns1__MCUResult)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__MCUResult[] =
{	{ (long)ns1__MCUResult__OK, "OK" },
	{ (long)ns1__MCUResult__AccountNotExist, "AccountNotExist" },
	{ (long)ns1__MCUResult__SessionExpired, "SessionExpired" },
	{ (long)ns1__MCUResult__DeviceNotExist, "DeviceNotExist" },
	{ (long)ns1__MCUResult__AccountExist, "AccountExist" },
	{ (long)ns1__MCUResult__EmailExist, "EmailExist" },
	{ (long)ns1__MCUResult__AccountFormat, "AccountFormat" },
	{ (long)ns1__MCUResult__EmailFormat, "EmailFormat" },
	{ (long)ns1__MCUResult__PasswordFormat, "PasswordFormat" },
	{ (long)ns1__MCUResult__NicknameFormat, "NicknameFormat" },
	{ (long)ns1__MCUResult__MobileTelFormat, "MobileTelFormat" },
	{ (long)ns1__MCUResult__Authencation, "Authencation" },
	{ (long)ns1__MCUResult__MobileTelExist, "MobileTelExist" },
	{ (long)ns1__MCUResult__MCUVersion, "MCUVersion" },
	{ (long)ns1__MCUResult__DeviceAuthencation, "DeviceAuthencation" },
	{ (long)ns1__MCUResult__DeviceOffline, "DeviceOffline" },
	{ (long)ns1__MCUResult__ParamIllegal, "ParamIllegal" },
	{ (long)ns1__MCUResult__HashTokenIllegal, "HashTokenIllegal" },
	{ (long)ns1__MCUResult__ServiceBusy, "ServiceBusy" },
	{ (long)ns1__MCUResult__NotSupport, "NotSupport" },
	{ (long)ns1__MCUResult__DeviceBusy, "DeviceBusy" },
	{ (long)ns1__MCUResult__EmailSend, "EmailSend" },
	{ (long)ns1__MCUResult__SMSSend, "SMSSend" },
	{ (long)ns1__MCUResult__AccessDenied, "AccessDenied" },
	{ (long)ns1__MCUResult__DeviceSessionExpired, "DeviceSessionExpired" },
	{ (long)ns1__MCUResult__NotAllowSession, "NotAllowSession" },
	{ (long)ns1__MCUResult__DeviceError, "DeviceError" },
	{ (long)ns1__MCUResult__MobileTelNotExist, "MobileTelNotExist" },
	{ (long)ns1__MCUResult__NoRecord, "NoRecord" },
	{ (long)ns1__MCUResult__DeviceBonded, "DeviceBonded" },
	{ (long)ns1__MCUResult__AlreadySucceed, "AlreadySucceed" },
	{ (long)ns1__MCUResult__TypeIllegal, "TypeIllegal" },
	{ (long)ns1__MCUResult__AlreadyShared, "AlreadyShared" },
	{ (long)ns1__MCUResult__NoPriority, "NoPriority" },
	{ (long)ns1__MCUResult__ReachedLimit, "ReachedLimit" },
	{ (long)ns1__MCUResult__NonMonitor, "NonMonitor" },
	{ (long)ns1__MCUResult__Matching, "Matching" },
	{ (long)ns1__MCUResult__MatchingExpired, "MatchingExpired" },
	{ (long)ns1__MCUResult__ServiceInternal, "ServiceInternal" },
	{ (long)ns1__MCUResult__NetworkOperatorNotSupported, "NetworkOperatorNotSupported" },
	{ (long)ns1__MCUResult__TrustedAuthorityAuthencation, "TrustedAuthorityAuthencation" },
	{ (long)ns1__MCUResult__UnKnow, "UnKnow" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__MCUResult2s(struct soap *soap, enum ns1__MCUResult n)
{	const char *s = soap_code_str(soap_codes_ns1__MCUResult, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MCUResult(struct soap *soap, const char *tag, int id, const enum ns1__MCUResult *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MCUResult), type) || soap_send(soap, soap_ns1__MCUResult2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__MCUResult(struct soap *soap, const char *s, enum ns1__MCUResult *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__MCUResult, s);
	if (map)
		*a = (enum ns1__MCUResult)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 41)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__MCUResult)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__MCUResult * SOAP_FMAC4 soap_in_ns1__MCUResult(struct soap *soap, const char *tag, enum ns1__MCUResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__MCUResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MCUResult, sizeof(enum ns1__MCUResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__MCUResult(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__MCUResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MCUResult, 0, sizeof(enum ns1__MCUResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MCUResult(struct soap *soap, const enum ns1__MCUResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__MCUResult);
	if (soap_out_ns1__MCUResult(soap, tag?tag:"ns1:MCUResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__MCUResult * SOAP_FMAC4 soap_get_ns1__MCUResult(struct soap *soap, enum ns1__MCUResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MCUResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)xsd__boolean__false_, "false" },
	{ (long)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_xsd__boolean, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__vodSearch(struct soap *soap, struct __ns1__vodSearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__vodSearchReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__vodSearch(struct soap *soap, const struct __ns1__vodSearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__vodSearchReq(soap, &a->ns1__vodSearchReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__vodSearch(struct soap *soap, const char *tag, int id, const struct __ns1__vodSearch *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__vodSearchReq(soap, "ns1:vodSearchReq", -1, &a->ns1__vodSearchReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__vodSearch * SOAP_FMAC4 soap_in___ns1__vodSearch(struct soap *soap, const char *tag, struct __ns1__vodSearch *a, const char *type)
{
	size_t soap_flag_ns1__vodSearchReq = 1;
	short soap_flag;
	a = (struct __ns1__vodSearch *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__vodSearch, sizeof(struct __ns1__vodSearch), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__vodSearch(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__vodSearchReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__vodSearchReq(soap, "ns1:vodSearchReq", &a->ns1__vodSearchReq, ""))
				{	soap_flag_ns1__vodSearchReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__vodSearch(struct soap *soap, const struct __ns1__vodSearch *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__vodSearch(soap, tag?tag:"-ns1:vodSearch", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__vodSearch * SOAP_FMAC4 soap_get___ns1__vodSearch(struct soap *soap, struct __ns1__vodSearch *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__vodSearch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getVODUrl(struct soap *soap, struct __ns1__getVODUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getVODUrlReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getVODUrl(struct soap *soap, const struct __ns1__getVODUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getVODUrlReq(soap, &a->ns1__getVODUrlReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getVODUrl(struct soap *soap, const char *tag, int id, const struct __ns1__getVODUrl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getVODUrlReq(soap, "ns1:getVODUrlReq", -1, &a->ns1__getVODUrlReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVODUrl * SOAP_FMAC4 soap_in___ns1__getVODUrl(struct soap *soap, const char *tag, struct __ns1__getVODUrl *a, const char *type)
{
	size_t soap_flag_ns1__getVODUrlReq = 1;
	short soap_flag;
	a = (struct __ns1__getVODUrl *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getVODUrl, sizeof(struct __ns1__getVODUrl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getVODUrl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getVODUrlReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getVODUrlReq(soap, "ns1:getVODUrlReq", &a->ns1__getVODUrlReq, ""))
				{	soap_flag_ns1__getVODUrlReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getVODUrl(struct soap *soap, const struct __ns1__getVODUrl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getVODUrl(soap, tag?tag:"-ns1:getVODUrl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVODUrl * SOAP_FMAC4 soap_get___ns1__getVODUrl(struct soap *soap, struct __ns1__getVODUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getVODUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPlayUrl(struct soap *soap, struct __ns1__getPlayUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPlayUrlReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPlayUrl(struct soap *soap, const struct __ns1__getPlayUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getPlayUrlReq(soap, &a->ns1__getPlayUrlReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPlayUrl(struct soap *soap, const char *tag, int id, const struct __ns1__getPlayUrl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getPlayUrlReq(soap, "ns1:getPlayUrlReq", -1, &a->ns1__getPlayUrlReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPlayUrl * SOAP_FMAC4 soap_in___ns1__getPlayUrl(struct soap *soap, const char *tag, struct __ns1__getPlayUrl *a, const char *type)
{
	size_t soap_flag_ns1__getPlayUrlReq = 1;
	short soap_flag;
	a = (struct __ns1__getPlayUrl *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPlayUrl, sizeof(struct __ns1__getPlayUrl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPlayUrl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPlayUrlReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getPlayUrlReq(soap, "ns1:getPlayUrlReq", &a->ns1__getPlayUrlReq, ""))
				{	soap_flag_ns1__getPlayUrlReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPlayUrl(struct soap *soap, const struct __ns1__getPlayUrl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPlayUrl(soap, tag?tag:"-ns1:getPlayUrl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPlayUrl * SOAP_FMAC4 soap_get___ns1__getPlayUrl(struct soap *soap, struct __ns1__getPlayUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPlayUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setPrivacyMaskParam(struct soap *soap, struct __ns1__setPrivacyMaskParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setPrivacyMaskParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setPrivacyMaskParam(struct soap *soap, const struct __ns1__setPrivacyMaskParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setPrivacyMaskParamReq(soap, &a->ns1__setPrivacyMaskParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setPrivacyMaskParam(struct soap *soap, const char *tag, int id, const struct __ns1__setPrivacyMaskParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setPrivacyMaskParamReq(soap, "ns1:setPrivacyMaskParamReq", -1, &a->ns1__setPrivacyMaskParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPrivacyMaskParam * SOAP_FMAC4 soap_in___ns1__setPrivacyMaskParam(struct soap *soap, const char *tag, struct __ns1__setPrivacyMaskParam *a, const char *type)
{
	size_t soap_flag_ns1__setPrivacyMaskParamReq = 1;
	short soap_flag;
	a = (struct __ns1__setPrivacyMaskParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setPrivacyMaskParam, sizeof(struct __ns1__setPrivacyMaskParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setPrivacyMaskParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setPrivacyMaskParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setPrivacyMaskParamReq(soap, "ns1:setPrivacyMaskParamReq", &a->ns1__setPrivacyMaskParamReq, ""))
				{	soap_flag_ns1__setPrivacyMaskParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setPrivacyMaskParam(struct soap *soap, const struct __ns1__setPrivacyMaskParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setPrivacyMaskParam(soap, tag?tag:"-ns1:setPrivacyMaskParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPrivacyMaskParam * SOAP_FMAC4 soap_get___ns1__setPrivacyMaskParam(struct soap *soap, struct __ns1__setPrivacyMaskParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setPrivacyMaskParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPrivacyMaskParam(struct soap *soap, struct __ns1__getPrivacyMaskParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPrivacyMaskParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPrivacyMaskParam(struct soap *soap, const struct __ns1__getPrivacyMaskParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getPrivacyMaskParamReq(soap, &a->ns1__getPrivacyMaskParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPrivacyMaskParam(struct soap *soap, const char *tag, int id, const struct __ns1__getPrivacyMaskParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getPrivacyMaskParamReq(soap, "ns1:getPrivacyMaskParamReq", -1, &a->ns1__getPrivacyMaskParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPrivacyMaskParam * SOAP_FMAC4 soap_in___ns1__getPrivacyMaskParam(struct soap *soap, const char *tag, struct __ns1__getPrivacyMaskParam *a, const char *type)
{
	size_t soap_flag_ns1__getPrivacyMaskParamReq = 1;
	short soap_flag;
	a = (struct __ns1__getPrivacyMaskParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPrivacyMaskParam, sizeof(struct __ns1__getPrivacyMaskParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPrivacyMaskParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPrivacyMaskParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getPrivacyMaskParamReq(soap, "ns1:getPrivacyMaskParamReq", &a->ns1__getPrivacyMaskParamReq, ""))
				{	soap_flag_ns1__getPrivacyMaskParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPrivacyMaskParam(struct soap *soap, const struct __ns1__getPrivacyMaskParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPrivacyMaskParam(soap, tag?tag:"-ns1:getPrivacyMaskParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPrivacyMaskParam * SOAP_FMAC4 soap_get___ns1__getPrivacyMaskParam(struct soap *soap, struct __ns1__getPrivacyMaskParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPrivacyMaskParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setVMDParam(struct soap *soap, struct __ns1__setVMDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setVMDParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setVMDParam(struct soap *soap, const struct __ns1__setVMDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setVMDParamReq(soap, &a->ns1__setVMDParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setVMDParam(struct soap *soap, const char *tag, int id, const struct __ns1__setVMDParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setVMDParamReq(soap, "ns1:setVMDParamReq", -1, &a->ns1__setVMDParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setVMDParam * SOAP_FMAC4 soap_in___ns1__setVMDParam(struct soap *soap, const char *tag, struct __ns1__setVMDParam *a, const char *type)
{
	size_t soap_flag_ns1__setVMDParamReq = 1;
	short soap_flag;
	a = (struct __ns1__setVMDParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setVMDParam, sizeof(struct __ns1__setVMDParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setVMDParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setVMDParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setVMDParamReq(soap, "ns1:setVMDParamReq", &a->ns1__setVMDParamReq, ""))
				{	soap_flag_ns1__setVMDParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setVMDParam(struct soap *soap, const struct __ns1__setVMDParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setVMDParam(soap, tag?tag:"-ns1:setVMDParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setVMDParam * SOAP_FMAC4 soap_get___ns1__setVMDParam(struct soap *soap, struct __ns1__setVMDParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setVMDParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getVMDParam(struct soap *soap, struct __ns1__getVMDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getVMDParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getVMDParam(struct soap *soap, const struct __ns1__getVMDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getVMDParamReq(soap, &a->ns1__getVMDParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getVMDParam(struct soap *soap, const char *tag, int id, const struct __ns1__getVMDParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getVMDParamReq(soap, "ns1:getVMDParamReq", -1, &a->ns1__getVMDParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVMDParam * SOAP_FMAC4 soap_in___ns1__getVMDParam(struct soap *soap, const char *tag, struct __ns1__getVMDParam *a, const char *type)
{
	size_t soap_flag_ns1__getVMDParamReq = 1;
	short soap_flag;
	a = (struct __ns1__getVMDParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getVMDParam, sizeof(struct __ns1__getVMDParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getVMDParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getVMDParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getVMDParamReq(soap, "ns1:getVMDParamReq", &a->ns1__getVMDParamReq, ""))
				{	soap_flag_ns1__getVMDParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getVMDParam(struct soap *soap, const struct __ns1__getVMDParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getVMDParam(soap, tag?tag:"-ns1:getVMDParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVMDParam * SOAP_FMAC4 soap_get___ns1__getVMDParam(struct soap *soap, struct __ns1__getVMDParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getVMDParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setTime(struct soap *soap, struct __ns1__setTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setTimeReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setTime(struct soap *soap, const struct __ns1__setTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setTimeReq(soap, &a->ns1__setTimeReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setTime(struct soap *soap, const char *tag, int id, const struct __ns1__setTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setTimeReq(soap, "ns1:setTimeReq", -1, &a->ns1__setTimeReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTime * SOAP_FMAC4 soap_in___ns1__setTime(struct soap *soap, const char *tag, struct __ns1__setTime *a, const char *type)
{
	size_t soap_flag_ns1__setTimeReq = 1;
	short soap_flag;
	a = (struct __ns1__setTime *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setTime, sizeof(struct __ns1__setTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setTimeReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setTimeReq(soap, "ns1:setTimeReq", &a->ns1__setTimeReq, ""))
				{	soap_flag_ns1__setTimeReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setTime(struct soap *soap, const struct __ns1__setTime *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setTime(soap, tag?tag:"-ns1:setTime", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTime * SOAP_FMAC4 soap_get___ns1__setTime(struct soap *soap, struct __ns1__setTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTime(struct soap *soap, struct __ns1__getTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTimeReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTime(struct soap *soap, const struct __ns1__getTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getTimeReq(soap, &a->ns1__getTimeReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTime(struct soap *soap, const char *tag, int id, const struct __ns1__getTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getTimeReq(soap, "ns1:getTimeReq", -1, &a->ns1__getTimeReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTime * SOAP_FMAC4 soap_in___ns1__getTime(struct soap *soap, const char *tag, struct __ns1__getTime *a, const char *type)
{
	size_t soap_flag_ns1__getTimeReq = 1;
	short soap_flag;
	a = (struct __ns1__getTime *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTime, sizeof(struct __ns1__getTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTimeReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getTimeReq(soap, "ns1:getTimeReq", &a->ns1__getTimeReq, ""))
				{	soap_flag_ns1__getTimeReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTime(struct soap *soap, const struct __ns1__getTime *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTime(soap, tag?tag:"-ns1:getTime", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTime * SOAP_FMAC4 soap_get___ns1__getTime(struct soap *soap, struct __ns1__getTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setOSDParam(struct soap *soap, struct __ns1__setOSDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setOSDParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setOSDParam(struct soap *soap, const struct __ns1__setOSDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setOSDParamReq(soap, &a->ns1__setOSDParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setOSDParam(struct soap *soap, const char *tag, int id, const struct __ns1__setOSDParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setOSDParamReq(soap, "ns1:setOSDParamReq", -1, &a->ns1__setOSDParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setOSDParam * SOAP_FMAC4 soap_in___ns1__setOSDParam(struct soap *soap, const char *tag, struct __ns1__setOSDParam *a, const char *type)
{
	size_t soap_flag_ns1__setOSDParamReq = 1;
	short soap_flag;
	a = (struct __ns1__setOSDParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setOSDParam, sizeof(struct __ns1__setOSDParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setOSDParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setOSDParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setOSDParamReq(soap, "ns1:setOSDParamReq", &a->ns1__setOSDParamReq, ""))
				{	soap_flag_ns1__setOSDParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setOSDParam(struct soap *soap, const struct __ns1__setOSDParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setOSDParam(soap, tag?tag:"-ns1:setOSDParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setOSDParam * SOAP_FMAC4 soap_get___ns1__setOSDParam(struct soap *soap, struct __ns1__setOSDParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setOSDParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getOSDParam(struct soap *soap, struct __ns1__getOSDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getOSDParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getOSDParam(struct soap *soap, const struct __ns1__getOSDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getOSDParamReq(soap, &a->ns1__getOSDParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getOSDParam(struct soap *soap, const char *tag, int id, const struct __ns1__getOSDParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getOSDParamReq(soap, "ns1:getOSDParamReq", -1, &a->ns1__getOSDParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOSDParam * SOAP_FMAC4 soap_in___ns1__getOSDParam(struct soap *soap, const char *tag, struct __ns1__getOSDParam *a, const char *type)
{
	size_t soap_flag_ns1__getOSDParamReq = 1;
	short soap_flag;
	a = (struct __ns1__getOSDParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getOSDParam, sizeof(struct __ns1__getOSDParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getOSDParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getOSDParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getOSDParamReq(soap, "ns1:getOSDParamReq", &a->ns1__getOSDParamReq, ""))
				{	soap_flag_ns1__getOSDParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getOSDParam(struct soap *soap, const struct __ns1__getOSDParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getOSDParam(soap, tag?tag:"-ns1:getOSDParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOSDParam * SOAP_FMAC4 soap_get___ns1__getOSDParam(struct soap *soap, struct __ns1__getOSDParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getOSDParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setVideoParam(struct soap *soap, struct __ns1__setVideoParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setVideoParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setVideoParam(struct soap *soap, const struct __ns1__setVideoParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setVideoParamReq(soap, &a->ns1__setVideoParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setVideoParam(struct soap *soap, const char *tag, int id, const struct __ns1__setVideoParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setVideoParamReq(soap, "ns1:setVideoParamReq", -1, &a->ns1__setVideoParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setVideoParam * SOAP_FMAC4 soap_in___ns1__setVideoParam(struct soap *soap, const char *tag, struct __ns1__setVideoParam *a, const char *type)
{
	size_t soap_flag_ns1__setVideoParamReq = 1;
	short soap_flag;
	a = (struct __ns1__setVideoParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setVideoParam, sizeof(struct __ns1__setVideoParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setVideoParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setVideoParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setVideoParamReq(soap, "ns1:setVideoParamReq", &a->ns1__setVideoParamReq, ""))
				{	soap_flag_ns1__setVideoParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setVideoParam(struct soap *soap, const struct __ns1__setVideoParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setVideoParam(soap, tag?tag:"-ns1:setVideoParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setVideoParam * SOAP_FMAC4 soap_get___ns1__setVideoParam(struct soap *soap, struct __ns1__setVideoParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setVideoParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getVideoParam(struct soap *soap, struct __ns1__getVideoParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getVideoParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getVideoParam(struct soap *soap, const struct __ns1__getVideoParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getVideoParamReq(soap, &a->ns1__getVideoParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getVideoParam(struct soap *soap, const char *tag, int id, const struct __ns1__getVideoParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getVideoParamReq(soap, "ns1:getVideoParamReq", -1, &a->ns1__getVideoParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVideoParam * SOAP_FMAC4 soap_in___ns1__getVideoParam(struct soap *soap, const char *tag, struct __ns1__getVideoParam *a, const char *type)
{
	size_t soap_flag_ns1__getVideoParamReq = 1;
	short soap_flag;
	a = (struct __ns1__getVideoParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getVideoParam, sizeof(struct __ns1__getVideoParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getVideoParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getVideoParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getVideoParamReq(soap, "ns1:getVideoParamReq", &a->ns1__getVideoParamReq, ""))
				{	soap_flag_ns1__getVideoParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getVideoParam(struct soap *soap, const struct __ns1__getVideoParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getVideoParam(soap, tag?tag:"-ns1:getVideoParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVideoParam * SOAP_FMAC4 soap_get___ns1__getVideoParam(struct soap *soap, struct __ns1__getVideoParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getVideoParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryDevLog(struct soap *soap, struct __ns1__queryDevLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryDevLogReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryDevLog(struct soap *soap, const struct __ns1__queryDevLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryDevLogReq(soap, &a->ns1__queryDevLogReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryDevLog(struct soap *soap, const char *tag, int id, const struct __ns1__queryDevLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryDevLogReq(soap, "ns1:queryDevLogReq", -1, &a->ns1__queryDevLogReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDevLog * SOAP_FMAC4 soap_in___ns1__queryDevLog(struct soap *soap, const char *tag, struct __ns1__queryDevLog *a, const char *type)
{
	size_t soap_flag_ns1__queryDevLogReq = 1;
	short soap_flag;
	a = (struct __ns1__queryDevLog *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryDevLog, sizeof(struct __ns1__queryDevLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryDevLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryDevLogReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryDevLogReq(soap, "ns1:queryDevLogReq", &a->ns1__queryDevLogReq, ""))
				{	soap_flag_ns1__queryDevLogReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryDevLog(struct soap *soap, const struct __ns1__queryDevLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryDevLog(soap, tag?tag:"-ns1:queryDevLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDevLog * SOAP_FMAC4 soap_get___ns1__queryDevLog(struct soap *soap, struct __ns1__queryDevLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryDevLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryLog(struct soap *soap, struct __ns1__queryLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryLogReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryLog(struct soap *soap, const struct __ns1__queryLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryLogReq(soap, &a->ns1__queryLogReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryLog(struct soap *soap, const char *tag, int id, const struct __ns1__queryLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryLogReq(soap, "ns1:queryLogReq", -1, &a->ns1__queryLogReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryLog * SOAP_FMAC4 soap_in___ns1__queryLog(struct soap *soap, const char *tag, struct __ns1__queryLog *a, const char *type)
{
	size_t soap_flag_ns1__queryLogReq = 1;
	short soap_flag;
	a = (struct __ns1__queryLog *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryLog, sizeof(struct __ns1__queryLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryLogReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryLogReq(soap, "ns1:queryLogReq", &a->ns1__queryLogReq, ""))
				{	soap_flag_ns1__queryLogReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryLog(struct soap *soap, const struct __ns1__queryLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryLog(soap, tag?tag:"-ns1:queryLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryLog * SOAP_FMAC4 soap_get___ns1__queryLog(struct soap *soap, struct __ns1__queryLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__upgradeDevVer(struct soap *soap, struct __ns1__upgradeDevVer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__upgradeDevVerReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__upgradeDevVer(struct soap *soap, const struct __ns1__upgradeDevVer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__upgradeDevVerReq(soap, &a->ns1__upgradeDevVerReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__upgradeDevVer(struct soap *soap, const char *tag, int id, const struct __ns1__upgradeDevVer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__upgradeDevVerReq(soap, "ns1:upgradeDevVerReq", -1, &a->ns1__upgradeDevVerReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__upgradeDevVer * SOAP_FMAC4 soap_in___ns1__upgradeDevVer(struct soap *soap, const char *tag, struct __ns1__upgradeDevVer *a, const char *type)
{
	size_t soap_flag_ns1__upgradeDevVerReq = 1;
	short soap_flag;
	a = (struct __ns1__upgradeDevVer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__upgradeDevVer, sizeof(struct __ns1__upgradeDevVer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__upgradeDevVer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__upgradeDevVerReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__upgradeDevVerReq(soap, "ns1:upgradeDevVerReq", &a->ns1__upgradeDevVerReq, ""))
				{	soap_flag_ns1__upgradeDevVerReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__upgradeDevVer(struct soap *soap, const struct __ns1__upgradeDevVer *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__upgradeDevVer(soap, tag?tag:"-ns1:upgradeDevVer", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__upgradeDevVer * SOAP_FMAC4 soap_get___ns1__upgradeDevVer(struct soap *soap, struct __ns1__upgradeDevVer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__upgradeDevVer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDevVer(struct soap *soap, struct __ns1__getDevVer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDevVerReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDevVer(struct soap *soap, const struct __ns1__getDevVer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getDevVerReq(soap, &a->ns1__getDevVerReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDevVer(struct soap *soap, const char *tag, int id, const struct __ns1__getDevVer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getDevVerReq(soap, "ns1:getDevVerReq", -1, &a->ns1__getDevVerReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDevVer * SOAP_FMAC4 soap_in___ns1__getDevVer(struct soap *soap, const char *tag, struct __ns1__getDevVer *a, const char *type)
{
	size_t soap_flag_ns1__getDevVerReq = 1;
	short soap_flag;
	a = (struct __ns1__getDevVer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDevVer, sizeof(struct __ns1__getDevVer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDevVer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDevVerReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getDevVerReq(soap, "ns1:getDevVerReq", &a->ns1__getDevVerReq, ""))
				{	soap_flag_ns1__getDevVerReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDevVer(struct soap *soap, const struct __ns1__getDevVer *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDevVer(soap, tag?tag:"-ns1:getDevVer", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDevVer * SOAP_FMAC4 soap_get___ns1__getDevVer(struct soap *soap, struct __ns1__getDevVer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDevVer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__reboot(struct soap *soap, struct __ns1__reboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__rebootReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__reboot(struct soap *soap, const struct __ns1__reboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__rebootReq(soap, &a->ns1__rebootReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__reboot(struct soap *soap, const char *tag, int id, const struct __ns1__reboot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__rebootReq(soap, "ns1:rebootReq", -1, &a->ns1__rebootReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__reboot * SOAP_FMAC4 soap_in___ns1__reboot(struct soap *soap, const char *tag, struct __ns1__reboot *a, const char *type)
{
	size_t soap_flag_ns1__rebootReq = 1;
	short soap_flag;
	a = (struct __ns1__reboot *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__reboot, sizeof(struct __ns1__reboot), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__reboot(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__rebootReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__rebootReq(soap, "ns1:rebootReq", &a->ns1__rebootReq, ""))
				{	soap_flag_ns1__rebootReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__reboot(struct soap *soap, const struct __ns1__reboot *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__reboot(soap, tag?tag:"-ns1:reboot", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__reboot * SOAP_FMAC4 soap_get___ns1__reboot(struct soap *soap, struct __ns1__reboot *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__reboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setCodingParam(struct soap *soap, struct __ns1__setCodingParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setCodingParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setCodingParam(struct soap *soap, const struct __ns1__setCodingParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setCodingParamReq(soap, &a->ns1__setCodingParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setCodingParam(struct soap *soap, const char *tag, int id, const struct __ns1__setCodingParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setCodingParamReq(soap, "ns1:setCodingParamReq", -1, &a->ns1__setCodingParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setCodingParam * SOAP_FMAC4 soap_in___ns1__setCodingParam(struct soap *soap, const char *tag, struct __ns1__setCodingParam *a, const char *type)
{
	size_t soap_flag_ns1__setCodingParamReq = 1;
	short soap_flag;
	a = (struct __ns1__setCodingParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setCodingParam, sizeof(struct __ns1__setCodingParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setCodingParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setCodingParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setCodingParamReq(soap, "ns1:setCodingParamReq", &a->ns1__setCodingParamReq, ""))
				{	soap_flag_ns1__setCodingParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setCodingParam(struct soap *soap, const struct __ns1__setCodingParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setCodingParam(soap, tag?tag:"-ns1:setCodingParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setCodingParam * SOAP_FMAC4 soap_get___ns1__setCodingParam(struct soap *soap, struct __ns1__setCodingParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setCodingParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCodingParam(struct soap *soap, struct __ns1__getCodingParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getCodingParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCodingParam(struct soap *soap, const struct __ns1__getCodingParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getCodingParamReq(soap, &a->ns1__getCodingParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCodingParam(struct soap *soap, const char *tag, int id, const struct __ns1__getCodingParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getCodingParamReq(soap, "ns1:getCodingParamReq", -1, &a->ns1__getCodingParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCodingParam * SOAP_FMAC4 soap_in___ns1__getCodingParam(struct soap *soap, const char *tag, struct __ns1__getCodingParam *a, const char *type)
{
	size_t soap_flag_ns1__getCodingParamReq = 1;
	short soap_flag;
	a = (struct __ns1__getCodingParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCodingParam, sizeof(struct __ns1__getCodingParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCodingParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getCodingParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getCodingParamReq(soap, "ns1:getCodingParamReq", &a->ns1__getCodingParamReq, ""))
				{	soap_flag_ns1__getCodingParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCodingParam(struct soap *soap, const struct __ns1__getCodingParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getCodingParam(soap, tag?tag:"-ns1:getCodingParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCodingParam * SOAP_FMAC4 soap_get___ns1__getCodingParam(struct soap *soap, struct __ns1__getCodingParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCodingParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__presetControl(struct soap *soap, struct __ns1__presetControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__presetControlReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__presetControl(struct soap *soap, const struct __ns1__presetControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__presetControlReq(soap, &a->ns1__presetControlReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__presetControl(struct soap *soap, const char *tag, int id, const struct __ns1__presetControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__presetControlReq(soap, "ns1:presetControlReq", -1, &a->ns1__presetControlReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__presetControl * SOAP_FMAC4 soap_in___ns1__presetControl(struct soap *soap, const char *tag, struct __ns1__presetControl *a, const char *type)
{
	size_t soap_flag_ns1__presetControlReq = 1;
	short soap_flag;
	a = (struct __ns1__presetControl *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__presetControl, sizeof(struct __ns1__presetControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__presetControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__presetControlReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__presetControlReq(soap, "ns1:presetControlReq", &a->ns1__presetControlReq, ""))
				{	soap_flag_ns1__presetControlReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__presetControl(struct soap *soap, const struct __ns1__presetControl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__presetControl(soap, tag?tag:"-ns1:presetControl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__presetControl * SOAP_FMAC4 soap_get___ns1__presetControl(struct soap *soap, struct __ns1__presetControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__presetControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lensControl(struct soap *soap, struct __ns1__lensControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__lensControlReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lensControl(struct soap *soap, const struct __ns1__lensControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__lensControlReq(soap, &a->ns1__lensControlReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lensControl(struct soap *soap, const char *tag, int id, const struct __ns1__lensControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__lensControlReq(soap, "ns1:lensControlReq", -1, &a->ns1__lensControlReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lensControl * SOAP_FMAC4 soap_in___ns1__lensControl(struct soap *soap, const char *tag, struct __ns1__lensControl *a, const char *type)
{
	size_t soap_flag_ns1__lensControlReq = 1;
	short soap_flag;
	a = (struct __ns1__lensControl *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lensControl, sizeof(struct __ns1__lensControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lensControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__lensControlReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__lensControlReq(soap, "ns1:lensControlReq", &a->ns1__lensControlReq, ""))
				{	soap_flag_ns1__lensControlReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lensControl(struct soap *soap, const struct __ns1__lensControl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__lensControl(soap, tag?tag:"-ns1:lensControl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lensControl * SOAP_FMAC4 soap_get___ns1__lensControl(struct soap *soap, struct __ns1__lensControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lensControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ptzControl(struct soap *soap, struct __ns1__ptzControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ptzControlReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ptzControl(struct soap *soap, const struct __ns1__ptzControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ptzControlReq(soap, &a->ns1__ptzControlReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ptzControl(struct soap *soap, const char *tag, int id, const struct __ns1__ptzControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__ptzControlReq(soap, "ns1:ptzControlReq", -1, &a->ns1__ptzControlReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ptzControl * SOAP_FMAC4 soap_in___ns1__ptzControl(struct soap *soap, const char *tag, struct __ns1__ptzControl *a, const char *type)
{
	size_t soap_flag_ns1__ptzControlReq = 1;
	short soap_flag;
	a = (struct __ns1__ptzControl *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ptzControl, sizeof(struct __ns1__ptzControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ptzControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ptzControlReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ptzControlReq(soap, "ns1:ptzControlReq", &a->ns1__ptzControlReq, ""))
				{	soap_flag_ns1__ptzControlReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ptzControl(struct soap *soap, const struct __ns1__ptzControl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ptzControl(soap, tag?tag:"-ns1:ptzControl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ptzControl * SOAP_FMAC4 soap_get___ns1__ptzControl(struct soap *soap, struct __ns1__ptzControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ptzControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__nullifyDevice(struct soap *soap, struct __ns1__nullifyDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__nullifyDeviceReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__nullifyDevice(struct soap *soap, const struct __ns1__nullifyDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__nullifyDeviceReq(soap, &a->ns1__nullifyDeviceReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__nullifyDevice(struct soap *soap, const char *tag, int id, const struct __ns1__nullifyDevice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__nullifyDeviceReq(soap, "ns1:nullifyDeviceReq", -1, &a->ns1__nullifyDeviceReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__nullifyDevice * SOAP_FMAC4 soap_in___ns1__nullifyDevice(struct soap *soap, const char *tag, struct __ns1__nullifyDevice *a, const char *type)
{
	size_t soap_flag_ns1__nullifyDeviceReq = 1;
	short soap_flag;
	a = (struct __ns1__nullifyDevice *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__nullifyDevice, sizeof(struct __ns1__nullifyDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__nullifyDevice(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__nullifyDeviceReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__nullifyDeviceReq(soap, "ns1:nullifyDeviceReq", &a->ns1__nullifyDeviceReq, ""))
				{	soap_flag_ns1__nullifyDeviceReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__nullifyDevice(struct soap *soap, const struct __ns1__nullifyDevice *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__nullifyDevice(soap, tag?tag:"-ns1:nullifyDevice", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__nullifyDevice * SOAP_FMAC4 soap_get___ns1__nullifyDevice(struct soap *soap, struct __ns1__nullifyDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__nullifyDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addDevice(struct soap *soap, struct __ns1__addDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addDeviceReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addDevice(struct soap *soap, const struct __ns1__addDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__addDeviceReq(soap, &a->ns1__addDeviceReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addDevice(struct soap *soap, const char *tag, int id, const struct __ns1__addDevice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__addDeviceReq(soap, "ns1:addDeviceReq", -1, &a->ns1__addDeviceReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDevice * SOAP_FMAC4 soap_in___ns1__addDevice(struct soap *soap, const char *tag, struct __ns1__addDevice *a, const char *type)
{
	size_t soap_flag_ns1__addDeviceReq = 1;
	short soap_flag;
	a = (struct __ns1__addDevice *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addDevice, sizeof(struct __ns1__addDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addDevice(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addDeviceReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__addDeviceReq(soap, "ns1:addDeviceReq", &a->ns1__addDeviceReq, ""))
				{	soap_flag_ns1__addDeviceReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addDevice(struct soap *soap, const struct __ns1__addDevice *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addDevice(soap, tag?tag:"-ns1:addDevice", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDevice * SOAP_FMAC4 soap_get___ns1__addDevice(struct soap *soap, struct __ns1__addDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateChannelName(struct soap *soap, struct __ns1__updateChannelName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateChannelNameReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateChannelName(struct soap *soap, const struct __ns1__updateChannelName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__updateChannelNameReq(soap, &a->ns1__updateChannelNameReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateChannelName(struct soap *soap, const char *tag, int id, const struct __ns1__updateChannelName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__updateChannelNameReq(soap, "ns1:updateChannelNameReq", -1, &a->ns1__updateChannelNameReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateChannelName * SOAP_FMAC4 soap_in___ns1__updateChannelName(struct soap *soap, const char *tag, struct __ns1__updateChannelName *a, const char *type)
{
	size_t soap_flag_ns1__updateChannelNameReq = 1;
	short soap_flag;
	a = (struct __ns1__updateChannelName *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateChannelName, sizeof(struct __ns1__updateChannelName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateChannelName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateChannelNameReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__updateChannelNameReq(soap, "ns1:updateChannelNameReq", &a->ns1__updateChannelNameReq, ""))
				{	soap_flag_ns1__updateChannelNameReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateChannelName(struct soap *soap, const struct __ns1__updateChannelName *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateChannelName(soap, tag?tag:"-ns1:updateChannelName", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateChannelName * SOAP_FMAC4 soap_get___ns1__updateChannelName(struct soap *soap, struct __ns1__updateChannelName *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateChannelName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__userLogout(struct soap *soap, struct __ns1__userLogout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__userLogoutReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__userLogout(struct soap *soap, const struct __ns1__userLogout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__userLogoutReq(soap, &a->ns1__userLogoutReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__userLogout(struct soap *soap, const char *tag, int id, const struct __ns1__userLogout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__userLogoutReq(soap, "ns1:userLogoutReq", -1, &a->ns1__userLogoutReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__userLogout * SOAP_FMAC4 soap_in___ns1__userLogout(struct soap *soap, const char *tag, struct __ns1__userLogout *a, const char *type)
{
	size_t soap_flag_ns1__userLogoutReq = 1;
	short soap_flag;
	a = (struct __ns1__userLogout *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__userLogout, sizeof(struct __ns1__userLogout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__userLogout(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__userLogoutReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__userLogoutReq(soap, "ns1:userLogoutReq", &a->ns1__userLogoutReq, ""))
				{	soap_flag_ns1__userLogoutReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__userLogout(struct soap *soap, const struct __ns1__userLogout *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__userLogout(soap, tag?tag:"-ns1:userLogout", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__userLogout * SOAP_FMAC4 soap_get___ns1__userLogout(struct soap *soap, struct __ns1__userLogout *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__userLogout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__userLogin(struct soap *soap, struct __ns1__userLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__userLoginReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__userLogin(struct soap *soap, const struct __ns1__userLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__userLoginReq(soap, &a->ns1__userLoginReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__userLogin(struct soap *soap, const char *tag, int id, const struct __ns1__userLogin *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__userLoginReq(soap, "ns1:userLoginReq", -1, &a->ns1__userLoginReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__userLogin * SOAP_FMAC4 soap_in___ns1__userLogin(struct soap *soap, const char *tag, struct __ns1__userLogin *a, const char *type)
{
	size_t soap_flag_ns1__userLoginReq = 1;
	short soap_flag;
	a = (struct __ns1__userLogin *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__userLogin, sizeof(struct __ns1__userLogin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__userLogin(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__userLoginReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__userLoginReq(soap, "ns1:userLoginReq", &a->ns1__userLoginReq, "ns1:userLoginReq"))
				{	soap_flag_ns1__userLoginReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__userLogin(struct soap *soap, const struct __ns1__userLogin *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__userLogin(soap, tag?tag:"-ns1:userLogin", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__userLogin * SOAP_FMAC4 soap_get___ns1__userLogin(struct soap *soap, struct __ns1__userLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__userLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryDeviceBonded(struct soap *soap, struct __ns1__queryDeviceBonded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryDeviceBondedReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryDeviceBonded(struct soap *soap, const struct __ns1__queryDeviceBonded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryDeviceBondedReq(soap, &a->ns1__queryDeviceBondedReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryDeviceBonded(struct soap *soap, const char *tag, int id, const struct __ns1__queryDeviceBonded *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryDeviceBondedReq(soap, "ns1:queryDeviceBondedReq", -1, &a->ns1__queryDeviceBondedReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDeviceBonded * SOAP_FMAC4 soap_in___ns1__queryDeviceBonded(struct soap *soap, const char *tag, struct __ns1__queryDeviceBonded *a, const char *type)
{
	size_t soap_flag_ns1__queryDeviceBondedReq = 1;
	short soap_flag;
	a = (struct __ns1__queryDeviceBonded *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryDeviceBonded, sizeof(struct __ns1__queryDeviceBonded), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryDeviceBonded(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryDeviceBondedReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryDeviceBondedReq(soap, "ns1:queryDeviceBondedReq", &a->ns1__queryDeviceBondedReq, ""))
				{	soap_flag_ns1__queryDeviceBondedReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryDeviceBonded(struct soap *soap, const struct __ns1__queryDeviceBonded *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryDeviceBonded(soap, tag?tag:"-ns1:queryDeviceBonded", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDeviceBonded * SOAP_FMAC4 soap_get___ns1__queryDeviceBonded(struct soap *soap, struct __ns1__queryDeviceBonded *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryDeviceBonded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryClientVersion(struct soap *soap, struct __ns1__queryClientVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryClientVersionReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryClientVersion(struct soap *soap, const struct __ns1__queryClientVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryClientVersionReq(soap, &a->ns1__queryClientVersionReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryClientVersion(struct soap *soap, const char *tag, int id, const struct __ns1__queryClientVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryClientVersionReq(soap, "ns1:queryClientVersionReq", -1, &a->ns1__queryClientVersionReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryClientVersion * SOAP_FMAC4 soap_in___ns1__queryClientVersion(struct soap *soap, const char *tag, struct __ns1__queryClientVersion *a, const char *type)
{
	size_t soap_flag_ns1__queryClientVersionReq = 1;
	short soap_flag;
	a = (struct __ns1__queryClientVersion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryClientVersion, sizeof(struct __ns1__queryClientVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryClientVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryClientVersionReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryClientVersionReq(soap, "ns1:queryClientVersionReq", &a->ns1__queryClientVersionReq, ""))
				{	soap_flag_ns1__queryClientVersionReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryClientVersion(struct soap *soap, const struct __ns1__queryClientVersion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryClientVersion(soap, tag?tag:"-ns1:queryClientVersion", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryClientVersion * SOAP_FMAC4 soap_get___ns1__queryClientVersion(struct soap *soap, struct __ns1__queryClientVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryClientVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryAndroidToken(struct soap *soap, struct __ns1__queryAndroidToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryAndroidTokenReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryAndroidToken(struct soap *soap, const struct __ns1__queryAndroidToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryAndroidTokenReq(soap, &a->ns1__queryAndroidTokenReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryAndroidToken(struct soap *soap, const char *tag, int id, const struct __ns1__queryAndroidToken *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryAndroidTokenReq(soap, "ns1:queryAndroidTokenReq", -1, &a->ns1__queryAndroidTokenReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryAndroidToken * SOAP_FMAC4 soap_in___ns1__queryAndroidToken(struct soap *soap, const char *tag, struct __ns1__queryAndroidToken *a, const char *type)
{
	size_t soap_flag_ns1__queryAndroidTokenReq = 1;
	short soap_flag;
	a = (struct __ns1__queryAndroidToken *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryAndroidToken, sizeof(struct __ns1__queryAndroidToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryAndroidToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryAndroidTokenReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryAndroidTokenReq(soap, "ns1:queryAndroidTokenReq", &a->ns1__queryAndroidTokenReq, ""))
				{	soap_flag_ns1__queryAndroidTokenReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryAndroidToken(struct soap *soap, const struct __ns1__queryAndroidToken *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryAndroidToken(soap, tag?tag:"-ns1:queryAndroidToken", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryAndroidToken * SOAP_FMAC4 soap_get___ns1__queryAndroidToken(struct soap *soap, struct __ns1__queryAndroidToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryAndroidToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryAppleToken(struct soap *soap, struct __ns1__queryAppleToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryAppleTokenReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryAppleToken(struct soap *soap, const struct __ns1__queryAppleToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryAppleTokenReq(soap, &a->ns1__queryAppleTokenReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryAppleToken(struct soap *soap, const char *tag, int id, const struct __ns1__queryAppleToken *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryAppleTokenReq(soap, "ns1:queryAppleTokenReq", -1, &a->ns1__queryAppleTokenReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryAppleToken * SOAP_FMAC4 soap_in___ns1__queryAppleToken(struct soap *soap, const char *tag, struct __ns1__queryAppleToken *a, const char *type)
{
	size_t soap_flag_ns1__queryAppleTokenReq = 1;
	short soap_flag;
	a = (struct __ns1__queryAppleToken *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryAppleToken, sizeof(struct __ns1__queryAppleToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryAppleToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryAppleTokenReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryAppleTokenReq(soap, "ns1:queryAppleTokenReq", &a->ns1__queryAppleTokenReq, ""))
				{	soap_flag_ns1__queryAppleTokenReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryAppleToken(struct soap *soap, const struct __ns1__queryAppleToken *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryAppleToken(soap, tag?tag:"-ns1:queryAppleToken", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryAppleToken * SOAP_FMAC4 soap_get___ns1__queryAppleToken(struct soap *soap, struct __ns1__queryAppleToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryAppleToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryDeviceSharingSource(struct soap *soap, struct __ns1__queryDeviceSharingSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryDeviceSharingSourceReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryDeviceSharingSource(struct soap *soap, const struct __ns1__queryDeviceSharingSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryDeviceSharingSourceReq(soap, &a->ns1__queryDeviceSharingSourceReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryDeviceSharingSource(struct soap *soap, const char *tag, int id, const struct __ns1__queryDeviceSharingSource *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryDeviceSharingSourceReq(soap, "ns1:queryDeviceSharingSourceReq", -1, &a->ns1__queryDeviceSharingSourceReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDeviceSharingSource * SOAP_FMAC4 soap_in___ns1__queryDeviceSharingSource(struct soap *soap, const char *tag, struct __ns1__queryDeviceSharingSource *a, const char *type)
{
	size_t soap_flag_ns1__queryDeviceSharingSourceReq = 1;
	short soap_flag;
	a = (struct __ns1__queryDeviceSharingSource *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryDeviceSharingSource, sizeof(struct __ns1__queryDeviceSharingSource), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryDeviceSharingSource(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryDeviceSharingSourceReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryDeviceSharingSourceReq(soap, "ns1:queryDeviceSharingSourceReq", &a->ns1__queryDeviceSharingSourceReq, ""))
				{	soap_flag_ns1__queryDeviceSharingSourceReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryDeviceSharingSource(struct soap *soap, const struct __ns1__queryDeviceSharingSource *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryDeviceSharingSource(soap, tag?tag:"-ns1:queryDeviceSharingSource", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDeviceSharingSource * SOAP_FMAC4 soap_get___ns1__queryDeviceSharingSource(struct soap *soap, struct __ns1__queryDeviceSharingSource *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryDeviceSharingSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryDeviceSharer(struct soap *soap, struct __ns1__queryDeviceSharer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryDeviceSharerReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryDeviceSharer(struct soap *soap, const struct __ns1__queryDeviceSharer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryDeviceSharerReq(soap, &a->ns1__queryDeviceSharerReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryDeviceSharer(struct soap *soap, const char *tag, int id, const struct __ns1__queryDeviceSharer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryDeviceSharerReq(soap, "ns1:queryDeviceSharerReq", -1, &a->ns1__queryDeviceSharerReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDeviceSharer * SOAP_FMAC4 soap_in___ns1__queryDeviceSharer(struct soap *soap, const char *tag, struct __ns1__queryDeviceSharer *a, const char *type)
{
	size_t soap_flag_ns1__queryDeviceSharerReq = 1;
	short soap_flag;
	a = (struct __ns1__queryDeviceSharer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryDeviceSharer, sizeof(struct __ns1__queryDeviceSharer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryDeviceSharer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryDeviceSharerReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryDeviceSharerReq(soap, "ns1:queryDeviceSharerReq", &a->ns1__queryDeviceSharerReq, ""))
				{	soap_flag_ns1__queryDeviceSharerReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryDeviceSharer(struct soap *soap, const struct __ns1__queryDeviceSharer *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryDeviceSharer(soap, tag?tag:"-ns1:queryDeviceSharer", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDeviceSharer * SOAP_FMAC4 soap_get___ns1__queryDeviceSharer(struct soap *soap, struct __ns1__queryDeviceSharer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryDeviceSharer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__nullifyDeviceSharer(struct soap *soap, struct __ns1__nullifyDeviceSharer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__nullifyDeviceSharerReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__nullifyDeviceSharer(struct soap *soap, const struct __ns1__nullifyDeviceSharer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__nullifyDeviceSharerReq(soap, &a->ns1__nullifyDeviceSharerReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__nullifyDeviceSharer(struct soap *soap, const char *tag, int id, const struct __ns1__nullifyDeviceSharer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__nullifyDeviceSharerReq(soap, "ns1:nullifyDeviceSharerReq", -1, &a->ns1__nullifyDeviceSharerReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__nullifyDeviceSharer * SOAP_FMAC4 soap_in___ns1__nullifyDeviceSharer(struct soap *soap, const char *tag, struct __ns1__nullifyDeviceSharer *a, const char *type)
{
	size_t soap_flag_ns1__nullifyDeviceSharerReq = 1;
	short soap_flag;
	a = (struct __ns1__nullifyDeviceSharer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__nullifyDeviceSharer, sizeof(struct __ns1__nullifyDeviceSharer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__nullifyDeviceSharer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__nullifyDeviceSharerReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__nullifyDeviceSharerReq(soap, "ns1:nullifyDeviceSharerReq", &a->ns1__nullifyDeviceSharerReq, ""))
				{	soap_flag_ns1__nullifyDeviceSharerReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__nullifyDeviceSharer(struct soap *soap, const struct __ns1__nullifyDeviceSharer *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__nullifyDeviceSharer(soap, tag?tag:"-ns1:nullifyDeviceSharer", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__nullifyDeviceSharer * SOAP_FMAC4 soap_get___ns1__nullifyDeviceSharer(struct soap *soap, struct __ns1__nullifyDeviceSharer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__nullifyDeviceSharer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addDeviceSharer(struct soap *soap, struct __ns1__addDeviceSharer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addDeviceSharerReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addDeviceSharer(struct soap *soap, const struct __ns1__addDeviceSharer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__addDeviceSharerReq(soap, &a->ns1__addDeviceSharerReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addDeviceSharer(struct soap *soap, const char *tag, int id, const struct __ns1__addDeviceSharer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__addDeviceSharerReq(soap, "ns1:addDeviceSharerReq", -1, &a->ns1__addDeviceSharerReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDeviceSharer * SOAP_FMAC4 soap_in___ns1__addDeviceSharer(struct soap *soap, const char *tag, struct __ns1__addDeviceSharer *a, const char *type)
{
	size_t soap_flag_ns1__addDeviceSharerReq = 1;
	short soap_flag;
	a = (struct __ns1__addDeviceSharer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addDeviceSharer, sizeof(struct __ns1__addDeviceSharer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addDeviceSharer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addDeviceSharerReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__addDeviceSharerReq(soap, "ns1:addDeviceSharerReq", &a->ns1__addDeviceSharerReq, ""))
				{	soap_flag_ns1__addDeviceSharerReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addDeviceSharer(struct soap *soap, const struct __ns1__addDeviceSharer *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addDeviceSharer(soap, tag?tag:"-ns1:addDeviceSharer", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDeviceSharer * SOAP_FMAC4 soap_get___ns1__addDeviceSharer(struct soap *soap, struct __ns1__addDeviceSharer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addDeviceSharer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryDeviceStatus(struct soap *soap, struct __ns1__queryDeviceStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryDeviceStatusReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryDeviceStatus(struct soap *soap, const struct __ns1__queryDeviceStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryDeviceStatusReq(soap, &a->ns1__queryDeviceStatusReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryDeviceStatus(struct soap *soap, const char *tag, int id, const struct __ns1__queryDeviceStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryDeviceStatusReq(soap, "ns1:queryDeviceStatusReq", -1, &a->ns1__queryDeviceStatusReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDeviceStatus * SOAP_FMAC4 soap_in___ns1__queryDeviceStatus(struct soap *soap, const char *tag, struct __ns1__queryDeviceStatus *a, const char *type)
{
	size_t soap_flag_ns1__queryDeviceStatusReq = 1;
	short soap_flag;
	a = (struct __ns1__queryDeviceStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryDeviceStatus, sizeof(struct __ns1__queryDeviceStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryDeviceStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryDeviceStatusReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryDeviceStatusReq(soap, "ns1:queryDeviceStatusReq", &a->ns1__queryDeviceStatusReq, ""))
				{	soap_flag_ns1__queryDeviceStatusReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryDeviceStatus(struct soap *soap, const struct __ns1__queryDeviceStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryDeviceStatus(soap, tag?tag:"-ns1:queryDeviceStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDeviceStatus * SOAP_FMAC4 soap_get___ns1__queryDeviceStatus(struct soap *soap, struct __ns1__queryDeviceStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryDeviceStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateAndroidToken(struct soap *soap, struct __ns1__updateAndroidToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateAndroidTokenReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateAndroidToken(struct soap *soap, const struct __ns1__updateAndroidToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__updateAndroidTokenReq(soap, &a->ns1__updateAndroidTokenReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateAndroidToken(struct soap *soap, const char *tag, int id, const struct __ns1__updateAndroidToken *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__updateAndroidTokenReq(soap, "ns1:updateAndroidTokenReq", -1, &a->ns1__updateAndroidTokenReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAndroidToken * SOAP_FMAC4 soap_in___ns1__updateAndroidToken(struct soap *soap, const char *tag, struct __ns1__updateAndroidToken *a, const char *type)
{
	size_t soap_flag_ns1__updateAndroidTokenReq = 1;
	short soap_flag;
	a = (struct __ns1__updateAndroidToken *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateAndroidToken, sizeof(struct __ns1__updateAndroidToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateAndroidToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateAndroidTokenReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__updateAndroidTokenReq(soap, "ns1:updateAndroidTokenReq", &a->ns1__updateAndroidTokenReq, ""))
				{	soap_flag_ns1__updateAndroidTokenReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateAndroidToken(struct soap *soap, const struct __ns1__updateAndroidToken *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateAndroidToken(soap, tag?tag:"-ns1:updateAndroidToken", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAndroidToken * SOAP_FMAC4 soap_get___ns1__updateAndroidToken(struct soap *soap, struct __ns1__updateAndroidToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateAndroidToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryPUEventLog(struct soap *soap, struct __ns1__queryPUEventLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryPUEventLogReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryPUEventLog(struct soap *soap, const struct __ns1__queryPUEventLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryPUEventLogReq(soap, &a->ns1__queryPUEventLogReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryPUEventLog(struct soap *soap, const char *tag, int id, const struct __ns1__queryPUEventLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryPUEventLogReq(soap, "ns1:queryPUEventLogReq", -1, &a->ns1__queryPUEventLogReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryPUEventLog * SOAP_FMAC4 soap_in___ns1__queryPUEventLog(struct soap *soap, const char *tag, struct __ns1__queryPUEventLog *a, const char *type)
{
	size_t soap_flag_ns1__queryPUEventLogReq = 1;
	short soap_flag;
	a = (struct __ns1__queryPUEventLog *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryPUEventLog, sizeof(struct __ns1__queryPUEventLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryPUEventLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryPUEventLogReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryPUEventLogReq(soap, "ns1:queryPUEventLogReq", &a->ns1__queryPUEventLogReq, ""))
				{	soap_flag_ns1__queryPUEventLogReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryPUEventLog(struct soap *soap, const struct __ns1__queryPUEventLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryPUEventLog(soap, tag?tag:"-ns1:queryPUEventLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryPUEventLog * SOAP_FMAC4 soap_get___ns1__queryPUEventLog(struct soap *soap, struct __ns1__queryPUEventLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryPUEventLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryPUOnOffLog(struct soap *soap, struct __ns1__queryPUOnOffLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryPUOnOffLogReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryPUOnOffLog(struct soap *soap, const struct __ns1__queryPUOnOffLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryPUOnOffLogReq(soap, &a->ns1__queryPUOnOffLogReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryPUOnOffLog(struct soap *soap, const char *tag, int id, const struct __ns1__queryPUOnOffLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryPUOnOffLogReq(soap, "ns1:queryPUOnOffLogReq", -1, &a->ns1__queryPUOnOffLogReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryPUOnOffLog * SOAP_FMAC4 soap_in___ns1__queryPUOnOffLog(struct soap *soap, const char *tag, struct __ns1__queryPUOnOffLog *a, const char *type)
{
	size_t soap_flag_ns1__queryPUOnOffLogReq = 1;
	short soap_flag;
	a = (struct __ns1__queryPUOnOffLog *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryPUOnOffLog, sizeof(struct __ns1__queryPUOnOffLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryPUOnOffLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryPUOnOffLogReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryPUOnOffLogReq(soap, "ns1:queryPUOnOffLogReq", &a->ns1__queryPUOnOffLogReq, ""))
				{	soap_flag_ns1__queryPUOnOffLogReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryPUOnOffLog(struct soap *soap, const struct __ns1__queryPUOnOffLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryPUOnOffLog(soap, tag?tag:"-ns1:queryPUOnOffLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryPUOnOffLog * SOAP_FMAC4 soap_get___ns1__queryPUOnOffLog(struct soap *soap, struct __ns1__queryPUOnOffLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryPUOnOffLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__inviteKeepAlive(struct soap *soap, struct __ns1__inviteKeepAlive *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__inviteKeepAliveReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__inviteKeepAlive(struct soap *soap, const struct __ns1__inviteKeepAlive *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__inviteKeepAliveReq(soap, &a->ns1__inviteKeepAliveReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__inviteKeepAlive(struct soap *soap, const char *tag, int id, const struct __ns1__inviteKeepAlive *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__inviteKeepAliveReq(soap, "ns1:inviteKeepAliveReq", -1, &a->ns1__inviteKeepAliveReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__inviteKeepAlive * SOAP_FMAC4 soap_in___ns1__inviteKeepAlive(struct soap *soap, const char *tag, struct __ns1__inviteKeepAlive *a, const char *type)
{
	size_t soap_flag_ns1__inviteKeepAliveReq = 1;
	short soap_flag;
	a = (struct __ns1__inviteKeepAlive *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__inviteKeepAlive, sizeof(struct __ns1__inviteKeepAlive), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__inviteKeepAlive(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__inviteKeepAliveReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__inviteKeepAliveReq(soap, "ns1:inviteKeepAliveReq", &a->ns1__inviteKeepAliveReq, ""))
				{	soap_flag_ns1__inviteKeepAliveReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__inviteKeepAlive(struct soap *soap, const struct __ns1__inviteKeepAlive *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__inviteKeepAlive(soap, tag?tag:"-ns1:inviteKeepAlive", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__inviteKeepAlive * SOAP_FMAC4 soap_get___ns1__inviteKeepAlive(struct soap *soap, struct __ns1__inviteKeepAlive *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__inviteKeepAlive(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__notifyNATResult(struct soap *soap, struct __ns1__notifyNATResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__notifyNATResultReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__notifyNATResult(struct soap *soap, const struct __ns1__notifyNATResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__notifyNATResultReq(soap, &a->ns1__notifyNATResultReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__notifyNATResult(struct soap *soap, const char *tag, int id, const struct __ns1__notifyNATResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__notifyNATResultReq(soap, "ns1:notifyNATResultReq", -1, &a->ns1__notifyNATResultReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__notifyNATResult * SOAP_FMAC4 soap_in___ns1__notifyNATResult(struct soap *soap, const char *tag, struct __ns1__notifyNATResult *a, const char *type)
{
	size_t soap_flag_ns1__notifyNATResultReq = 1;
	short soap_flag;
	a = (struct __ns1__notifyNATResult *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__notifyNATResult, sizeof(struct __ns1__notifyNATResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__notifyNATResult(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__notifyNATResultReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__notifyNATResultReq(soap, "ns1:notifyNATResultReq", &a->ns1__notifyNATResultReq, ""))
				{	soap_flag_ns1__notifyNATResultReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__notifyNATResult(struct soap *soap, const struct __ns1__notifyNATResult *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__notifyNATResult(soap, tag?tag:"-ns1:notifyNATResult", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__notifyNATResult * SOAP_FMAC4 soap_get___ns1__notifyNATResult(struct soap *soap, struct __ns1__notifyNATResult *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__notifyNATResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__subscribeEMail(struct soap *soap, struct __ns1__subscribeEMail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__subscribeEMailReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__subscribeEMail(struct soap *soap, const struct __ns1__subscribeEMail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__subscribeEMailReq(soap, &a->ns1__subscribeEMailReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__subscribeEMail(struct soap *soap, const char *tag, int id, const struct __ns1__subscribeEMail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__subscribeEMailReq(soap, "ns1:subscribeEMailReq", -1, &a->ns1__subscribeEMailReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__subscribeEMail * SOAP_FMAC4 soap_in___ns1__subscribeEMail(struct soap *soap, const char *tag, struct __ns1__subscribeEMail *a, const char *type)
{
	size_t soap_flag_ns1__subscribeEMailReq = 1;
	short soap_flag;
	a = (struct __ns1__subscribeEMail *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__subscribeEMail, sizeof(struct __ns1__subscribeEMail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__subscribeEMail(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__subscribeEMailReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__subscribeEMailReq(soap, "ns1:subscribeEMailReq", &a->ns1__subscribeEMailReq, ""))
				{	soap_flag_ns1__subscribeEMailReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__subscribeEMail(struct soap *soap, const struct __ns1__subscribeEMail *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__subscribeEMail(soap, tag?tag:"-ns1:subscribeEMail", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__subscribeEMail * SOAP_FMAC4 soap_get___ns1__subscribeEMail(struct soap *soap, struct __ns1__subscribeEMail *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__subscribeEMail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__subscribeSMS(struct soap *soap, struct __ns1__subscribeSMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__subscribeSMSReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__subscribeSMS(struct soap *soap, const struct __ns1__subscribeSMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__subscribeSMSReq(soap, &a->ns1__subscribeSMSReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__subscribeSMS(struct soap *soap, const char *tag, int id, const struct __ns1__subscribeSMS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__subscribeSMSReq(soap, "ns1:subscribeSMSReq", -1, &a->ns1__subscribeSMSReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__subscribeSMS * SOAP_FMAC4 soap_in___ns1__subscribeSMS(struct soap *soap, const char *tag, struct __ns1__subscribeSMS *a, const char *type)
{
	size_t soap_flag_ns1__subscribeSMSReq = 1;
	short soap_flag;
	a = (struct __ns1__subscribeSMS *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__subscribeSMS, sizeof(struct __ns1__subscribeSMS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__subscribeSMS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__subscribeSMSReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__subscribeSMSReq(soap, "ns1:subscribeSMSReq", &a->ns1__subscribeSMSReq, ""))
				{	soap_flag_ns1__subscribeSMSReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__subscribeSMS(struct soap *soap, const struct __ns1__subscribeSMS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__subscribeSMS(soap, tag?tag:"-ns1:subscribeSMS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__subscribeSMS * SOAP_FMAC4 soap_get___ns1__subscribeSMS(struct soap *soap, struct __ns1__subscribeSMS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__subscribeSMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getNATServer(struct soap *soap, struct __ns1__getNATServer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getNATServerReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getNATServer(struct soap *soap, const struct __ns1__getNATServer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getNATServerReq(soap, &a->ns1__getNATServerReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getNATServer(struct soap *soap, const char *tag, int id, const struct __ns1__getNATServer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getNATServerReq(soap, "ns1:getNATServerReq", -1, &a->ns1__getNATServerReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getNATServer * SOAP_FMAC4 soap_in___ns1__getNATServer(struct soap *soap, const char *tag, struct __ns1__getNATServer *a, const char *type)
{
	size_t soap_flag_ns1__getNATServerReq = 1;
	short soap_flag;
	a = (struct __ns1__getNATServer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getNATServer, sizeof(struct __ns1__getNATServer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getNATServer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getNATServerReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getNATServerReq(soap, "ns1:getNATServerReq", &a->ns1__getNATServerReq, ""))
				{	soap_flag_ns1__getNATServerReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getNATServer(struct soap *soap, const struct __ns1__getNATServer *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getNATServer(soap, tag?tag:"-ns1:getNATServer", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getNATServer * SOAP_FMAC4 soap_get___ns1__getNATServer(struct soap *soap, struct __ns1__getNATServer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getNATServer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__bye(struct soap *soap, struct __ns1__bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__byeReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__bye(struct soap *soap, const struct __ns1__bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__byeReq(soap, &a->ns1__byeReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__bye(struct soap *soap, const char *tag, int id, const struct __ns1__bye *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__byeReq(soap, "ns1:byeReq", -1, &a->ns1__byeReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__bye * SOAP_FMAC4 soap_in___ns1__bye(struct soap *soap, const char *tag, struct __ns1__bye *a, const char *type)
{
	size_t soap_flag_ns1__byeReq = 1;
	short soap_flag;
	a = (struct __ns1__bye *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__bye, sizeof(struct __ns1__bye), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__bye(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__byeReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__byeReq(soap, "ns1:byeReq", &a->ns1__byeReq, ""))
				{	soap_flag_ns1__byeReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__bye(struct soap *soap, const struct __ns1__bye *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__bye(soap, tag?tag:"-ns1:bye", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__bye * SOAP_FMAC4 soap_get___ns1__bye(struct soap *soap, struct __ns1__bye *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__bye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__invite(struct soap *soap, struct __ns1__invite *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__inviteReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__invite(struct soap *soap, const struct __ns1__invite *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__inviteReq(soap, &a->ns1__inviteReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__invite(struct soap *soap, const char *tag, int id, const struct __ns1__invite *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__inviteReq(soap, "ns1:inviteReq", -1, &a->ns1__inviteReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__invite * SOAP_FMAC4 soap_in___ns1__invite(struct soap *soap, const char *tag, struct __ns1__invite *a, const char *type)
{
	size_t soap_flag_ns1__inviteReq = 1;
	short soap_flag;
	a = (struct __ns1__invite *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__invite, sizeof(struct __ns1__invite), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__invite(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__inviteReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__inviteReq(soap, "ns1:inviteReq", &a->ns1__inviteReq, "ns1:inviteReq"))
				{	soap_flag_ns1__inviteReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__invite(struct soap *soap, const struct __ns1__invite *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__invite(soap, tag?tag:"-ns1:invite", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__invite * SOAP_FMAC4 soap_get___ns1__invite(struct soap *soap, struct __ns1__invite *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__invite(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setAuxiliary(struct soap *soap, struct __ns1__setAuxiliary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setAuxiliaryReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setAuxiliary(struct soap *soap, const struct __ns1__setAuxiliary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setAuxiliaryReq(soap, &a->ns1__setAuxiliaryReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setAuxiliary(struct soap *soap, const char *tag, int id, const struct __ns1__setAuxiliary *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setAuxiliaryReq(soap, "ns1:setAuxiliaryReq", -1, &a->ns1__setAuxiliaryReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setAuxiliary * SOAP_FMAC4 soap_in___ns1__setAuxiliary(struct soap *soap, const char *tag, struct __ns1__setAuxiliary *a, const char *type)
{
	size_t soap_flag_ns1__setAuxiliaryReq = 1;
	short soap_flag;
	a = (struct __ns1__setAuxiliary *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setAuxiliary, sizeof(struct __ns1__setAuxiliary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setAuxiliary(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setAuxiliaryReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setAuxiliaryReq(soap, "ns1:setAuxiliaryReq", &a->ns1__setAuxiliaryReq, ""))
				{	soap_flag_ns1__setAuxiliaryReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setAuxiliary(struct soap *soap, const struct __ns1__setAuxiliary *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setAuxiliary(soap, tag?tag:"-ns1:setAuxiliary", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setAuxiliary * SOAP_FMAC4 soap_get___ns1__setAuxiliary(struct soap *soap, struct __ns1__setAuxiliary *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setAuxiliary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAuxiliary(struct soap *soap, struct __ns1__getAuxiliary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAuxiliaryReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAuxiliary(struct soap *soap, const struct __ns1__getAuxiliary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getAuxiliaryReq(soap, &a->ns1__getAuxiliaryReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAuxiliary(struct soap *soap, const char *tag, int id, const struct __ns1__getAuxiliary *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getAuxiliaryReq(soap, "ns1:getAuxiliaryReq", -1, &a->ns1__getAuxiliaryReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAuxiliary * SOAP_FMAC4 soap_in___ns1__getAuxiliary(struct soap *soap, const char *tag, struct __ns1__getAuxiliary *a, const char *type)
{
	size_t soap_flag_ns1__getAuxiliaryReq = 1;
	short soap_flag;
	a = (struct __ns1__getAuxiliary *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAuxiliary, sizeof(struct __ns1__getAuxiliary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAuxiliary(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAuxiliaryReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAuxiliaryReq(soap, "ns1:getAuxiliaryReq", &a->ns1__getAuxiliaryReq, ""))
				{	soap_flag_ns1__getAuxiliaryReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAuxiliary(struct soap *soap, const struct __ns1__getAuxiliary *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAuxiliary(soap, tag?tag:"-ns1:getAuxiliary", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAuxiliary * SOAP_FMAC4 soap_get___ns1__getAuxiliary(struct soap *soap, struct __ns1__getAuxiliary *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAuxiliary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getBackPassword(struct soap *soap, struct __ns1__getBackPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getBackPasswordReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getBackPassword(struct soap *soap, const struct __ns1__getBackPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getBackPasswordReq(soap, &a->ns1__getBackPasswordReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getBackPassword(struct soap *soap, const char *tag, int id, const struct __ns1__getBackPassword *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getBackPasswordReq(soap, "ns1:getBackPasswordReq", -1, &a->ns1__getBackPasswordReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getBackPassword * SOAP_FMAC4 soap_in___ns1__getBackPassword(struct soap *soap, const char *tag, struct __ns1__getBackPassword *a, const char *type)
{
	size_t soap_flag_ns1__getBackPasswordReq = 1;
	short soap_flag;
	a = (struct __ns1__getBackPassword *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getBackPassword, sizeof(struct __ns1__getBackPassword), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getBackPassword(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getBackPasswordReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getBackPasswordReq(soap, "ns1:getBackPasswordReq", &a->ns1__getBackPasswordReq, ""))
				{	soap_flag_ns1__getBackPasswordReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getBackPassword(struct soap *soap, const struct __ns1__getBackPassword *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getBackPassword(soap, tag?tag:"-ns1:getBackPassword", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getBackPassword * SOAP_FMAC4 soap_get___ns1__getBackPassword(struct soap *soap, struct __ns1__getBackPassword *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getBackPassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAccount(struct soap *soap, struct __ns1__getAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAccountReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAccount(struct soap *soap, const struct __ns1__getAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getAccountReq(soap, &a->ns1__getAccountReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAccount(struct soap *soap, const char *tag, int id, const struct __ns1__getAccount *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getAccountReq(soap, "ns1:getAccountReq", -1, &a->ns1__getAccountReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAccount * SOAP_FMAC4 soap_in___ns1__getAccount(struct soap *soap, const char *tag, struct __ns1__getAccount *a, const char *type)
{
	size_t soap_flag_ns1__getAccountReq = 1;
	short soap_flag;
	a = (struct __ns1__getAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAccount, sizeof(struct __ns1__getAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAccountReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAccountReq(soap, "ns1:getAccountReq", &a->ns1__getAccountReq, ""))
				{	soap_flag_ns1__getAccountReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAccount(struct soap *soap, const struct __ns1__getAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAccount(soap, tag?tag:"-ns1:getAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAccount * SOAP_FMAC4 soap_get___ns1__getAccount(struct soap *soap, struct __ns1__getAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateAppleToken(struct soap *soap, struct __ns1__updateAppleToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateAppleTokenReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateAppleToken(struct soap *soap, const struct __ns1__updateAppleToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__updateAppleTokenReq(soap, &a->ns1__updateAppleTokenReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateAppleToken(struct soap *soap, const char *tag, int id, const struct __ns1__updateAppleToken *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__updateAppleTokenReq(soap, "ns1:updateAppleTokenReq", -1, &a->ns1__updateAppleTokenReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAppleToken * SOAP_FMAC4 soap_in___ns1__updateAppleToken(struct soap *soap, const char *tag, struct __ns1__updateAppleToken *a, const char *type)
{
	size_t soap_flag_ns1__updateAppleTokenReq = 1;
	short soap_flag;
	a = (struct __ns1__updateAppleToken *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateAppleToken, sizeof(struct __ns1__updateAppleToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateAppleToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateAppleTokenReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__updateAppleTokenReq(soap, "ns1:updateAppleTokenReq", &a->ns1__updateAppleTokenReq, ""))
				{	soap_flag_ns1__updateAppleTokenReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateAppleToken(struct soap *soap, const struct __ns1__updateAppleToken *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateAppleToken(soap, tag?tag:"-ns1:updateAppleToken", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAppleToken * SOAP_FMAC4 soap_get___ns1__updateAppleToken(struct soap *soap, struct __ns1__updateAppleToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateAppleToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryDevice(struct soap *soap, struct __ns1__queryDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryDeviceReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryDevice(struct soap *soap, const struct __ns1__queryDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryDeviceReq(soap, &a->ns1__queryDeviceReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryDevice(struct soap *soap, const char *tag, int id, const struct __ns1__queryDevice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryDeviceReq(soap, "ns1:queryDeviceReq", -1, &a->ns1__queryDeviceReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDevice * SOAP_FMAC4 soap_in___ns1__queryDevice(struct soap *soap, const char *tag, struct __ns1__queryDevice *a, const char *type)
{
	size_t soap_flag_ns1__queryDeviceReq = 1;
	short soap_flag;
	a = (struct __ns1__queryDevice *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryDevice, sizeof(struct __ns1__queryDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryDevice(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryDeviceReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryDeviceReq(soap, "ns1:queryDeviceReq", &a->ns1__queryDeviceReq, ""))
				{	soap_flag_ns1__queryDeviceReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryDevice(struct soap *soap, const struct __ns1__queryDevice *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryDevice(soap, tag?tag:"-ns1:queryDevice", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDevice * SOAP_FMAC4 soap_get___ns1__queryDevice(struct soap *soap, struct __ns1__queryDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updatePassword(struct soap *soap, struct __ns1__updatePassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updatePasswordReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updatePassword(struct soap *soap, const struct __ns1__updatePassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__updatePasswordReq(soap, &a->ns1__updatePasswordReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updatePassword(struct soap *soap, const char *tag, int id, const struct __ns1__updatePassword *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__updatePasswordReq(soap, "ns1:updatePasswordReq", -1, &a->ns1__updatePasswordReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updatePassword * SOAP_FMAC4 soap_in___ns1__updatePassword(struct soap *soap, const char *tag, struct __ns1__updatePassword *a, const char *type)
{
	size_t soap_flag_ns1__updatePasswordReq = 1;
	short soap_flag;
	a = (struct __ns1__updatePassword *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updatePassword, sizeof(struct __ns1__updatePassword), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updatePassword(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updatePasswordReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__updatePasswordReq(soap, "ns1:updatePasswordReq", &a->ns1__updatePasswordReq, ""))
				{	soap_flag_ns1__updatePasswordReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updatePassword(struct soap *soap, const struct __ns1__updatePassword *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updatePassword(soap, tag?tag:"-ns1:updatePassword", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updatePassword * SOAP_FMAC4 soap_get___ns1__updatePassword(struct soap *soap, struct __ns1__updatePassword *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updatePassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateAccount(struct soap *soap, struct __ns1__updateAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateAccountReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateAccount(struct soap *soap, const struct __ns1__updateAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__updateAccountReq(soap, &a->ns1__updateAccountReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateAccount(struct soap *soap, const char *tag, int id, const struct __ns1__updateAccount *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__updateAccountReq(soap, "ns1:updateAccountReq", -1, &a->ns1__updateAccountReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAccount * SOAP_FMAC4 soap_in___ns1__updateAccount(struct soap *soap, const char *tag, struct __ns1__updateAccount *a, const char *type)
{
	size_t soap_flag_ns1__updateAccountReq = 1;
	short soap_flag;
	a = (struct __ns1__updateAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateAccount, sizeof(struct __ns1__updateAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateAccountReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__updateAccountReq(soap, "ns1:updateAccountReq", &a->ns1__updateAccountReq, ""))
				{	soap_flag_ns1__updateAccountReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateAccount(struct soap *soap, const struct __ns1__updateAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateAccount(soap, tag?tag:"-ns1:updateAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAccount * SOAP_FMAC4 soap_get___ns1__updateAccount(struct soap *soap, struct __ns1__updateAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createAccount(struct soap *soap, struct __ns1__createAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__createAccountReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createAccount(struct soap *soap, const struct __ns1__createAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__createAccountReq(soap, &a->ns1__createAccountReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createAccount(struct soap *soap, const char *tag, int id, const struct __ns1__createAccount *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__createAccountReq(soap, "ns1:createAccountReq", -1, &a->ns1__createAccountReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createAccount * SOAP_FMAC4 soap_in___ns1__createAccount(struct soap *soap, const char *tag, struct __ns1__createAccount *a, const char *type)
{
	size_t soap_flag_ns1__createAccountReq = 1;
	short soap_flag;
	a = (struct __ns1__createAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createAccount, sizeof(struct __ns1__createAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__createAccountReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__createAccountReq(soap, "ns1:createAccountReq", &a->ns1__createAccountReq, ""))
				{	soap_flag_ns1__createAccountReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createAccount(struct soap *soap, const struct __ns1__createAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__createAccount(soap, tag?tag:"-ns1:createAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createAccount * SOAP_FMAC4 soap_get___ns1__createAccount(struct soap *soap, struct __ns1__createAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPicture(struct soap *soap, struct __ns1__getPicture *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPictureReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPicture(struct soap *soap, const struct __ns1__getPicture *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getPictureReq(soap, &a->ns1__getPictureReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPicture(struct soap *soap, const char *tag, int id, const struct __ns1__getPicture *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getPictureReq(soap, "ns1:getPictureReq", -1, &a->ns1__getPictureReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPicture * SOAP_FMAC4 soap_in___ns1__getPicture(struct soap *soap, const char *tag, struct __ns1__getPicture *a, const char *type)
{
	size_t soap_flag_ns1__getPictureReq = 1;
	short soap_flag;
	a = (struct __ns1__getPicture *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPicture, sizeof(struct __ns1__getPicture), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPicture(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPictureReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getPictureReq(soap, "ns1:getPictureReq", &a->ns1__getPictureReq, ""))
				{	soap_flag_ns1__getPictureReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPicture(struct soap *soap, const struct __ns1__getPicture *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPicture(soap, tag?tag:"-ns1:getPicture", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPicture * SOAP_FMAC4 soap_get___ns1__getPicture(struct soap *soap, struct __ns1__getPicture *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPicture(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__flaggedNoticeStatus(struct soap *soap, struct __ns1__flaggedNoticeStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__flaggedNoticeStatusReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__flaggedNoticeStatus(struct soap *soap, const struct __ns1__flaggedNoticeStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__flaggedNoticeStatusReq(soap, &a->ns1__flaggedNoticeStatusReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__flaggedNoticeStatus(struct soap *soap, const char *tag, int id, const struct __ns1__flaggedNoticeStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__flaggedNoticeStatusReq(soap, "ns1:flaggedNoticeStatusReq", -1, &a->ns1__flaggedNoticeStatusReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__flaggedNoticeStatus * SOAP_FMAC4 soap_in___ns1__flaggedNoticeStatus(struct soap *soap, const char *tag, struct __ns1__flaggedNoticeStatus *a, const char *type)
{
	size_t soap_flag_ns1__flaggedNoticeStatusReq = 1;
	short soap_flag;
	a = (struct __ns1__flaggedNoticeStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__flaggedNoticeStatus, sizeof(struct __ns1__flaggedNoticeStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__flaggedNoticeStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__flaggedNoticeStatusReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__flaggedNoticeStatusReq(soap, "ns1:flaggedNoticeStatusReq", &a->ns1__flaggedNoticeStatusReq, ""))
				{	soap_flag_ns1__flaggedNoticeStatusReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__flaggedNoticeStatus(struct soap *soap, const struct __ns1__flaggedNoticeStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__flaggedNoticeStatus(soap, tag?tag:"-ns1:flaggedNoticeStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__flaggedNoticeStatus * SOAP_FMAC4 soap_get___ns1__flaggedNoticeStatus(struct soap *soap, struct __ns1__flaggedNoticeStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__flaggedNoticeStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryNotices(struct soap *soap, struct __ns1__queryNotices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryNoticesReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryNotices(struct soap *soap, const struct __ns1__queryNotices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryNoticesReq(soap, &a->ns1__queryNoticesReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryNotices(struct soap *soap, const char *tag, int id, const struct __ns1__queryNotices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryNoticesReq(soap, "ns1:queryNoticesReq", -1, &a->ns1__queryNoticesReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryNotices * SOAP_FMAC4 soap_in___ns1__queryNotices(struct soap *soap, const char *tag, struct __ns1__queryNotices *a, const char *type)
{
	size_t soap_flag_ns1__queryNoticesReq = 1;
	short soap_flag;
	a = (struct __ns1__queryNotices *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryNotices, sizeof(struct __ns1__queryNotices), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryNotices(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryNoticesReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryNoticesReq(soap, "ns1:queryNoticesReq", &a->ns1__queryNoticesReq, ""))
				{	soap_flag_ns1__queryNoticesReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryNotices(struct soap *soap, const struct __ns1__queryNotices *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryNotices(soap, tag?tag:"-ns1:queryNotices", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryNotices * SOAP_FMAC4 soap_get___ns1__queryNotices(struct soap *soap, struct __ns1__queryNotices *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryNotices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__trustedAuthorityLogin(struct soap *soap, struct __ns1__trustedAuthorityLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__trustedAuthorityLoginReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__trustedAuthorityLogin(struct soap *soap, const struct __ns1__trustedAuthorityLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__trustedAuthorityLoginReq(soap, &a->ns1__trustedAuthorityLoginReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__trustedAuthorityLogin(struct soap *soap, const char *tag, int id, const struct __ns1__trustedAuthorityLogin *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__trustedAuthorityLoginReq(soap, "ns1:trustedAuthorityLoginReq", -1, &a->ns1__trustedAuthorityLoginReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__trustedAuthorityLogin * SOAP_FMAC4 soap_in___ns1__trustedAuthorityLogin(struct soap *soap, const char *tag, struct __ns1__trustedAuthorityLogin *a, const char *type)
{
	size_t soap_flag_ns1__trustedAuthorityLoginReq = 1;
	short soap_flag;
	a = (struct __ns1__trustedAuthorityLogin *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__trustedAuthorityLogin, sizeof(struct __ns1__trustedAuthorityLogin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__trustedAuthorityLogin(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__trustedAuthorityLoginReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__trustedAuthorityLoginReq(soap, "ns1:trustedAuthorityLoginReq", &a->ns1__trustedAuthorityLoginReq, "ns1:trustedAuthorityLoginReq"))
				{	soap_flag_ns1__trustedAuthorityLoginReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__trustedAuthorityLogin(struct soap *soap, const struct __ns1__trustedAuthorityLogin *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__trustedAuthorityLogin(soap, tag?tag:"-ns1:trustedAuthorityLogin", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__trustedAuthorityLogin * SOAP_FMAC4 soap_get___ns1__trustedAuthorityLogin(struct soap *soap, struct __ns1__trustedAuthorityLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__trustedAuthorityLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDeviceMatchingResult(struct soap *soap, struct __ns1__getDeviceMatchingResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDeviceMatchingResultReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDeviceMatchingResult(struct soap *soap, const struct __ns1__getDeviceMatchingResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getDeviceMatchingResultReq(soap, &a->ns1__getDeviceMatchingResultReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDeviceMatchingResult(struct soap *soap, const char *tag, int id, const struct __ns1__getDeviceMatchingResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getDeviceMatchingResultReq(soap, "ns1:getDeviceMatchingResultReq", -1, &a->ns1__getDeviceMatchingResultReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDeviceMatchingResult * SOAP_FMAC4 soap_in___ns1__getDeviceMatchingResult(struct soap *soap, const char *tag, struct __ns1__getDeviceMatchingResult *a, const char *type)
{
	size_t soap_flag_ns1__getDeviceMatchingResultReq = 1;
	short soap_flag;
	a = (struct __ns1__getDeviceMatchingResult *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDeviceMatchingResult, sizeof(struct __ns1__getDeviceMatchingResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDeviceMatchingResult(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDeviceMatchingResultReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getDeviceMatchingResultReq(soap, "ns1:getDeviceMatchingResultReq", &a->ns1__getDeviceMatchingResultReq, ""))
				{	soap_flag_ns1__getDeviceMatchingResultReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDeviceMatchingResult(struct soap *soap, const struct __ns1__getDeviceMatchingResult *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDeviceMatchingResult(soap, tag?tag:"-ns1:getDeviceMatchingResult", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDeviceMatchingResult * SOAP_FMAC4 soap_get___ns1__getDeviceMatchingResult(struct soap *soap, struct __ns1__getDeviceMatchingResult *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDeviceMatchingResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDeviceMatchingCode(struct soap *soap, struct __ns1__getDeviceMatchingCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDeviceMatchingCodeReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDeviceMatchingCode(struct soap *soap, const struct __ns1__getDeviceMatchingCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getDeviceMatchingCodeReq(soap, &a->ns1__getDeviceMatchingCodeReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDeviceMatchingCode(struct soap *soap, const char *tag, int id, const struct __ns1__getDeviceMatchingCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getDeviceMatchingCodeReq(soap, "ns1:getDeviceMatchingCodeReq", -1, &a->ns1__getDeviceMatchingCodeReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDeviceMatchingCode * SOAP_FMAC4 soap_in___ns1__getDeviceMatchingCode(struct soap *soap, const char *tag, struct __ns1__getDeviceMatchingCode *a, const char *type)
{
	size_t soap_flag_ns1__getDeviceMatchingCodeReq = 1;
	short soap_flag;
	a = (struct __ns1__getDeviceMatchingCode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDeviceMatchingCode, sizeof(struct __ns1__getDeviceMatchingCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDeviceMatchingCode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDeviceMatchingCodeReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getDeviceMatchingCodeReq(soap, "ns1:getDeviceMatchingCodeReq", &a->ns1__getDeviceMatchingCodeReq, ""))
				{	soap_flag_ns1__getDeviceMatchingCodeReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDeviceMatchingCode(struct soap *soap, const struct __ns1__getDeviceMatchingCode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDeviceMatchingCode(soap, tag?tag:"-ns1:getDeviceMatchingCode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDeviceMatchingCode * SOAP_FMAC4 soap_get___ns1__getDeviceMatchingCode(struct soap *soap, struct __ns1__getDeviceMatchingCode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDeviceMatchingCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDynamicPassword(struct soap *soap, struct __ns1__getDynamicPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDynamicPasswordReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDynamicPassword(struct soap *soap, const struct __ns1__getDynamicPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getDynamicPasswordReq(soap, &a->ns1__getDynamicPasswordReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDynamicPassword(struct soap *soap, const char *tag, int id, const struct __ns1__getDynamicPassword *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getDynamicPasswordReq(soap, "ns1:getDynamicPasswordReq", -1, &a->ns1__getDynamicPasswordReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDynamicPassword * SOAP_FMAC4 soap_in___ns1__getDynamicPassword(struct soap *soap, const char *tag, struct __ns1__getDynamicPassword *a, const char *type)
{
	size_t soap_flag_ns1__getDynamicPasswordReq = 1;
	short soap_flag;
	a = (struct __ns1__getDynamicPassword *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDynamicPassword, sizeof(struct __ns1__getDynamicPassword), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDynamicPassword(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDynamicPasswordReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getDynamicPasswordReq(soap, "ns1:getDynamicPasswordReq", &a->ns1__getDynamicPasswordReq, ""))
				{	soap_flag_ns1__getDynamicPasswordReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDynamicPassword(struct soap *soap, const struct __ns1__getDynamicPassword *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDynamicPassword(soap, tag?tag:"-ns1:getDynamicPassword", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDynamicPassword * SOAP_FMAC4 soap_get___ns1__getDynamicPassword(struct soap *soap, struct __ns1__getDynamicPassword *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDynamicPassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getWirelessNetwork(struct soap *soap, struct __ns1__getWirelessNetwork *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getWirelessNetworkReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getWirelessNetwork(struct soap *soap, const struct __ns1__getWirelessNetwork *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getWirelessNetworkReq(soap, &a->ns1__getWirelessNetworkReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getWirelessNetwork(struct soap *soap, const char *tag, int id, const struct __ns1__getWirelessNetwork *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getWirelessNetworkReq(soap, "ns1:getWirelessNetworkReq", -1, &a->ns1__getWirelessNetworkReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getWirelessNetwork * SOAP_FMAC4 soap_in___ns1__getWirelessNetwork(struct soap *soap, const char *tag, struct __ns1__getWirelessNetwork *a, const char *type)
{
	size_t soap_flag_ns1__getWirelessNetworkReq = 1;
	short soap_flag;
	a = (struct __ns1__getWirelessNetwork *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getWirelessNetwork, sizeof(struct __ns1__getWirelessNetwork), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getWirelessNetwork(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getWirelessNetworkReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getWirelessNetworkReq(soap, "ns1:getWirelessNetworkReq", &a->ns1__getWirelessNetworkReq, ""))
				{	soap_flag_ns1__getWirelessNetworkReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getWirelessNetwork(struct soap *soap, const struct __ns1__getWirelessNetwork *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getWirelessNetwork(soap, tag?tag:"-ns1:getWirelessNetwork", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getWirelessNetwork * SOAP_FMAC4 soap_get___ns1__getWirelessNetwork(struct soap *soap, struct __ns1__getWirelessNetwork *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getWirelessNetwork(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setRelay(struct soap *soap, struct __ns1__setRelay *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setRelayReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setRelay(struct soap *soap, const struct __ns1__setRelay *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setRelayReq(soap, &a->ns1__setRelayReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setRelay(struct soap *soap, const char *tag, int id, const struct __ns1__setRelay *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setRelayReq(soap, "ns1:setRelayReq", -1, &a->ns1__setRelayReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setRelay * SOAP_FMAC4 soap_in___ns1__setRelay(struct soap *soap, const char *tag, struct __ns1__setRelay *a, const char *type)
{
	size_t soap_flag_ns1__setRelayReq = 1;
	short soap_flag;
	a = (struct __ns1__setRelay *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setRelay, sizeof(struct __ns1__setRelay), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setRelay(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setRelayReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setRelayReq(soap, "ns1:setRelayReq", &a->ns1__setRelayReq, ""))
				{	soap_flag_ns1__setRelayReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setRelay(struct soap *soap, const struct __ns1__setRelay *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setRelay(soap, tag?tag:"-ns1:setRelay", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setRelay * SOAP_FMAC4 soap_get___ns1__setRelay(struct soap *soap, struct __ns1__setRelay *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setRelay(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRelay(struct soap *soap, struct __ns1__getRelay *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getRelayReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRelay(struct soap *soap, const struct __ns1__getRelay *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getRelayReq(soap, &a->ns1__getRelayReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRelay(struct soap *soap, const char *tag, int id, const struct __ns1__getRelay *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getRelayReq(soap, "ns1:getRelayReq", -1, &a->ns1__getRelayReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRelay * SOAP_FMAC4 soap_in___ns1__getRelay(struct soap *soap, const char *tag, struct __ns1__getRelay *a, const char *type)
{
	size_t soap_flag_ns1__getRelayReq = 1;
	short soap_flag;
	a = (struct __ns1__getRelay *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRelay, sizeof(struct __ns1__getRelay), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRelay(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getRelayReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getRelayReq(soap, "ns1:getRelayReq", &a->ns1__getRelayReq, ""))
				{	soap_flag_ns1__getRelayReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRelay(struct soap *soap, const struct __ns1__getRelay *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getRelay(soap, tag?tag:"-ns1:getRelay", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRelay * SOAP_FMAC4 soap_get___ns1__getRelay(struct soap *soap, struct __ns1__getRelay *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRelay(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setRecordParam(struct soap *soap, struct __ns1__setRecordParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setRecordParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setRecordParam(struct soap *soap, const struct __ns1__setRecordParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setRecordParamReq(soap, &a->ns1__setRecordParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setRecordParam(struct soap *soap, const char *tag, int id, const struct __ns1__setRecordParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setRecordParamReq(soap, "ns1:setRecordParamReq", -1, &a->ns1__setRecordParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setRecordParam * SOAP_FMAC4 soap_in___ns1__setRecordParam(struct soap *soap, const char *tag, struct __ns1__setRecordParam *a, const char *type)
{
	size_t soap_flag_ns1__setRecordParamReq = 1;
	short soap_flag;
	a = (struct __ns1__setRecordParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setRecordParam, sizeof(struct __ns1__setRecordParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setRecordParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setRecordParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setRecordParamReq(soap, "ns1:setRecordParamReq", &a->ns1__setRecordParamReq, ""))
				{	soap_flag_ns1__setRecordParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setRecordParam(struct soap *soap, const struct __ns1__setRecordParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setRecordParam(soap, tag?tag:"-ns1:setRecordParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setRecordParam * SOAP_FMAC4 soap_get___ns1__setRecordParam(struct soap *soap, struct __ns1__setRecordParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setRecordParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRecordParam(struct soap *soap, struct __ns1__getRecordParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getRecordParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRecordParam(struct soap *soap, const struct __ns1__getRecordParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getRecordParamReq(soap, &a->ns1__getRecordParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRecordParam(struct soap *soap, const char *tag, int id, const struct __ns1__getRecordParam *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getRecordParamReq(soap, "ns1:getRecordParamReq", -1, &a->ns1__getRecordParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRecordParam * SOAP_FMAC4 soap_in___ns1__getRecordParam(struct soap *soap, const char *tag, struct __ns1__getRecordParam *a, const char *type)
{
	size_t soap_flag_ns1__getRecordParamReq = 1;
	short soap_flag;
	a = (struct __ns1__getRecordParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRecordParam, sizeof(struct __ns1__getRecordParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRecordParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getRecordParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getRecordParamReq(soap, "ns1:getRecordParamReq", &a->ns1__getRecordParamReq, ""))
				{	soap_flag_ns1__getRecordParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRecordParam(struct soap *soap, const struct __ns1__getRecordParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getRecordParam(soap, tag?tag:"-ns1:getRecordParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRecordParam * SOAP_FMAC4 soap_get___ns1__getRecordParam(struct soap *soap, struct __ns1__getRecordParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRecordParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setPushWorkSheet(struct soap *soap, struct __ns1__setPushWorkSheet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setPushWorkSheetReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setPushWorkSheet(struct soap *soap, const struct __ns1__setPushWorkSheet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setPushWorkSheetReq(soap, &a->ns1__setPushWorkSheetReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setPushWorkSheet(struct soap *soap, const char *tag, int id, const struct __ns1__setPushWorkSheet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setPushWorkSheetReq(soap, "ns1:setPushWorkSheetReq", -1, &a->ns1__setPushWorkSheetReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPushWorkSheet * SOAP_FMAC4 soap_in___ns1__setPushWorkSheet(struct soap *soap, const char *tag, struct __ns1__setPushWorkSheet *a, const char *type)
{
	size_t soap_flag_ns1__setPushWorkSheetReq = 1;
	short soap_flag;
	a = (struct __ns1__setPushWorkSheet *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setPushWorkSheet, sizeof(struct __ns1__setPushWorkSheet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setPushWorkSheet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setPushWorkSheetReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setPushWorkSheetReq(soap, "ns1:setPushWorkSheetReq", &a->ns1__setPushWorkSheetReq, ""))
				{	soap_flag_ns1__setPushWorkSheetReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setPushWorkSheet(struct soap *soap, const struct __ns1__setPushWorkSheet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setPushWorkSheet(soap, tag?tag:"-ns1:setPushWorkSheet", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPushWorkSheet * SOAP_FMAC4 soap_get___ns1__setPushWorkSheet(struct soap *soap, struct __ns1__setPushWorkSheet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setPushWorkSheet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPushWorkSheet(struct soap *soap, struct __ns1__getPushWorkSheet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPushWorkSheetReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPushWorkSheet(struct soap *soap, const struct __ns1__getPushWorkSheet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getPushWorkSheetReq(soap, &a->ns1__getPushWorkSheetReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPushWorkSheet(struct soap *soap, const char *tag, int id, const struct __ns1__getPushWorkSheet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getPushWorkSheetReq(soap, "ns1:getPushWorkSheetReq", -1, &a->ns1__getPushWorkSheetReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPushWorkSheet * SOAP_FMAC4 soap_in___ns1__getPushWorkSheet(struct soap *soap, const char *tag, struct __ns1__getPushWorkSheet *a, const char *type)
{
	size_t soap_flag_ns1__getPushWorkSheetReq = 1;
	short soap_flag;
	a = (struct __ns1__getPushWorkSheet *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPushWorkSheet, sizeof(struct __ns1__getPushWorkSheet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPushWorkSheet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPushWorkSheetReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getPushWorkSheetReq(soap, "ns1:getPushWorkSheetReq", &a->ns1__getPushWorkSheetReq, ""))
				{	soap_flag_ns1__getPushWorkSheetReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPushWorkSheet(struct soap *soap, const struct __ns1__getPushWorkSheet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPushWorkSheet(soap, tag?tag:"-ns1:getPushWorkSheet", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPushWorkSheet * SOAP_FMAC4 soap_get___ns1__getPushWorkSheet(struct soap *soap, struct __ns1__getPushWorkSheet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPushWorkSheet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__subscribeAndroidPush(struct soap *soap, struct __ns1__subscribeAndroidPush *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__subscribeAndroidPushReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__subscribeAndroidPush(struct soap *soap, const struct __ns1__subscribeAndroidPush *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__subscribeAndroidPushReq(soap, &a->ns1__subscribeAndroidPushReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__subscribeAndroidPush(struct soap *soap, const char *tag, int id, const struct __ns1__subscribeAndroidPush *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__subscribeAndroidPushReq(soap, "ns1:subscribeAndroidPushReq", -1, &a->ns1__subscribeAndroidPushReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__subscribeAndroidPush * SOAP_FMAC4 soap_in___ns1__subscribeAndroidPush(struct soap *soap, const char *tag, struct __ns1__subscribeAndroidPush *a, const char *type)
{
	size_t soap_flag_ns1__subscribeAndroidPushReq = 1;
	short soap_flag;
	a = (struct __ns1__subscribeAndroidPush *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__subscribeAndroidPush, sizeof(struct __ns1__subscribeAndroidPush), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__subscribeAndroidPush(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__subscribeAndroidPushReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__subscribeAndroidPushReq(soap, "ns1:subscribeAndroidPushReq", &a->ns1__subscribeAndroidPushReq, ""))
				{	soap_flag_ns1__subscribeAndroidPushReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__subscribeAndroidPush(struct soap *soap, const struct __ns1__subscribeAndroidPush *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__subscribeAndroidPush(soap, tag?tag:"-ns1:subscribeAndroidPush", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__subscribeAndroidPush * SOAP_FMAC4 soap_get___ns1__subscribeAndroidPush(struct soap *soap, struct __ns1__subscribeAndroidPush *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__subscribeAndroidPush(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__subscribeApplePush(struct soap *soap, struct __ns1__subscribeApplePush *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__subscribeApplePushReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__subscribeApplePush(struct soap *soap, const struct __ns1__subscribeApplePush *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__subscribeApplePushReq(soap, &a->ns1__subscribeApplePushReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__subscribeApplePush(struct soap *soap, const char *tag, int id, const struct __ns1__subscribeApplePush *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__subscribeApplePushReq(soap, "ns1:subscribeApplePushReq", -1, &a->ns1__subscribeApplePushReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__subscribeApplePush * SOAP_FMAC4 soap_in___ns1__subscribeApplePush(struct soap *soap, const char *tag, struct __ns1__subscribeApplePush *a, const char *type)
{
	size_t soap_flag_ns1__subscribeApplePushReq = 1;
	short soap_flag;
	a = (struct __ns1__subscribeApplePush *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__subscribeApplePush, sizeof(struct __ns1__subscribeApplePush), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__subscribeApplePush(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__subscribeApplePushReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__subscribeApplePushReq(soap, "ns1:subscribeApplePushReq", &a->ns1__subscribeApplePushReq, ""))
				{	soap_flag_ns1__subscribeApplePushReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__subscribeApplePush(struct soap *soap, const struct __ns1__subscribeApplePush *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__subscribeApplePush(soap, tag?tag:"-ns1:subscribeApplePush", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__subscribeApplePush * SOAP_FMAC4 soap_get___ns1__subscribeApplePush(struct soap *soap, struct __ns1__subscribeApplePush *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__subscribeApplePush(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__vodSearchRes(struct soap *soap, struct _ns1__vodSearchRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_int(soap, &a->PageNo);
	soap_default_int(soap, &a->PageCount);
	soap_default_int(soap, &a->RecordCount);
	a->__sizeRecord = 0;
	a->Record = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__vodSearchRes(struct soap *soap, const struct _ns1__vodSearchRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->PageNo, SOAP_TYPE_int);
	soap_embedded(soap, &a->PageCount, SOAP_TYPE_int);
	soap_embedded(soap, &a->RecordCount, SOAP_TYPE_int);
	if (a->Record)
	{	int i;
		for (i = 0; i < a->__sizeRecord; i++)
		{
			soap_embedded(soap, a->Record + i, SOAP_TYPE_ns1__VODRecord);
			soap_serialize_ns1__VODRecord(soap, a->Record + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__vodSearchRes(struct soap *soap, const char *tag, int id, const struct _ns1__vodSearchRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__vodSearchRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PageNo", -1, &a->PageNo, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PageCount", -1, &a->PageCount, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:RecordCount", -1, &a->RecordCount, ""))
		return soap->error;
	if (a->Record)
	{	int i;
		for (i = 0; i < a->__sizeRecord; i++)
			if (soap_out_ns1__VODRecord(soap, "ns1:Record", -1, a->Record + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__vodSearchRes * SOAP_FMAC4 soap_in__ns1__vodSearchRes(struct soap *soap, const char *tag, struct _ns1__vodSearchRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_PageNo = 1;
	size_t soap_flag_PageCount = 1;
	size_t soap_flag_RecordCount = 1;
	struct soap_blist *soap_blist_Record = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__vodSearchRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__vodSearchRes, sizeof(struct _ns1__vodSearchRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__vodSearchRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_PageNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PageNo", &a->PageNo, "xsd:int"))
				{	soap_flag_PageNo--;
					continue;
				}
			if (soap_flag_PageCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PageCount", &a->PageCount, "xsd:int"))
				{	soap_flag_PageCount--;
					continue;
				}
			if (soap_flag_RecordCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:RecordCount", &a->RecordCount, "xsd:int"))
				{	soap_flag_RecordCount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Record", 1, NULL))
			{	if (a->Record == NULL)
				{	if (soap_blist_Record == NULL)
						soap_blist_Record = soap_new_block(soap);
					a->Record = (struct ns1__VODRecord *)soap_push_block(soap, soap_blist_Record, sizeof(struct ns1__VODRecord));
					if (a->Record == NULL)
						return NULL;
					soap_default_ns1__VODRecord(soap, a->Record);
				}
				soap_revert(soap);
				if (soap_in_ns1__VODRecord(soap, "ns1:Record", a->Record, "ns1:VODRecord"))
				{	a->__sizeRecord++;
					a->Record = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Record)
			soap_pop_block(soap, soap_blist_Record);
		if (a->__sizeRecord)
			a->Record = (struct ns1__VODRecord *)soap_save_block(soap, soap_blist_Record, NULL, 1);
		else
		{	a->Record = NULL;
			if (soap_blist_Record)
				soap_end_block(soap, soap_blist_Record);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__vodSearchRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__vodSearchRes, 0, sizeof(struct _ns1__vodSearchRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_PageNo > 0 || soap_flag_PageCount > 0 || soap_flag_RecordCount > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__vodSearchRes(struct soap *soap, const struct _ns1__vodSearchRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__vodSearchRes);
	if (soap_out__ns1__vodSearchRes(soap, tag?tag:"ns1:vodSearchRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__vodSearchRes * SOAP_FMAC4 soap_get__ns1__vodSearchRes(struct soap *soap, struct _ns1__vodSearchRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__vodSearchRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__vodSearchReq(struct soap *soap, struct _ns1__vodSearchReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__StreamType(soap, &a->StreamType);
	soap_default_time(soap, &a->StartTime);
	soap_default_time(soap, &a->EndTime);
	a->PageNo = NULL;
	soap_default_string(soap, &a->SearchID);
	a->PageSize = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__vodSearchReq(struct soap *soap, const struct _ns1__vodSearchReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_embedded(soap, &a->StartTime, SOAP_TYPE_time);
	soap_embedded(soap, &a->EndTime, SOAP_TYPE_time);
	soap_serialize_PointerToint(soap, &a->PageNo);
	soap_serialize_string(soap, &a->SearchID);
	soap_serialize_PointerToint(soap, &a->PageSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__vodSearchReq(struct soap *soap, const char *tag, int id, const struct _ns1__vodSearchReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__vodSearchReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__StreamType(soap, "ns1:StreamType", -1, &a->StreamType, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:StartTime", -1, &a->StartTime, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:EndTime", -1, &a->EndTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:PageNo", -1, &a->PageNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SearchID", -1, &a->SearchID, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:PageSize", -1, &a->PageSize, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__vodSearchReq * SOAP_FMAC4 soap_in__ns1__vodSearchReq(struct soap *soap, const char *tag, struct _ns1__vodSearchReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_StreamType = 1;
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_EndTime = 1;
	size_t soap_flag_PageNo = 1;
	size_t soap_flag_SearchID = 1;
	size_t soap_flag_PageSize = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__vodSearchReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__vodSearchReq, sizeof(struct _ns1__vodSearchReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__vodSearchReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_StreamType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StreamType(soap, "ns1:StreamType", &a->StreamType, "ns1:StreamType"))
				{	soap_flag_StreamType--;
					continue;
				}
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:StartTime", &a->StartTime, "xsd:dateTime"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_EndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:EndTime", &a->EndTime, "xsd:dateTime"))
				{	soap_flag_EndTime--;
					continue;
				}
			if (soap_flag_PageNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:PageNo", &a->PageNo, "xsd:int"))
				{	soap_flag_PageNo--;
					continue;
				}
			if (soap_flag_SearchID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SearchID", &a->SearchID, "xsd:string"))
				{	soap_flag_SearchID--;
					continue;
				}
			if (soap_flag_PageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:PageSize", &a->PageSize, "xsd:int"))
				{	soap_flag_PageSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__vodSearchReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__vodSearchReq, 0, sizeof(struct _ns1__vodSearchReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_StreamType > 0 || soap_flag_StartTime > 0 || soap_flag_EndTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__vodSearchReq(struct soap *soap, const struct _ns1__vodSearchReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__vodSearchReq);
	if (soap_out__ns1__vodSearchReq(soap, tag?tag:"ns1:vodSearchReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__vodSearchReq * SOAP_FMAC4 soap_get__ns1__vodSearchReq(struct soap *soap, struct _ns1__vodSearchReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__vodSearchReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVODUrlRes(struct soap *soap, struct _ns1__getVODUrlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->VideoVODUrl);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVODUrlRes(struct soap *soap, const struct _ns1__getVODUrlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VideoVODUrl);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVODUrlRes(struct soap *soap, const char *tag, int id, const struct _ns1__getVODUrlRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVODUrlRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:VideoVODUrl", -1, &a->VideoVODUrl, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVODUrlRes * SOAP_FMAC4 soap_in__ns1__getVODUrlRes(struct soap *soap, const char *tag, struct _ns1__getVODUrlRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_VideoVODUrl = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVODUrlRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVODUrlRes, sizeof(struct _ns1__getVODUrlRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVODUrlRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_VideoVODUrl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:VideoVODUrl", &a->VideoVODUrl, "xsd:string"))
				{	soap_flag_VideoVODUrl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVODUrlRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVODUrlRes, 0, sizeof(struct _ns1__getVODUrlRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVODUrlRes(struct soap *soap, const struct _ns1__getVODUrlRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVODUrlRes);
	if (soap_out__ns1__getVODUrlRes(soap, tag?tag:"ns1:getVODUrlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVODUrlRes * SOAP_FMAC4 soap_get__ns1__getVODUrlRes(struct soap *soap, struct _ns1__getVODUrlRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVODUrlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVODUrlReq(struct soap *soap, struct _ns1__getVODUrlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__StreamType(soap, &a->StreamType);
	soap_default_time(soap, &a->StartTime);
	soap_default_time(soap, &a->EndTime);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVODUrlReq(struct soap *soap, const struct _ns1__getVODUrlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_embedded(soap, &a->StartTime, SOAP_TYPE_time);
	soap_embedded(soap, &a->EndTime, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVODUrlReq(struct soap *soap, const char *tag, int id, const struct _ns1__getVODUrlReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVODUrlReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__StreamType(soap, "ns1:StreamType", -1, &a->StreamType, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:StartTime", -1, &a->StartTime, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:EndTime", -1, &a->EndTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVODUrlReq * SOAP_FMAC4 soap_in__ns1__getVODUrlReq(struct soap *soap, const char *tag, struct _ns1__getVODUrlReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_StreamType = 1;
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_EndTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVODUrlReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVODUrlReq, sizeof(struct _ns1__getVODUrlReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVODUrlReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_StreamType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StreamType(soap, "ns1:StreamType", &a->StreamType, "ns1:StreamType"))
				{	soap_flag_StreamType--;
					continue;
				}
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:StartTime", &a->StartTime, "xsd:dateTime"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_EndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:EndTime", &a->EndTime, "xsd:dateTime"))
				{	soap_flag_EndTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVODUrlReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVODUrlReq, 0, sizeof(struct _ns1__getVODUrlReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_StreamType > 0 || soap_flag_StartTime > 0 || soap_flag_EndTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVODUrlReq(struct soap *soap, const struct _ns1__getVODUrlReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVODUrlReq);
	if (soap_out__ns1__getVODUrlReq(soap, tag?tag:"ns1:getVODUrlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVODUrlReq * SOAP_FMAC4 soap_get__ns1__getVODUrlReq(struct soap *soap, struct _ns1__getVODUrlReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVODUrlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPlayUrlRes(struct soap *soap, struct _ns1__getPlayUrlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->AOR);
	soap_default_string(soap, &a->ProxyUri);
	soap_default_string(soap, &a->ContactUri);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPlayUrlRes(struct soap *soap, const struct _ns1__getPlayUrlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->AOR);
	soap_serialize_string(soap, &a->ProxyUri);
	soap_serialize_string(soap, &a->ContactUri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPlayUrlRes(struct soap *soap, const char *tag, int id, const struct _ns1__getPlayUrlRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPlayUrlRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:AOR", -1, &a->AOR, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ProxyUri", -1, &a->ProxyUri, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ContactUri", -1, &a->ContactUri, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPlayUrlRes * SOAP_FMAC4 soap_in__ns1__getPlayUrlRes(struct soap *soap, const char *tag, struct _ns1__getPlayUrlRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_AOR = 1;
	size_t soap_flag_ProxyUri = 1;
	size_t soap_flag_ContactUri = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPlayUrlRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPlayUrlRes, sizeof(struct _ns1__getPlayUrlRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPlayUrlRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_AOR && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AOR", &a->AOR, "xsd:string"))
				{	soap_flag_AOR--;
					continue;
				}
			if (soap_flag_ProxyUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ProxyUri", &a->ProxyUri, "xsd:string"))
				{	soap_flag_ProxyUri--;
					continue;
				}
			if (soap_flag_ContactUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ContactUri", &a->ContactUri, "xsd:string"))
				{	soap_flag_ContactUri--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPlayUrlRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPlayUrlRes, 0, sizeof(struct _ns1__getPlayUrlRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPlayUrlRes(struct soap *soap, const struct _ns1__getPlayUrlRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPlayUrlRes);
	if (soap_out__ns1__getPlayUrlRes(soap, tag?tag:"ns1:getPlayUrlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPlayUrlRes * SOAP_FMAC4 soap_get__ns1__getPlayUrlRes(struct soap *soap, struct _ns1__getPlayUrlRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPlayUrlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPlayUrlReq(struct soap *soap, struct _ns1__getPlayUrlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__StreamType(soap, &a->StreamType);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPlayUrlReq(struct soap *soap, const struct _ns1__getPlayUrlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPlayUrlReq(struct soap *soap, const char *tag, int id, const struct _ns1__getPlayUrlReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPlayUrlReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__StreamType(soap, "ns1:StreamType", -1, &a->StreamType, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPlayUrlReq * SOAP_FMAC4 soap_in__ns1__getPlayUrlReq(struct soap *soap, const char *tag, struct _ns1__getPlayUrlReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_StreamType = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPlayUrlReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPlayUrlReq, sizeof(struct _ns1__getPlayUrlReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPlayUrlReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_StreamType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StreamType(soap, "ns1:StreamType", &a->StreamType, "ns1:StreamType"))
				{	soap_flag_StreamType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPlayUrlReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPlayUrlReq, 0, sizeof(struct _ns1__getPlayUrlReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_StreamType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPlayUrlReq(struct soap *soap, const struct _ns1__getPlayUrlReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPlayUrlReq);
	if (soap_out__ns1__getPlayUrlReq(soap, tag?tag:"ns1:getPlayUrlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPlayUrlReq * SOAP_FMAC4 soap_get__ns1__getPlayUrlReq(struct soap *soap, struct _ns1__getPlayUrlReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPlayUrlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setPrivacyMaskParamRes(struct soap *soap, struct _ns1__setPrivacyMaskParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setPrivacyMaskParamRes(struct soap *soap, const struct _ns1__setPrivacyMaskParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setPrivacyMaskParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__setPrivacyMaskParamRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setPrivacyMaskParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamRes * SOAP_FMAC4 soap_in__ns1__setPrivacyMaskParamRes(struct soap *soap, const char *tag, struct _ns1__setPrivacyMaskParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setPrivacyMaskParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setPrivacyMaskParamRes, sizeof(struct _ns1__setPrivacyMaskParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setPrivacyMaskParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPrivacyMaskParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setPrivacyMaskParamRes, 0, sizeof(struct _ns1__setPrivacyMaskParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setPrivacyMaskParamRes(struct soap *soap, const struct _ns1__setPrivacyMaskParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setPrivacyMaskParamRes);
	if (soap_out__ns1__setPrivacyMaskParamRes(soap, tag?tag:"ns1:setPrivacyMaskParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamRes * SOAP_FMAC4 soap_get__ns1__setPrivacyMaskParamRes(struct soap *soap, struct _ns1__setPrivacyMaskParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setPrivacyMaskParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setPrivacyMaskParamReq(struct soap *soap, struct _ns1__setPrivacyMaskParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->Enabled = NULL;
	a->__sizeRegion = 0;
	a->Region = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setPrivacyMaskParamReq(struct soap *soap, const struct _ns1__setPrivacyMaskParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	if (a->Region)
	{	int i;
		for (i = 0; i < a->__sizeRegion; i++)
		{
			soap_embedded(soap, a->Region + i, SOAP_TYPE_ns1__PrivacyMaskRegion);
			soap_serialize_ns1__PrivacyMaskRegion(soap, a->Region + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setPrivacyMaskParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__setPrivacyMaskParamReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setPrivacyMaskParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Region)
	{	int i;
		for (i = 0; i < a->__sizeRegion; i++)
			if (soap_out_ns1__PrivacyMaskRegion(soap, "ns1:Region", -1, a->Region + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamReq * SOAP_FMAC4 soap_in__ns1__setPrivacyMaskParamReq(struct soap *soap, const char *tag, struct _ns1__setPrivacyMaskParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_Enabled = 1;
	struct soap_blist *soap_blist_Region = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setPrivacyMaskParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setPrivacyMaskParamReq, sizeof(struct _ns1__setPrivacyMaskParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setPrivacyMaskParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Region", 1, NULL))
			{	if (a->Region == NULL)
				{	if (soap_blist_Region == NULL)
						soap_blist_Region = soap_new_block(soap);
					a->Region = (struct ns1__PrivacyMaskRegion *)soap_push_block(soap, soap_blist_Region, sizeof(struct ns1__PrivacyMaskRegion));
					if (a->Region == NULL)
						return NULL;
					soap_default_ns1__PrivacyMaskRegion(soap, a->Region);
				}
				soap_revert(soap);
				if (soap_in_ns1__PrivacyMaskRegion(soap, "ns1:Region", a->Region, "ns1:PrivacyMaskRegion"))
				{	a->__sizeRegion++;
					a->Region = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Region)
			soap_pop_block(soap, soap_blist_Region);
		if (a->__sizeRegion)
			a->Region = (struct ns1__PrivacyMaskRegion *)soap_save_block(soap, soap_blist_Region, NULL, 1);
		else
		{	a->Region = NULL;
			if (soap_blist_Region)
				soap_end_block(soap, soap_blist_Region);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPrivacyMaskParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setPrivacyMaskParamReq, 0, sizeof(struct _ns1__setPrivacyMaskParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setPrivacyMaskParamReq(struct soap *soap, const struct _ns1__setPrivacyMaskParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setPrivacyMaskParamReq);
	if (soap_out__ns1__setPrivacyMaskParamReq(soap, tag?tag:"ns1:setPrivacyMaskParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamReq * SOAP_FMAC4 soap_get__ns1__setPrivacyMaskParamReq(struct soap *soap, struct _ns1__setPrivacyMaskParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setPrivacyMaskParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPrivacyMaskParamRes(struct soap *soap, struct _ns1__getPrivacyMaskParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->Enabled = NULL;
	a->HorizontalResolution = NULL;
	a->VerticalResolution = NULL;
	a->__sizeRegion = 0;
	a->Region = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPrivacyMaskParamRes(struct soap *soap, const struct _ns1__getPrivacyMaskParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_PointerToint(soap, &a->HorizontalResolution);
	soap_serialize_PointerToint(soap, &a->VerticalResolution);
	if (a->Region)
	{	int i;
		for (i = 0; i < a->__sizeRegion; i++)
		{
			soap_embedded(soap, a->Region + i, SOAP_TYPE_ns1__PrivacyMaskRegion);
			soap_serialize_ns1__PrivacyMaskRegion(soap, a->Region + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPrivacyMaskParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__getPrivacyMaskParamRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPrivacyMaskParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:HorizontalResolution", -1, &a->HorizontalResolution, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:VerticalResolution", -1, &a->VerticalResolution, ""))
		return soap->error;
	if (a->Region)
	{	int i;
		for (i = 0; i < a->__sizeRegion; i++)
			if (soap_out_ns1__PrivacyMaskRegion(soap, "ns1:Region", -1, a->Region + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamRes * SOAP_FMAC4 soap_in__ns1__getPrivacyMaskParamRes(struct soap *soap, const char *tag, struct _ns1__getPrivacyMaskParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_HorizontalResolution = 1;
	size_t soap_flag_VerticalResolution = 1;
	struct soap_blist *soap_blist_Region = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPrivacyMaskParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPrivacyMaskParamRes, sizeof(struct _ns1__getPrivacyMaskParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPrivacyMaskParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_HorizontalResolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:HorizontalResolution", &a->HorizontalResolution, "xsd:int"))
				{	soap_flag_HorizontalResolution--;
					continue;
				}
			if (soap_flag_VerticalResolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:VerticalResolution", &a->VerticalResolution, "xsd:int"))
				{	soap_flag_VerticalResolution--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Region", 1, NULL))
			{	if (a->Region == NULL)
				{	if (soap_blist_Region == NULL)
						soap_blist_Region = soap_new_block(soap);
					a->Region = (struct ns1__PrivacyMaskRegion *)soap_push_block(soap, soap_blist_Region, sizeof(struct ns1__PrivacyMaskRegion));
					if (a->Region == NULL)
						return NULL;
					soap_default_ns1__PrivacyMaskRegion(soap, a->Region);
				}
				soap_revert(soap);
				if (soap_in_ns1__PrivacyMaskRegion(soap, "ns1:Region", a->Region, "ns1:PrivacyMaskRegion"))
				{	a->__sizeRegion++;
					a->Region = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Region)
			soap_pop_block(soap, soap_blist_Region);
		if (a->__sizeRegion)
			a->Region = (struct ns1__PrivacyMaskRegion *)soap_save_block(soap, soap_blist_Region, NULL, 1);
		else
		{	a->Region = NULL;
			if (soap_blist_Region)
				soap_end_block(soap, soap_blist_Region);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPrivacyMaskParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPrivacyMaskParamRes, 0, sizeof(struct _ns1__getPrivacyMaskParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPrivacyMaskParamRes(struct soap *soap, const struct _ns1__getPrivacyMaskParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPrivacyMaskParamRes);
	if (soap_out__ns1__getPrivacyMaskParamRes(soap, tag?tag:"ns1:getPrivacyMaskParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamRes * SOAP_FMAC4 soap_get__ns1__getPrivacyMaskParamRes(struct soap *soap, struct _ns1__getPrivacyMaskParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPrivacyMaskParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPrivacyMaskParamReq(struct soap *soap, struct _ns1__getPrivacyMaskParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPrivacyMaskParamReq(struct soap *soap, const struct _ns1__getPrivacyMaskParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPrivacyMaskParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__getPrivacyMaskParamReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPrivacyMaskParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamReq * SOAP_FMAC4 soap_in__ns1__getPrivacyMaskParamReq(struct soap *soap, const char *tag, struct _ns1__getPrivacyMaskParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPrivacyMaskParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPrivacyMaskParamReq, sizeof(struct _ns1__getPrivacyMaskParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPrivacyMaskParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPrivacyMaskParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPrivacyMaskParamReq, 0, sizeof(struct _ns1__getPrivacyMaskParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPrivacyMaskParamReq(struct soap *soap, const struct _ns1__getPrivacyMaskParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPrivacyMaskParamReq);
	if (soap_out__ns1__getPrivacyMaskParamReq(soap, tag?tag:"ns1:getPrivacyMaskParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamReq * SOAP_FMAC4 soap_get__ns1__getPrivacyMaskParamReq(struct soap *soap, struct _ns1__getPrivacyMaskParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPrivacyMaskParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setVMDParamRes(struct soap *soap, struct _ns1__setVMDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setVMDParamRes(struct soap *soap, const struct _ns1__setVMDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setVMDParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__setVMDParamRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setVMDParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setVMDParamRes * SOAP_FMAC4 soap_in__ns1__setVMDParamRes(struct soap *soap, const char *tag, struct _ns1__setVMDParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setVMDParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setVMDParamRes, sizeof(struct _ns1__setVMDParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setVMDParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVMDParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setVMDParamRes, 0, sizeof(struct _ns1__setVMDParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setVMDParamRes(struct soap *soap, const struct _ns1__setVMDParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setVMDParamRes);
	if (soap_out__ns1__setVMDParamRes(soap, tag?tag:"ns1:setVMDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVMDParamRes * SOAP_FMAC4 soap_get__ns1__setVMDParamRes(struct soap *soap, struct _ns1__setVMDParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setVMDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setVMDParamReq(struct soap *soap, struct _ns1__setVMDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->Enabled = NULL;
	a->Sensitivity = NULL;
	a->StartTriggerTime = NULL;
	a->EndTriggerTime = NULL;
	a->Grid = NULL;
	a->WorkSheet = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setVMDParamReq(struct soap *soap, const struct _ns1__setVMDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_PointerToint(soap, &a->Sensitivity);
	soap_serialize_PointerToint(soap, &a->StartTriggerTime);
	soap_serialize_PointerToint(soap, &a->EndTriggerTime);
	soap_serialize_PointerTons1__VMDGrid(soap, &a->Grid);
	soap_serialize_PointerTons1__WorkSheet(soap, &a->WorkSheet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setVMDParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__setVMDParamReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setVMDParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Sensitivity", -1, &a->Sensitivity, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:StartTriggerTime", -1, &a->StartTriggerTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:EndTriggerTime", -1, &a->EndTriggerTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__VMDGrid(soap, "ns1:Grid", -1, &a->Grid, ""))
		return soap->error;
	if (soap_out_PointerTons1__WorkSheet(soap, "ns1:WorkSheet", -1, &a->WorkSheet, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setVMDParamReq * SOAP_FMAC4 soap_in__ns1__setVMDParamReq(struct soap *soap, const char *tag, struct _ns1__setVMDParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Sensitivity = 1;
	size_t soap_flag_StartTriggerTime = 1;
	size_t soap_flag_EndTriggerTime = 1;
	size_t soap_flag_Grid = 1;
	size_t soap_flag_WorkSheet = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setVMDParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setVMDParamReq, sizeof(struct _ns1__setVMDParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setVMDParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Sensitivity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Sensitivity", &a->Sensitivity, "xsd:int"))
				{	soap_flag_Sensitivity--;
					continue;
				}
			if (soap_flag_StartTriggerTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:StartTriggerTime", &a->StartTriggerTime, "xsd:int"))
				{	soap_flag_StartTriggerTime--;
					continue;
				}
			if (soap_flag_EndTriggerTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:EndTriggerTime", &a->EndTriggerTime, "xsd:int"))
				{	soap_flag_EndTriggerTime--;
					continue;
				}
			if (soap_flag_Grid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__VMDGrid(soap, "ns1:Grid", &a->Grid, "ns1:VMDGrid"))
				{	soap_flag_Grid--;
					continue;
				}
			if (soap_flag_WorkSheet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__WorkSheet(soap, "ns1:WorkSheet", &a->WorkSheet, "ns1:WorkSheet"))
				{	soap_flag_WorkSheet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVMDParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setVMDParamReq, 0, sizeof(struct _ns1__setVMDParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setVMDParamReq(struct soap *soap, const struct _ns1__setVMDParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setVMDParamReq);
	if (soap_out__ns1__setVMDParamReq(soap, tag?tag:"ns1:setVMDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVMDParamReq * SOAP_FMAC4 soap_get__ns1__setVMDParamReq(struct soap *soap, struct _ns1__setVMDParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setVMDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVMDParamRes(struct soap *soap, struct _ns1__getVMDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->Enabled = NULL;
	a->Sensitivity = NULL;
	a->StartTriggerTime = NULL;
	a->EndTriggerTime = NULL;
	a->RowGranularity = NULL;
	a->ColumnGranularity = NULL;
	a->Grid = NULL;
	a->WorkSheet = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVMDParamRes(struct soap *soap, const struct _ns1__getVMDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_PointerToint(soap, &a->Sensitivity);
	soap_serialize_PointerToint(soap, &a->StartTriggerTime);
	soap_serialize_PointerToint(soap, &a->EndTriggerTime);
	soap_serialize_PointerToint(soap, &a->RowGranularity);
	soap_serialize_PointerToint(soap, &a->ColumnGranularity);
	soap_serialize_PointerTons1__VMDGrid(soap, &a->Grid);
	soap_serialize_PointerTons1__WorkSheet(soap, &a->WorkSheet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVMDParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__getVMDParamRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVMDParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Sensitivity", -1, &a->Sensitivity, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:StartTriggerTime", -1, &a->StartTriggerTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:EndTriggerTime", -1, &a->EndTriggerTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:RowGranularity", -1, &a->RowGranularity, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ColumnGranularity", -1, &a->ColumnGranularity, ""))
		return soap->error;
	if (soap_out_PointerTons1__VMDGrid(soap, "ns1:Grid", -1, &a->Grid, ""))
		return soap->error;
	if (soap_out_PointerTons1__WorkSheet(soap, "ns1:WorkSheet", -1, &a->WorkSheet, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVMDParamRes * SOAP_FMAC4 soap_in__ns1__getVMDParamRes(struct soap *soap, const char *tag, struct _ns1__getVMDParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Sensitivity = 1;
	size_t soap_flag_StartTriggerTime = 1;
	size_t soap_flag_EndTriggerTime = 1;
	size_t soap_flag_RowGranularity = 1;
	size_t soap_flag_ColumnGranularity = 1;
	size_t soap_flag_Grid = 1;
	size_t soap_flag_WorkSheet = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVMDParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVMDParamRes, sizeof(struct _ns1__getVMDParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVMDParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Sensitivity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Sensitivity", &a->Sensitivity, "xsd:int"))
				{	soap_flag_Sensitivity--;
					continue;
				}
			if (soap_flag_StartTriggerTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:StartTriggerTime", &a->StartTriggerTime, "xsd:int"))
				{	soap_flag_StartTriggerTime--;
					continue;
				}
			if (soap_flag_EndTriggerTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:EndTriggerTime", &a->EndTriggerTime, "xsd:int"))
				{	soap_flag_EndTriggerTime--;
					continue;
				}
			if (soap_flag_RowGranularity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:RowGranularity", &a->RowGranularity, "xsd:int"))
				{	soap_flag_RowGranularity--;
					continue;
				}
			if (soap_flag_ColumnGranularity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:ColumnGranularity", &a->ColumnGranularity, "xsd:int"))
				{	soap_flag_ColumnGranularity--;
					continue;
				}
			if (soap_flag_Grid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__VMDGrid(soap, "ns1:Grid", &a->Grid, "ns1:VMDGrid"))
				{	soap_flag_Grid--;
					continue;
				}
			if (soap_flag_WorkSheet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__WorkSheet(soap, "ns1:WorkSheet", &a->WorkSheet, "ns1:WorkSheet"))
				{	soap_flag_WorkSheet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVMDParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVMDParamRes, 0, sizeof(struct _ns1__getVMDParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVMDParamRes(struct soap *soap, const struct _ns1__getVMDParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVMDParamRes);
	if (soap_out__ns1__getVMDParamRes(soap, tag?tag:"ns1:getVMDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVMDParamRes * SOAP_FMAC4 soap_get__ns1__getVMDParamRes(struct soap *soap, struct _ns1__getVMDParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVMDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVMDParamReq(struct soap *soap, struct _ns1__getVMDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVMDParamReq(struct soap *soap, const struct _ns1__getVMDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVMDParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__getVMDParamReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVMDParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVMDParamReq * SOAP_FMAC4 soap_in__ns1__getVMDParamReq(struct soap *soap, const char *tag, struct _ns1__getVMDParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVMDParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVMDParamReq, sizeof(struct _ns1__getVMDParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVMDParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVMDParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVMDParamReq, 0, sizeof(struct _ns1__getVMDParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVMDParamReq(struct soap *soap, const struct _ns1__getVMDParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVMDParamReq);
	if (soap_out__ns1__getVMDParamReq(soap, tag?tag:"ns1:getVMDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVMDParamReq * SOAP_FMAC4 soap_get__ns1__getVMDParamReq(struct soap *soap, struct _ns1__getVMDParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVMDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setTimeRes(struct soap *soap, struct _ns1__setTimeRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setTimeRes(struct soap *soap, const struct _ns1__setTimeRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setTimeRes(struct soap *soap, const char *tag, int id, const struct _ns1__setTimeRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setTimeRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setTimeRes * SOAP_FMAC4 soap_in__ns1__setTimeRes(struct soap *soap, const char *tag, struct _ns1__setTimeRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setTimeRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setTimeRes, sizeof(struct _ns1__setTimeRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setTimeRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setTimeRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setTimeRes, 0, sizeof(struct _ns1__setTimeRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setTimeRes(struct soap *soap, const struct _ns1__setTimeRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setTimeRes);
	if (soap_out__ns1__setTimeRes(soap, tag?tag:"ns1:setTimeRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setTimeRes * SOAP_FMAC4 soap_get__ns1__setTimeRes(struct soap *soap, struct _ns1__setTimeRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setTimeRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setTimeReq(struct soap *soap, struct _ns1__setTimeReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->Time = NULL;
	soap_default_string(soap, &a->TimeZone);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setTimeReq(struct soap *soap, const struct _ns1__setTimeReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_serialize_PointerTotime(soap, &a->Time);
	soap_serialize_string(soap, &a->TimeZone);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setTimeReq(struct soap *soap, const char *tag, int id, const struct _ns1__setTimeReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setTimeReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Time", -1, &a->Time, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:TimeZone", -1, &a->TimeZone, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setTimeReq * SOAP_FMAC4 soap_in__ns1__setTimeReq(struct soap *soap, const char *tag, struct _ns1__setTimeReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_Time = 1;
	size_t soap_flag_TimeZone = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setTimeReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setTimeReq, sizeof(struct _ns1__setTimeReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setTimeReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_TimeZone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:TimeZone", &a->TimeZone, "xsd:string"))
				{	soap_flag_TimeZone--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setTimeReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setTimeReq, 0, sizeof(struct _ns1__setTimeReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setTimeReq(struct soap *soap, const struct _ns1__setTimeReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setTimeReq);
	if (soap_out__ns1__setTimeReq(soap, tag?tag:"ns1:setTimeReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setTimeReq * SOAP_FMAC4 soap_get__ns1__setTimeReq(struct soap *soap, struct _ns1__setTimeReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setTimeReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getTimeRes(struct soap *soap, struct _ns1__getTimeRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->Time = NULL;
	soap_default_string(soap, &a->TimeZone);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getTimeRes(struct soap *soap, const struct _ns1__getTimeRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &a->Time);
	soap_serialize_string(soap, &a->TimeZone);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTimeRes(struct soap *soap, const char *tag, int id, const struct _ns1__getTimeRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTimeRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Time", -1, &a->Time, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:TimeZone", -1, &a->TimeZone, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getTimeRes * SOAP_FMAC4 soap_in__ns1__getTimeRes(struct soap *soap, const char *tag, struct _ns1__getTimeRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_Time = 1;
	size_t soap_flag_TimeZone = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getTimeRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTimeRes, sizeof(struct _ns1__getTimeRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getTimeRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_TimeZone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:TimeZone", &a->TimeZone, "xsd:string"))
				{	soap_flag_TimeZone--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getTimeRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTimeRes, 0, sizeof(struct _ns1__getTimeRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getTimeRes(struct soap *soap, const struct _ns1__getTimeRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getTimeRes);
	if (soap_out__ns1__getTimeRes(soap, tag?tag:"ns1:getTimeRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getTimeRes * SOAP_FMAC4 soap_get__ns1__getTimeRes(struct soap *soap, struct _ns1__getTimeRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTimeRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getTimeReq(struct soap *soap, struct _ns1__getTimeReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getTimeReq(struct soap *soap, const struct _ns1__getTimeReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTimeReq(struct soap *soap, const char *tag, int id, const struct _ns1__getTimeReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTimeReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getTimeReq * SOAP_FMAC4 soap_in__ns1__getTimeReq(struct soap *soap, const char *tag, struct _ns1__getTimeReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getTimeReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTimeReq, sizeof(struct _ns1__getTimeReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getTimeReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getTimeReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTimeReq, 0, sizeof(struct _ns1__getTimeReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getTimeReq(struct soap *soap, const struct _ns1__getTimeReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getTimeReq);
	if (soap_out__ns1__getTimeReq(soap, tag?tag:"ns1:getTimeReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getTimeReq * SOAP_FMAC4 soap_get__ns1__getTimeReq(struct soap *soap, struct _ns1__getTimeReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTimeReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setOSDParamRes(struct soap *soap, struct _ns1__setOSDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setOSDParamRes(struct soap *soap, const struct _ns1__setOSDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setOSDParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__setOSDParamRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setOSDParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setOSDParamRes * SOAP_FMAC4 soap_in__ns1__setOSDParamRes(struct soap *soap, const char *tag, struct _ns1__setOSDParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setOSDParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setOSDParamRes, sizeof(struct _ns1__setOSDParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setOSDParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setOSDParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setOSDParamRes, 0, sizeof(struct _ns1__setOSDParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setOSDParamRes(struct soap *soap, const struct _ns1__setOSDParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setOSDParamRes);
	if (soap_out__ns1__setOSDParamRes(soap, tag?tag:"ns1:setOSDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setOSDParamRes * SOAP_FMAC4 soap_get__ns1__setOSDParamRes(struct soap *soap, struct _ns1__setOSDParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setOSDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setOSDParamReq(struct soap *soap, struct _ns1__setOSDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->Enabled = NULL;
	a->TimestampEnabled = NULL;
	soap_default_string(soap, &a->DateTimeFormat);
	soap_default_string(soap, &a->DisplayText);
	a->FontSize = NULL;
	a->FontColor = NULL;
	a->TextPositionX = NULL;
	a->TextPositionY = NULL;
	a->TimestampPositionX = NULL;
	a->TimestampPositionY = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setOSDParamReq(struct soap *soap, const struct _ns1__setOSDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_PointerToxsd__boolean(soap, &a->TimestampEnabled);
	soap_serialize_string(soap, &a->DateTimeFormat);
	soap_serialize_string(soap, &a->DisplayText);
	soap_serialize_PointerToint(soap, &a->FontSize);
	soap_serialize_PointerToint(soap, &a->FontColor);
	soap_serialize_PointerToint(soap, &a->TextPositionX);
	soap_serialize_PointerToint(soap, &a->TextPositionY);
	soap_serialize_PointerToint(soap, &a->TimestampPositionX);
	soap_serialize_PointerToint(soap, &a->TimestampPositionY);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setOSDParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__setOSDParamReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setOSDParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:TimestampEnabled", -1, &a->TimestampEnabled, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DateTimeFormat", -1, &a->DateTimeFormat, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DisplayText", -1, &a->DisplayText, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:FontSize", -1, &a->FontSize, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:FontColor", -1, &a->FontColor, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TextPositionX", -1, &a->TextPositionX, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TextPositionY", -1, &a->TextPositionY, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TimestampPositionX", -1, &a->TimestampPositionX, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TimestampPositionY", -1, &a->TimestampPositionY, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setOSDParamReq * SOAP_FMAC4 soap_in__ns1__setOSDParamReq(struct soap *soap, const char *tag, struct _ns1__setOSDParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_TimestampEnabled = 1;
	size_t soap_flag_DateTimeFormat = 1;
	size_t soap_flag_DisplayText = 1;
	size_t soap_flag_FontSize = 1;
	size_t soap_flag_FontColor = 1;
	size_t soap_flag_TextPositionX = 1;
	size_t soap_flag_TextPositionY = 1;
	size_t soap_flag_TimestampPositionX = 1;
	size_t soap_flag_TimestampPositionY = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setOSDParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setOSDParamReq, sizeof(struct _ns1__setOSDParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setOSDParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_TimestampEnabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:TimestampEnabled", &a->TimestampEnabled, "xsd:boolean"))
				{	soap_flag_TimestampEnabled--;
					continue;
				}
			if (soap_flag_DateTimeFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DateTimeFormat", &a->DateTimeFormat, "xsd:string"))
				{	soap_flag_DateTimeFormat--;
					continue;
				}
			if (soap_flag_DisplayText && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DisplayText", &a->DisplayText, "xsd:string"))
				{	soap_flag_DisplayText--;
					continue;
				}
			if (soap_flag_FontSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:FontSize", &a->FontSize, "xsd:int"))
				{	soap_flag_FontSize--;
					continue;
				}
			if (soap_flag_FontColor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:FontColor", &a->FontColor, "xsd:int"))
				{	soap_flag_FontColor--;
					continue;
				}
			if (soap_flag_TextPositionX && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TextPositionX", &a->TextPositionX, "xsd:int"))
				{	soap_flag_TextPositionX--;
					continue;
				}
			if (soap_flag_TextPositionY && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TextPositionY", &a->TextPositionY, "xsd:int"))
				{	soap_flag_TextPositionY--;
					continue;
				}
			if (soap_flag_TimestampPositionX && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TimestampPositionX", &a->TimestampPositionX, "xsd:int"))
				{	soap_flag_TimestampPositionX--;
					continue;
				}
			if (soap_flag_TimestampPositionY && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TimestampPositionY", &a->TimestampPositionY, "xsd:int"))
				{	soap_flag_TimestampPositionY--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setOSDParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setOSDParamReq, 0, sizeof(struct _ns1__setOSDParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setOSDParamReq(struct soap *soap, const struct _ns1__setOSDParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setOSDParamReq);
	if (soap_out__ns1__setOSDParamReq(soap, tag?tag:"ns1:setOSDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setOSDParamReq * SOAP_FMAC4 soap_get__ns1__setOSDParamReq(struct soap *soap, struct _ns1__setOSDParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setOSDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getOSDParamRes(struct soap *soap, struct _ns1__getOSDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->Enabled = NULL;
	a->TimestampEnabled = NULL;
	soap_default_string(soap, &a->DateTimeFormat);
	soap_default_string(soap, &a->DisplayText);
	a->FontSize = NULL;
	a->FontColor = NULL;
	a->TextPositionX = NULL;
	a->TextPositionY = NULL;
	a->TimestampPositionX = NULL;
	a->TimestampPositionY = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getOSDParamRes(struct soap *soap, const struct _ns1__getOSDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_PointerToxsd__boolean(soap, &a->TimestampEnabled);
	soap_serialize_string(soap, &a->DateTimeFormat);
	soap_serialize_string(soap, &a->DisplayText);
	soap_serialize_PointerToint(soap, &a->FontSize);
	soap_serialize_PointerToint(soap, &a->FontColor);
	soap_serialize_PointerToint(soap, &a->TextPositionX);
	soap_serialize_PointerToint(soap, &a->TextPositionY);
	soap_serialize_PointerToint(soap, &a->TimestampPositionX);
	soap_serialize_PointerToint(soap, &a->TimestampPositionY);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getOSDParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__getOSDParamRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getOSDParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:TimestampEnabled", -1, &a->TimestampEnabled, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DateTimeFormat", -1, &a->DateTimeFormat, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DisplayText", -1, &a->DisplayText, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:FontSize", -1, &a->FontSize, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:FontColor", -1, &a->FontColor, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TextPositionX", -1, &a->TextPositionX, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TextPositionY", -1, &a->TextPositionY, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TimestampPositionX", -1, &a->TimestampPositionX, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TimestampPositionY", -1, &a->TimestampPositionY, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getOSDParamRes * SOAP_FMAC4 soap_in__ns1__getOSDParamRes(struct soap *soap, const char *tag, struct _ns1__getOSDParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_TimestampEnabled = 1;
	size_t soap_flag_DateTimeFormat = 1;
	size_t soap_flag_DisplayText = 1;
	size_t soap_flag_FontSize = 1;
	size_t soap_flag_FontColor = 1;
	size_t soap_flag_TextPositionX = 1;
	size_t soap_flag_TextPositionY = 1;
	size_t soap_flag_TimestampPositionX = 1;
	size_t soap_flag_TimestampPositionY = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getOSDParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getOSDParamRes, sizeof(struct _ns1__getOSDParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getOSDParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_TimestampEnabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:TimestampEnabled", &a->TimestampEnabled, "xsd:boolean"))
				{	soap_flag_TimestampEnabled--;
					continue;
				}
			if (soap_flag_DateTimeFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DateTimeFormat", &a->DateTimeFormat, "xsd:string"))
				{	soap_flag_DateTimeFormat--;
					continue;
				}
			if (soap_flag_DisplayText && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DisplayText", &a->DisplayText, "xsd:string"))
				{	soap_flag_DisplayText--;
					continue;
				}
			if (soap_flag_FontSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:FontSize", &a->FontSize, "xsd:int"))
				{	soap_flag_FontSize--;
					continue;
				}
			if (soap_flag_FontColor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:FontColor", &a->FontColor, "xsd:int"))
				{	soap_flag_FontColor--;
					continue;
				}
			if (soap_flag_TextPositionX && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TextPositionX", &a->TextPositionX, "xsd:int"))
				{	soap_flag_TextPositionX--;
					continue;
				}
			if (soap_flag_TextPositionY && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TextPositionY", &a->TextPositionY, "xsd:int"))
				{	soap_flag_TextPositionY--;
					continue;
				}
			if (soap_flag_TimestampPositionX && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TimestampPositionX", &a->TimestampPositionX, "xsd:int"))
				{	soap_flag_TimestampPositionX--;
					continue;
				}
			if (soap_flag_TimestampPositionY && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TimestampPositionY", &a->TimestampPositionY, "xsd:int"))
				{	soap_flag_TimestampPositionY--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getOSDParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getOSDParamRes, 0, sizeof(struct _ns1__getOSDParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getOSDParamRes(struct soap *soap, const struct _ns1__getOSDParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getOSDParamRes);
	if (soap_out__ns1__getOSDParamRes(soap, tag?tag:"ns1:getOSDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getOSDParamRes * SOAP_FMAC4 soap_get__ns1__getOSDParamRes(struct soap *soap, struct _ns1__getOSDParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getOSDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getOSDParamReq(struct soap *soap, struct _ns1__getOSDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getOSDParamReq(struct soap *soap, const struct _ns1__getOSDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getOSDParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__getOSDParamReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getOSDParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getOSDParamReq * SOAP_FMAC4 soap_in__ns1__getOSDParamReq(struct soap *soap, const char *tag, struct _ns1__getOSDParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getOSDParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getOSDParamReq, sizeof(struct _ns1__getOSDParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getOSDParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getOSDParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getOSDParamReq, 0, sizeof(struct _ns1__getOSDParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getOSDParamReq(struct soap *soap, const struct _ns1__getOSDParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getOSDParamReq);
	if (soap_out__ns1__getOSDParamReq(soap, tag?tag:"ns1:getOSDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getOSDParamReq * SOAP_FMAC4 soap_get__ns1__getOSDParamReq(struct soap *soap, struct _ns1__getOSDParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getOSDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setVideoParamRes(struct soap *soap, struct _ns1__setVideoParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setVideoParamRes(struct soap *soap, const struct _ns1__setVideoParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setVideoParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__setVideoParamRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setVideoParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setVideoParamRes * SOAP_FMAC4 soap_in__ns1__setVideoParamRes(struct soap *soap, const char *tag, struct _ns1__setVideoParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setVideoParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setVideoParamRes, sizeof(struct _ns1__setVideoParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setVideoParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVideoParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setVideoParamRes, 0, sizeof(struct _ns1__setVideoParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setVideoParamRes(struct soap *soap, const struct _ns1__setVideoParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setVideoParamRes);
	if (soap_out__ns1__setVideoParamRes(soap, tag?tag:"ns1:setVideoParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVideoParamRes * SOAP_FMAC4 soap_get__ns1__setVideoParamRes(struct soap *soap, struct _ns1__setVideoParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setVideoParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setVideoParamReq(struct soap *soap, struct _ns1__setVideoParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->VideoStandard = NULL;
	a->RotationDegree = NULL;
	a->Brightness = NULL;
	a->Contrast = NULL;
	a->Saturation = NULL;
	a->Hue = NULL;
	a->Infrared = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setVideoParamReq(struct soap *soap, const struct _ns1__setVideoParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_PointerTons1__VideoStandard(soap, &a->VideoStandard);
	soap_serialize_PointerToint(soap, &a->RotationDegree);
	soap_serialize_PointerToint(soap, &a->Brightness);
	soap_serialize_PointerToint(soap, &a->Contrast);
	soap_serialize_PointerToint(soap, &a->Saturation);
	soap_serialize_PointerToint(soap, &a->Hue);
	soap_serialize_PointerToxsd__boolean(soap, &a->Infrared);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setVideoParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__setVideoParamReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setVideoParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_PointerTons1__VideoStandard(soap, "ns1:VideoStandard", -1, &a->VideoStandard, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:RotationDegree", -1, &a->RotationDegree, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Brightness", -1, &a->Brightness, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Contrast", -1, &a->Contrast, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Saturation", -1, &a->Saturation, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Hue", -1, &a->Hue, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Infrared", -1, &a->Infrared, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setVideoParamReq * SOAP_FMAC4 soap_in__ns1__setVideoParamReq(struct soap *soap, const char *tag, struct _ns1__setVideoParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_VideoStandard = 1;
	size_t soap_flag_RotationDegree = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Saturation = 1;
	size_t soap_flag_Hue = 1;
	size_t soap_flag_Infrared = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setVideoParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setVideoParamReq, sizeof(struct _ns1__setVideoParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setVideoParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_VideoStandard && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__VideoStandard(soap, "ns1:VideoStandard", &a->VideoStandard, "ns1:VideoStandard"))
				{	soap_flag_VideoStandard--;
					continue;
				}
			if (soap_flag_RotationDegree && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:RotationDegree", &a->RotationDegree, "xsd:int"))
				{	soap_flag_RotationDegree--;
					continue;
				}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Brightness", &a->Brightness, "xsd:int"))
				{	soap_flag_Brightness--;
					continue;
				}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Contrast", &a->Contrast, "xsd:int"))
				{	soap_flag_Contrast--;
					continue;
				}
			if (soap_flag_Saturation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Saturation", &a->Saturation, "xsd:int"))
				{	soap_flag_Saturation--;
					continue;
				}
			if (soap_flag_Hue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Hue", &a->Hue, "xsd:int"))
				{	soap_flag_Hue--;
					continue;
				}
			if (soap_flag_Infrared && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Infrared", &a->Infrared, "xsd:boolean"))
				{	soap_flag_Infrared--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVideoParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setVideoParamReq, 0, sizeof(struct _ns1__setVideoParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setVideoParamReq(struct soap *soap, const struct _ns1__setVideoParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setVideoParamReq);
	if (soap_out__ns1__setVideoParamReq(soap, tag?tag:"ns1:setVideoParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVideoParamReq * SOAP_FMAC4 soap_get__ns1__setVideoParamReq(struct soap *soap, struct _ns1__setVideoParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setVideoParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVideoParamRes(struct soap *soap, struct _ns1__getVideoParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->VideoStandard = NULL;
	a->RotationDegree = NULL;
	a->Brightness = NULL;
	a->Contrast = NULL;
	a->Saturation = NULL;
	a->Hue = NULL;
	a->Infrared = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVideoParamRes(struct soap *soap, const struct _ns1__getVideoParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__VideoStandard(soap, &a->VideoStandard);
	soap_serialize_PointerToint(soap, &a->RotationDegree);
	soap_serialize_PointerToint(soap, &a->Brightness);
	soap_serialize_PointerToint(soap, &a->Contrast);
	soap_serialize_PointerToint(soap, &a->Saturation);
	soap_serialize_PointerToint(soap, &a->Hue);
	soap_serialize_PointerToxsd__boolean(soap, &a->Infrared);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVideoParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__getVideoParamRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVideoParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__VideoStandard(soap, "ns1:VideoStandard", -1, &a->VideoStandard, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:RotationDegree", -1, &a->RotationDegree, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Brightness", -1, &a->Brightness, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Contrast", -1, &a->Contrast, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Saturation", -1, &a->Saturation, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Hue", -1, &a->Hue, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Infrared", -1, &a->Infrared, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVideoParamRes * SOAP_FMAC4 soap_in__ns1__getVideoParamRes(struct soap *soap, const char *tag, struct _ns1__getVideoParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_VideoStandard = 1;
	size_t soap_flag_RotationDegree = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Saturation = 1;
	size_t soap_flag_Hue = 1;
	size_t soap_flag_Infrared = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVideoParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVideoParamRes, sizeof(struct _ns1__getVideoParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVideoParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_VideoStandard && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__VideoStandard(soap, "ns1:VideoStandard", &a->VideoStandard, "ns1:VideoStandard"))
				{	soap_flag_VideoStandard--;
					continue;
				}
			if (soap_flag_RotationDegree && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:RotationDegree", &a->RotationDegree, "xsd:int"))
				{	soap_flag_RotationDegree--;
					continue;
				}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Brightness", &a->Brightness, "xsd:int"))
				{	soap_flag_Brightness--;
					continue;
				}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Contrast", &a->Contrast, "xsd:int"))
				{	soap_flag_Contrast--;
					continue;
				}
			if (soap_flag_Saturation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Saturation", &a->Saturation, "xsd:int"))
				{	soap_flag_Saturation--;
					continue;
				}
			if (soap_flag_Hue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Hue", &a->Hue, "xsd:int"))
				{	soap_flag_Hue--;
					continue;
				}
			if (soap_flag_Infrared && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Infrared", &a->Infrared, "xsd:boolean"))
				{	soap_flag_Infrared--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVideoParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVideoParamRes, 0, sizeof(struct _ns1__getVideoParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVideoParamRes(struct soap *soap, const struct _ns1__getVideoParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVideoParamRes);
	if (soap_out__ns1__getVideoParamRes(soap, tag?tag:"ns1:getVideoParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVideoParamRes * SOAP_FMAC4 soap_get__ns1__getVideoParamRes(struct soap *soap, struct _ns1__getVideoParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVideoParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVideoParamReq(struct soap *soap, struct _ns1__getVideoParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVideoParamReq(struct soap *soap, const struct _ns1__getVideoParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVideoParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__getVideoParamReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVideoParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVideoParamReq * SOAP_FMAC4 soap_in__ns1__getVideoParamReq(struct soap *soap, const char *tag, struct _ns1__getVideoParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVideoParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVideoParamReq, sizeof(struct _ns1__getVideoParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVideoParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVideoParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVideoParamReq, 0, sizeof(struct _ns1__getVideoParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVideoParamReq(struct soap *soap, const struct _ns1__getVideoParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVideoParamReq);
	if (soap_out__ns1__getVideoParamReq(soap, tag?tag:"ns1:getVideoParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVideoParamReq * SOAP_FMAC4 soap_get__ns1__getVideoParamReq(struct soap *soap, struct _ns1__getVideoParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVideoParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDevLogRes(struct soap *soap, struct _ns1__queryDevLogRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->DevLog = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDevLogRes(struct soap *soap, const struct _ns1__queryDevLogRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfDevLog(soap, &a->DevLog);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDevLogRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryDevLogRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDevLogRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfDevLog(soap, "ns1:DevLog", -1, &a->DevLog, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDevLogRes * SOAP_FMAC4 soap_in__ns1__queryDevLogRes(struct soap *soap, const char *tag, struct _ns1__queryDevLogRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_DevLog = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDevLogRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDevLogRes, sizeof(struct _ns1__queryDevLogRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDevLogRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_DevLog && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDevLog(soap, "ns1:DevLog", &a->DevLog, "ns1:ArrayOfDevLog"))
				{	soap_flag_DevLog--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDevLogRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDevLogRes, 0, sizeof(struct _ns1__queryDevLogRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDevLogRes(struct soap *soap, const struct _ns1__queryDevLogRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDevLogRes);
	if (soap_out__ns1__queryDevLogRes(soap, tag?tag:"ns1:queryDevLogRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDevLogRes * SOAP_FMAC4 soap_get__ns1__queryDevLogRes(struct soap *soap, struct _ns1__queryDevLogRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDevLogRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDevLogReq(struct soap *soap, struct _ns1__queryDevLogReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_time(soap, &a->StartTime);
	soap_default_time(soap, &a->EndTime);
	soap_default_int(soap, &a->MaxResult);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDevLogReq(struct soap *soap, const struct _ns1__queryDevLogReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->StartTime, SOAP_TYPE_time);
	soap_embedded(soap, &a->EndTime, SOAP_TYPE_time);
	soap_embedded(soap, &a->MaxResult, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDevLogReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryDevLogReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDevLogReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:StartTime", -1, &a->StartTime, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:EndTime", -1, &a->EndTime, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:MaxResult", -1, &a->MaxResult, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDevLogReq * SOAP_FMAC4 soap_in__ns1__queryDevLogReq(struct soap *soap, const char *tag, struct _ns1__queryDevLogReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_EndTime = 1;
	size_t soap_flag_MaxResult = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDevLogReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDevLogReq, sizeof(struct _ns1__queryDevLogReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDevLogReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:StartTime", &a->StartTime, "xsd:dateTime"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_EndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:EndTime", &a->EndTime, "xsd:dateTime"))
				{	soap_flag_EndTime--;
					continue;
				}
			if (soap_flag_MaxResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:MaxResult", &a->MaxResult, "xsd:int"))
				{	soap_flag_MaxResult--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDevLogReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDevLogReq, 0, sizeof(struct _ns1__queryDevLogReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartTime > 0 || soap_flag_EndTime > 0 || soap_flag_MaxResult > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDevLogReq(struct soap *soap, const struct _ns1__queryDevLogReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDevLogReq);
	if (soap_out__ns1__queryDevLogReq(soap, tag?tag:"ns1:queryDevLogReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDevLogReq * SOAP_FMAC4 soap_get__ns1__queryDevLogReq(struct soap *soap, struct _ns1__queryDevLogReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDevLogReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryLogRes(struct soap *soap, struct _ns1__queryLogRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->PuLogAll = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryLogRes(struct soap *soap, const struct _ns1__queryLogRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPuLog(soap, &a->PuLogAll);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryLogRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryLogRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryLogRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfPuLog(soap, "ns1:PuLogAll", -1, &a->PuLogAll, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryLogRes * SOAP_FMAC4 soap_in__ns1__queryLogRes(struct soap *soap, const char *tag, struct _ns1__queryLogRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_PuLogAll = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryLogRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryLogRes, sizeof(struct _ns1__queryLogRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryLogRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_PuLogAll && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPuLog(soap, "ns1:PuLogAll", &a->PuLogAll, "ns1:ArrayOfPuLog"))
				{	soap_flag_PuLogAll--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryLogRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryLogRes, 0, sizeof(struct _ns1__queryLogRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryLogRes(struct soap *soap, const struct _ns1__queryLogRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryLogRes);
	if (soap_out__ns1__queryLogRes(soap, tag?tag:"ns1:queryLogRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryLogRes * SOAP_FMAC4 soap_get__ns1__queryLogRes(struct soap *soap, struct _ns1__queryLogRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryLogRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryLogReq(struct soap *soap, struct _ns1__queryLogReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryLogReq(struct soap *soap, const struct _ns1__queryLogReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryLogReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryLogReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryLogReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryLogReq * SOAP_FMAC4 soap_in__ns1__queryLogReq(struct soap *soap, const char *tag, struct _ns1__queryLogReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryLogReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryLogReq, sizeof(struct _ns1__queryLogReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryLogReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryLogReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryLogReq, 0, sizeof(struct _ns1__queryLogReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryLogReq(struct soap *soap, const struct _ns1__queryLogReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryLogReq);
	if (soap_out__ns1__queryLogReq(soap, tag?tag:"ns1:queryLogReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryLogReq * SOAP_FMAC4 soap_get__ns1__queryLogReq(struct soap *soap, struct _ns1__queryLogReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryLogReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__upgradeDevVerRes(struct soap *soap, struct _ns1__upgradeDevVerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__upgradeDevVerRes(struct soap *soap, const struct _ns1__upgradeDevVerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__upgradeDevVerRes(struct soap *soap, const char *tag, int id, const struct _ns1__upgradeDevVerRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__upgradeDevVerRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerRes * SOAP_FMAC4 soap_in__ns1__upgradeDevVerRes(struct soap *soap, const char *tag, struct _ns1__upgradeDevVerRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__upgradeDevVerRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__upgradeDevVerRes, sizeof(struct _ns1__upgradeDevVerRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__upgradeDevVerRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__upgradeDevVerRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__upgradeDevVerRes, 0, sizeof(struct _ns1__upgradeDevVerRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__upgradeDevVerRes(struct soap *soap, const struct _ns1__upgradeDevVerRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__upgradeDevVerRes);
	if (soap_out__ns1__upgradeDevVerRes(soap, tag?tag:"ns1:upgradeDevVerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerRes * SOAP_FMAC4 soap_get__ns1__upgradeDevVerRes(struct soap *soap, struct _ns1__upgradeDevVerRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__upgradeDevVerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__upgradeDevVerReq(struct soap *soap, struct _ns1__upgradeDevVerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_string(soap, &a->NewDevVer);
	soap_default_string(soap, &a->FTPAddress);
	a->FTPPort = NULL;
	soap_default_string(soap, &a->FTPAccount);
	soap_default_string(soap, &a->FTPPassword);
	soap_default_string(soap, &a->FTPFileName);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__upgradeDevVerReq(struct soap *soap, const struct _ns1__upgradeDevVerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_serialize_string(soap, &a->NewDevVer);
	soap_serialize_string(soap, &a->FTPAddress);
	soap_serialize_PointerToint(soap, &a->FTPPort);
	soap_serialize_string(soap, &a->FTPAccount);
	soap_serialize_string(soap, &a->FTPPassword);
	soap_serialize_string(soap, &a->FTPFileName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__upgradeDevVerReq(struct soap *soap, const char *tag, int id, const struct _ns1__upgradeDevVerReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__upgradeDevVerReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:NewDevVer", -1, &a->NewDevVer, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:FTPAddress", -1, &a->FTPAddress, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:FTPPort", -1, &a->FTPPort, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:FTPAccount", -1, &a->FTPAccount, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:FTPPassword", -1, &a->FTPPassword, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:FTPFileName", -1, &a->FTPFileName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerReq * SOAP_FMAC4 soap_in__ns1__upgradeDevVerReq(struct soap *soap, const char *tag, struct _ns1__upgradeDevVerReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_NewDevVer = 1;
	size_t soap_flag_FTPAddress = 1;
	size_t soap_flag_FTPPort = 1;
	size_t soap_flag_FTPAccount = 1;
	size_t soap_flag_FTPPassword = 1;
	size_t soap_flag_FTPFileName = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__upgradeDevVerReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__upgradeDevVerReq, sizeof(struct _ns1__upgradeDevVerReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__upgradeDevVerReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_NewDevVer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:NewDevVer", &a->NewDevVer, "xsd:string"))
				{	soap_flag_NewDevVer--;
					continue;
				}
			if (soap_flag_FTPAddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:FTPAddress", &a->FTPAddress, "xsd:string"))
				{	soap_flag_FTPAddress--;
					continue;
				}
			if (soap_flag_FTPPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:FTPPort", &a->FTPPort, "xsd:int"))
				{	soap_flag_FTPPort--;
					continue;
				}
			if (soap_flag_FTPAccount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:FTPAccount", &a->FTPAccount, "xsd:string"))
				{	soap_flag_FTPAccount--;
					continue;
				}
			if (soap_flag_FTPPassword && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:FTPPassword", &a->FTPPassword, "xsd:string"))
				{	soap_flag_FTPPassword--;
					continue;
				}
			if (soap_flag_FTPFileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:FTPFileName", &a->FTPFileName, "xsd:string"))
				{	soap_flag_FTPFileName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__upgradeDevVerReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__upgradeDevVerReq, 0, sizeof(struct _ns1__upgradeDevVerReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__upgradeDevVerReq(struct soap *soap, const struct _ns1__upgradeDevVerReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__upgradeDevVerReq);
	if (soap_out__ns1__upgradeDevVerReq(soap, tag?tag:"ns1:upgradeDevVerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerReq * SOAP_FMAC4 soap_get__ns1__upgradeDevVerReq(struct soap *soap, struct _ns1__upgradeDevVerReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__upgradeDevVerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getDevVerRes(struct soap *soap, struct _ns1__getDevVerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->CurDevVer);
	soap_default_string(soap, &a->NewDevVer);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getDevVerRes(struct soap *soap, const struct _ns1__getDevVerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->CurDevVer);
	soap_serialize_string(soap, &a->NewDevVer);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDevVerRes(struct soap *soap, const char *tag, int id, const struct _ns1__getDevVerRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDevVerRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:CurDevVer", -1, &a->CurDevVer, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:NewDevVer", -1, &a->NewDevVer, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getDevVerRes * SOAP_FMAC4 soap_in__ns1__getDevVerRes(struct soap *soap, const char *tag, struct _ns1__getDevVerRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_CurDevVer = 1;
	size_t soap_flag_NewDevVer = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getDevVerRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDevVerRes, sizeof(struct _ns1__getDevVerRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getDevVerRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_CurDevVer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:CurDevVer", &a->CurDevVer, "xsd:string"))
				{	soap_flag_CurDevVer--;
					continue;
				}
			if (soap_flag_NewDevVer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:NewDevVer", &a->NewDevVer, "xsd:string"))
				{	soap_flag_NewDevVer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDevVerRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDevVerRes, 0, sizeof(struct _ns1__getDevVerRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getDevVerRes(struct soap *soap, const struct _ns1__getDevVerRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getDevVerRes);
	if (soap_out__ns1__getDevVerRes(soap, tag?tag:"ns1:getDevVerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDevVerRes * SOAP_FMAC4 soap_get__ns1__getDevVerRes(struct soap *soap, struct _ns1__getDevVerRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDevVerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getDevVerReq(struct soap *soap, struct _ns1__getDevVerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getDevVerReq(struct soap *soap, const struct _ns1__getDevVerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDevVerReq(struct soap *soap, const char *tag, int id, const struct _ns1__getDevVerReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDevVerReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getDevVerReq * SOAP_FMAC4 soap_in__ns1__getDevVerReq(struct soap *soap, const char *tag, struct _ns1__getDevVerReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getDevVerReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDevVerReq, sizeof(struct _ns1__getDevVerReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getDevVerReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDevVerReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDevVerReq, 0, sizeof(struct _ns1__getDevVerReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getDevVerReq(struct soap *soap, const struct _ns1__getDevVerReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getDevVerReq);
	if (soap_out__ns1__getDevVerReq(soap, tag?tag:"ns1:getDevVerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDevVerReq * SOAP_FMAC4 soap_get__ns1__getDevVerReq(struct soap *soap, struct _ns1__getDevVerReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDevVerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__rebootRes(struct soap *soap, struct _ns1__rebootRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__rebootRes(struct soap *soap, const struct _ns1__rebootRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__rebootRes(struct soap *soap, const char *tag, int id, const struct _ns1__rebootRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__rebootRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__rebootRes * SOAP_FMAC4 soap_in__ns1__rebootRes(struct soap *soap, const char *tag, struct _ns1__rebootRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__rebootRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__rebootRes, sizeof(struct _ns1__rebootRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__rebootRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__rebootRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__rebootRes, 0, sizeof(struct _ns1__rebootRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__rebootRes(struct soap *soap, const struct _ns1__rebootRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__rebootRes);
	if (soap_out__ns1__rebootRes(soap, tag?tag:"ns1:rebootRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__rebootRes * SOAP_FMAC4 soap_get__ns1__rebootRes(struct soap *soap, struct _ns1__rebootRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__rebootRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__rebootReq(struct soap *soap, struct _ns1__rebootReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__rebootReq(struct soap *soap, const struct _ns1__rebootReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__rebootReq(struct soap *soap, const char *tag, int id, const struct _ns1__rebootReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__rebootReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__rebootReq * SOAP_FMAC4 soap_in__ns1__rebootReq(struct soap *soap, const char *tag, struct _ns1__rebootReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__rebootReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__rebootReq, sizeof(struct _ns1__rebootReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__rebootReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__rebootReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__rebootReq, 0, sizeof(struct _ns1__rebootReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__rebootReq(struct soap *soap, const struct _ns1__rebootReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__rebootReq);
	if (soap_out__ns1__rebootReq(soap, tag?tag:"ns1:rebootReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__rebootReq * SOAP_FMAC4 soap_get__ns1__rebootReq(struct soap *soap, struct _ns1__rebootReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__rebootReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setCodingParamRes(struct soap *soap, struct _ns1__setCodingParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setCodingParamRes(struct soap *soap, const struct _ns1__setCodingParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setCodingParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__setCodingParamRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setCodingParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setCodingParamRes * SOAP_FMAC4 soap_in__ns1__setCodingParamRes(struct soap *soap, const char *tag, struct _ns1__setCodingParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setCodingParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setCodingParamRes, sizeof(struct _ns1__setCodingParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setCodingParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setCodingParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setCodingParamRes, 0, sizeof(struct _ns1__setCodingParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setCodingParamRes(struct soap *soap, const struct _ns1__setCodingParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setCodingParamRes);
	if (soap_out__ns1__setCodingParamRes(soap, tag?tag:"ns1:setCodingParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setCodingParamRes * SOAP_FMAC4 soap_get__ns1__setCodingParamRes(struct soap *soap, struct _ns1__setCodingParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setCodingParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setCodingParamReq(struct soap *soap, struct _ns1__setCodingParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__StreamType(soap, &a->StreamType);
	a->FrameSize = NULL;
	a->FrameRate = NULL;
	a->RateType = NULL;
	a->BitRate = NULL;
	a->ImageQuality = NULL;
	a->AudioInput = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setCodingParamReq(struct soap *soap, const struct _ns1__setCodingParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_PointerTons1__FrameSize(soap, &a->FrameSize);
	soap_serialize_PointerToint(soap, &a->FrameRate);
	soap_serialize_PointerTons1__RateType(soap, &a->RateType);
	soap_serialize_PointerToint(soap, &a->BitRate);
	soap_serialize_PointerToint(soap, &a->ImageQuality);
	soap_serialize_PointerToxsd__boolean(soap, &a->AudioInput);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setCodingParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__setCodingParamReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setCodingParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__StreamType(soap, "ns1:StreamType", -1, &a->StreamType, ""))
		return soap->error;
	if (soap_out_PointerTons1__FrameSize(soap, "ns1:FrameSize", -1, &a->FrameSize, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:FrameRate", -1, &a->FrameRate, ""))
		return soap->error;
	if (soap_out_PointerTons1__RateType(soap, "ns1:RateType", -1, &a->RateType, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:BitRate", -1, &a->BitRate, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ImageQuality", -1, &a->ImageQuality, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:AudioInput", -1, &a->AudioInput, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setCodingParamReq * SOAP_FMAC4 soap_in__ns1__setCodingParamReq(struct soap *soap, const char *tag, struct _ns1__setCodingParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_StreamType = 1;
	size_t soap_flag_FrameSize = 1;
	size_t soap_flag_FrameRate = 1;
	size_t soap_flag_RateType = 1;
	size_t soap_flag_BitRate = 1;
	size_t soap_flag_ImageQuality = 1;
	size_t soap_flag_AudioInput = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setCodingParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setCodingParamReq, sizeof(struct _ns1__setCodingParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setCodingParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_StreamType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StreamType(soap, "ns1:StreamType", &a->StreamType, "ns1:StreamType"))
				{	soap_flag_StreamType--;
					continue;
				}
			if (soap_flag_FrameSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__FrameSize(soap, "ns1:FrameSize", &a->FrameSize, "ns1:FrameSize"))
				{	soap_flag_FrameSize--;
					continue;
				}
			if (soap_flag_FrameRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:FrameRate", &a->FrameRate, "xsd:int"))
				{	soap_flag_FrameRate--;
					continue;
				}
			if (soap_flag_RateType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RateType(soap, "ns1:RateType", &a->RateType, "ns1:RateType"))
				{	soap_flag_RateType--;
					continue;
				}
			if (soap_flag_BitRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:BitRate", &a->BitRate, "xsd:int"))
				{	soap_flag_BitRate--;
					continue;
				}
			if (soap_flag_ImageQuality && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:ImageQuality", &a->ImageQuality, "xsd:int"))
				{	soap_flag_ImageQuality--;
					continue;
				}
			if (soap_flag_AudioInput && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:AudioInput", &a->AudioInput, "xsd:boolean"))
				{	soap_flag_AudioInput--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setCodingParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setCodingParamReq, 0, sizeof(struct _ns1__setCodingParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_StreamType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setCodingParamReq(struct soap *soap, const struct _ns1__setCodingParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setCodingParamReq);
	if (soap_out__ns1__setCodingParamReq(soap, tag?tag:"ns1:setCodingParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setCodingParamReq * SOAP_FMAC4 soap_get__ns1__setCodingParamReq(struct soap *soap, struct _ns1__setCodingParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setCodingParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getCodingParamRes(struct soap *soap, struct _ns1__getCodingParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->FrameSize = NULL;
	a->FrameRate = NULL;
	a->RateType = NULL;
	a->BitRate = NULL;
	a->ImageQuality = NULL;
	a->AudioInput = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getCodingParamRes(struct soap *soap, const struct _ns1__getCodingParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__FrameSize(soap, &a->FrameSize);
	soap_serialize_PointerToint(soap, &a->FrameRate);
	soap_serialize_PointerTons1__RateType(soap, &a->RateType);
	soap_serialize_PointerToint(soap, &a->BitRate);
	soap_serialize_PointerToint(soap, &a->ImageQuality);
	soap_serialize_PointerToxsd__boolean(soap, &a->AudioInput);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCodingParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__getCodingParamRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCodingParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__FrameSize(soap, "ns1:FrameSize", -1, &a->FrameSize, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:FrameRate", -1, &a->FrameRate, ""))
		return soap->error;
	if (soap_out_PointerTons1__RateType(soap, "ns1:RateType", -1, &a->RateType, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:BitRate", -1, &a->BitRate, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ImageQuality", -1, &a->ImageQuality, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:AudioInput", -1, &a->AudioInput, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getCodingParamRes * SOAP_FMAC4 soap_in__ns1__getCodingParamRes(struct soap *soap, const char *tag, struct _ns1__getCodingParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_FrameSize = 1;
	size_t soap_flag_FrameRate = 1;
	size_t soap_flag_RateType = 1;
	size_t soap_flag_BitRate = 1;
	size_t soap_flag_ImageQuality = 1;
	size_t soap_flag_AudioInput = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getCodingParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCodingParamRes, sizeof(struct _ns1__getCodingParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getCodingParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_FrameSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__FrameSize(soap, "ns1:FrameSize", &a->FrameSize, "ns1:FrameSize"))
				{	soap_flag_FrameSize--;
					continue;
				}
			if (soap_flag_FrameRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:FrameRate", &a->FrameRate, "xsd:int"))
				{	soap_flag_FrameRate--;
					continue;
				}
			if (soap_flag_RateType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RateType(soap, "ns1:RateType", &a->RateType, "ns1:RateType"))
				{	soap_flag_RateType--;
					continue;
				}
			if (soap_flag_BitRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:BitRate", &a->BitRate, "xsd:int"))
				{	soap_flag_BitRate--;
					continue;
				}
			if (soap_flag_ImageQuality && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:ImageQuality", &a->ImageQuality, "xsd:int"))
				{	soap_flag_ImageQuality--;
					continue;
				}
			if (soap_flag_AudioInput && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:AudioInput", &a->AudioInput, "xsd:boolean"))
				{	soap_flag_AudioInput--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getCodingParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getCodingParamRes, 0, sizeof(struct _ns1__getCodingParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getCodingParamRes(struct soap *soap, const struct _ns1__getCodingParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getCodingParamRes);
	if (soap_out__ns1__getCodingParamRes(soap, tag?tag:"ns1:getCodingParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getCodingParamRes * SOAP_FMAC4 soap_get__ns1__getCodingParamRes(struct soap *soap, struct _ns1__getCodingParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCodingParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getCodingParamReq(struct soap *soap, struct _ns1__getCodingParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__StreamType(soap, &a->StreamType);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getCodingParamReq(struct soap *soap, const struct _ns1__getCodingParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCodingParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__getCodingParamReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCodingParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__StreamType(soap, "ns1:StreamType", -1, &a->StreamType, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getCodingParamReq * SOAP_FMAC4 soap_in__ns1__getCodingParamReq(struct soap *soap, const char *tag, struct _ns1__getCodingParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_StreamType = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getCodingParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCodingParamReq, sizeof(struct _ns1__getCodingParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getCodingParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_StreamType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StreamType(soap, "ns1:StreamType", &a->StreamType, "ns1:StreamType"))
				{	soap_flag_StreamType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getCodingParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getCodingParamReq, 0, sizeof(struct _ns1__getCodingParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_StreamType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getCodingParamReq(struct soap *soap, const struct _ns1__getCodingParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getCodingParamReq);
	if (soap_out__ns1__getCodingParamReq(soap, tag?tag:"ns1:getCodingParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getCodingParamReq * SOAP_FMAC4 soap_get__ns1__getCodingParamReq(struct soap *soap, struct _ns1__getCodingParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCodingParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__presetControlRes(struct soap *soap, struct _ns1__presetControlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__presetControlRes(struct soap *soap, const struct _ns1__presetControlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__presetControlRes(struct soap *soap, const char *tag, int id, const struct _ns1__presetControlRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__presetControlRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__presetControlRes * SOAP_FMAC4 soap_in__ns1__presetControlRes(struct soap *soap, const char *tag, struct _ns1__presetControlRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__presetControlRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__presetControlRes, sizeof(struct _ns1__presetControlRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__presetControlRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__presetControlRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__presetControlRes, 0, sizeof(struct _ns1__presetControlRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__presetControlRes(struct soap *soap, const struct _ns1__presetControlRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__presetControlRes);
	if (soap_out__ns1__presetControlRes(soap, tag?tag:"ns1:presetControlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__presetControlRes * SOAP_FMAC4 soap_get__ns1__presetControlRes(struct soap *soap, struct _ns1__presetControlRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__presetControlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__presetControlReq(struct soap *soap, struct _ns1__presetControlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__PTZPreset(soap, &a->PtzPreset);
	soap_default_int(soap, &a->PresetNo);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__presetControlReq(struct soap *soap, const struct _ns1__presetControlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_embedded(soap, &a->PresetNo, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__presetControlReq(struct soap *soap, const char *tag, int id, const struct _ns1__presetControlReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__presetControlReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__PTZPreset(soap, "ns1:PtzPreset", -1, &a->PtzPreset, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PresetNo", -1, &a->PresetNo, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__presetControlReq * SOAP_FMAC4 soap_in__ns1__presetControlReq(struct soap *soap, const char *tag, struct _ns1__presetControlReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_PtzPreset = 1;
	size_t soap_flag_PresetNo = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__presetControlReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__presetControlReq, sizeof(struct _ns1__presetControlReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__presetControlReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_PtzPreset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__PTZPreset(soap, "ns1:PtzPreset", &a->PtzPreset, "ns1:PTZPreset"))
				{	soap_flag_PtzPreset--;
					continue;
				}
			if (soap_flag_PresetNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PresetNo", &a->PresetNo, "xsd:int"))
				{	soap_flag_PresetNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__presetControlReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__presetControlReq, 0, sizeof(struct _ns1__presetControlReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_PtzPreset > 0 || soap_flag_PresetNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__presetControlReq(struct soap *soap, const struct _ns1__presetControlReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__presetControlReq);
	if (soap_out__ns1__presetControlReq(soap, tag?tag:"ns1:presetControlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__presetControlReq * SOAP_FMAC4 soap_get__ns1__presetControlReq(struct soap *soap, struct _ns1__presetControlReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__presetControlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__lensControlRes(struct soap *soap, struct _ns1__lensControlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__lensControlRes(struct soap *soap, const struct _ns1__lensControlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__lensControlRes(struct soap *soap, const char *tag, int id, const struct _ns1__lensControlRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__lensControlRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__lensControlRes * SOAP_FMAC4 soap_in__ns1__lensControlRes(struct soap *soap, const char *tag, struct _ns1__lensControlRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__lensControlRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__lensControlRes, sizeof(struct _ns1__lensControlRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__lensControlRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__lensControlRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__lensControlRes, 0, sizeof(struct _ns1__lensControlRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__lensControlRes(struct soap *soap, const struct _ns1__lensControlRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__lensControlRes);
	if (soap_out__ns1__lensControlRes(soap, tag?tag:"ns1:lensControlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__lensControlRes * SOAP_FMAC4 soap_get__ns1__lensControlRes(struct soap *soap, struct _ns1__lensControlRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__lensControlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__lensControlReq(struct soap *soap, struct _ns1__lensControlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__PTZLens(soap, &a->PtzLens);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__lensControlReq(struct soap *soap, const struct _ns1__lensControlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__lensControlReq(struct soap *soap, const char *tag, int id, const struct _ns1__lensControlReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__lensControlReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__PTZLens(soap, "ns1:PtzLens", -1, &a->PtzLens, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__lensControlReq * SOAP_FMAC4 soap_in__ns1__lensControlReq(struct soap *soap, const char *tag, struct _ns1__lensControlReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_PtzLens = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__lensControlReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__lensControlReq, sizeof(struct _ns1__lensControlReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__lensControlReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_PtzLens && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__PTZLens(soap, "ns1:PtzLens", &a->PtzLens, "ns1:PTZLens"))
				{	soap_flag_PtzLens--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__lensControlReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__lensControlReq, 0, sizeof(struct _ns1__lensControlReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_PtzLens > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__lensControlReq(struct soap *soap, const struct _ns1__lensControlReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__lensControlReq);
	if (soap_out__ns1__lensControlReq(soap, tag?tag:"ns1:lensControlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__lensControlReq * SOAP_FMAC4 soap_get__ns1__lensControlReq(struct soap *soap, struct _ns1__lensControlReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__lensControlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ptzControlRes(struct soap *soap, struct _ns1__ptzControlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ptzControlRes(struct soap *soap, const struct _ns1__ptzControlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ptzControlRes(struct soap *soap, const char *tag, int id, const struct _ns1__ptzControlRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ptzControlRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ptzControlRes * SOAP_FMAC4 soap_in__ns1__ptzControlRes(struct soap *soap, const char *tag, struct _ns1__ptzControlRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ptzControlRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ptzControlRes, sizeof(struct _ns1__ptzControlRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ptzControlRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ptzControlRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ptzControlRes, 0, sizeof(struct _ns1__ptzControlRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ptzControlRes(struct soap *soap, const struct _ns1__ptzControlRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ptzControlRes);
	if (soap_out__ns1__ptzControlRes(soap, tag?tag:"ns1:ptzControlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ptzControlRes * SOAP_FMAC4 soap_get__ns1__ptzControlRes(struct soap *soap, struct _ns1__ptzControlRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ptzControlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ptzControlReq(struct soap *soap, struct _ns1__ptzControlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__PTZDirection(soap, &a->PtzDirection);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ptzControlReq(struct soap *soap, const struct _ns1__ptzControlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ptzControlReq(struct soap *soap, const char *tag, int id, const struct _ns1__ptzControlReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ptzControlReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__PTZDirection(soap, "ns1:PtzDirection", -1, &a->PtzDirection, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ptzControlReq * SOAP_FMAC4 soap_in__ns1__ptzControlReq(struct soap *soap, const char *tag, struct _ns1__ptzControlReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_PtzDirection = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ptzControlReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ptzControlReq, sizeof(struct _ns1__ptzControlReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ptzControlReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_PtzDirection && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__PTZDirection(soap, "ns1:PtzDirection", &a->PtzDirection, "ns1:PTZDirection"))
				{	soap_flag_PtzDirection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ptzControlReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ptzControlReq, 0, sizeof(struct _ns1__ptzControlReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_PtzDirection > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ptzControlReq(struct soap *soap, const struct _ns1__ptzControlReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ptzControlReq);
	if (soap_out__ns1__ptzControlReq(soap, tag?tag:"ns1:ptzControlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ptzControlReq * SOAP_FMAC4 soap_get__ns1__ptzControlReq(struct soap *soap, struct _ns1__ptzControlReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ptzControlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__nullifyDeviceRes(struct soap *soap, struct _ns1__nullifyDeviceRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__nullifyDeviceRes(struct soap *soap, const struct _ns1__nullifyDeviceRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__nullifyDeviceRes(struct soap *soap, const char *tag, int id, const struct _ns1__nullifyDeviceRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__nullifyDeviceRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceRes * SOAP_FMAC4 soap_in__ns1__nullifyDeviceRes(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__nullifyDeviceRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__nullifyDeviceRes, sizeof(struct _ns1__nullifyDeviceRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__nullifyDeviceRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__nullifyDeviceRes, 0, sizeof(struct _ns1__nullifyDeviceRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__nullifyDeviceRes(struct soap *soap, const struct _ns1__nullifyDeviceRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__nullifyDeviceRes);
	if (soap_out__ns1__nullifyDeviceRes(soap, tag?tag:"ns1:nullifyDeviceRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceRes * SOAP_FMAC4 soap_get__ns1__nullifyDeviceRes(struct soap *soap, struct _ns1__nullifyDeviceRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__nullifyDeviceRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__nullifyDeviceReq(struct soap *soap, struct _ns1__nullifyDeviceReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_string(soap, &a->DevKey);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__nullifyDeviceReq(struct soap *soap, const struct _ns1__nullifyDeviceReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_serialize_string(soap, &a->DevKey);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__nullifyDeviceReq(struct soap *soap, const char *tag, int id, const struct _ns1__nullifyDeviceReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__nullifyDeviceReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevKey", -1, &a->DevKey, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceReq * SOAP_FMAC4 soap_in__ns1__nullifyDeviceReq(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_DevKey = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__nullifyDeviceReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__nullifyDeviceReq, sizeof(struct _ns1__nullifyDeviceReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__nullifyDeviceReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_DevKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevKey", &a->DevKey, "xsd:string"))
				{	soap_flag_DevKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__nullifyDeviceReq, 0, sizeof(struct _ns1__nullifyDeviceReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__nullifyDeviceReq(struct soap *soap, const struct _ns1__nullifyDeviceReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__nullifyDeviceReq);
	if (soap_out__ns1__nullifyDeviceReq(soap, tag?tag:"ns1:nullifyDeviceReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceReq * SOAP_FMAC4 soap_get__ns1__nullifyDeviceReq(struct soap *soap, struct _ns1__nullifyDeviceReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__nullifyDeviceReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__addDeviceRes(struct soap *soap, struct _ns1__addDeviceRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__addDeviceRes(struct soap *soap, const struct _ns1__addDeviceRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addDeviceRes(struct soap *soap, const char *tag, int id, const struct _ns1__addDeviceRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addDeviceRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__addDeviceRes * SOAP_FMAC4 soap_in__ns1__addDeviceRes(struct soap *soap, const char *tag, struct _ns1__addDeviceRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__addDeviceRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addDeviceRes, sizeof(struct _ns1__addDeviceRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__addDeviceRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addDeviceRes, 0, sizeof(struct _ns1__addDeviceRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__addDeviceRes(struct soap *soap, const struct _ns1__addDeviceRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__addDeviceRes);
	if (soap_out__ns1__addDeviceRes(soap, tag?tag:"ns1:addDeviceRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceRes * SOAP_FMAC4 soap_get__ns1__addDeviceRes(struct soap *soap, struct _ns1__addDeviceRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addDeviceRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__addDeviceReq(struct soap *soap, struct _ns1__addDeviceReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	a->DeviceAll = NULL;
	a->Forcible = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__addDeviceReq(struct soap *soap, const struct _ns1__addDeviceReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_PointerTons1__ArrayOfDevice(soap, &a->DeviceAll);
	soap_serialize_PointerToxsd__boolean(soap, &a->Forcible);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addDeviceReq(struct soap *soap, const char *tag, int id, const struct _ns1__addDeviceReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addDeviceReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfDevice(soap, "ns1:DeviceAll", -1, &a->DeviceAll, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Forcible", -1, &a->Forcible, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__addDeviceReq * SOAP_FMAC4 soap_in__ns1__addDeviceReq(struct soap *soap, const char *tag, struct _ns1__addDeviceReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DeviceAll = 1;
	size_t soap_flag_Forcible = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__addDeviceReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addDeviceReq, sizeof(struct _ns1__addDeviceReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__addDeviceReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DeviceAll && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDevice(soap, "ns1:DeviceAll", &a->DeviceAll, "ns1:ArrayOfDevice"))
				{	soap_flag_DeviceAll--;
					continue;
				}
			if (soap_flag_Forcible && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Forcible", &a->Forcible, "xsd:boolean"))
				{	soap_flag_Forcible--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addDeviceReq, 0, sizeof(struct _ns1__addDeviceReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__addDeviceReq(struct soap *soap, const struct _ns1__addDeviceReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__addDeviceReq);
	if (soap_out__ns1__addDeviceReq(soap, tag?tag:"ns1:addDeviceReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceReq * SOAP_FMAC4 soap_get__ns1__addDeviceReq(struct soap *soap, struct _ns1__addDeviceReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addDeviceReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateChannelNameRes(struct soap *soap, struct _ns1__updateChannelNameRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateChannelNameRes(struct soap *soap, const struct _ns1__updateChannelNameRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateChannelNameRes(struct soap *soap, const char *tag, int id, const struct _ns1__updateChannelNameRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateChannelNameRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateChannelNameRes * SOAP_FMAC4 soap_in__ns1__updateChannelNameRes(struct soap *soap, const char *tag, struct _ns1__updateChannelNameRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateChannelNameRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateChannelNameRes, sizeof(struct _ns1__updateChannelNameRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateChannelNameRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateChannelNameRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateChannelNameRes, 0, sizeof(struct _ns1__updateChannelNameRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateChannelNameRes(struct soap *soap, const struct _ns1__updateChannelNameRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateChannelNameRes);
	if (soap_out__ns1__updateChannelNameRes(soap, tag?tag:"ns1:updateChannelNameRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateChannelNameRes * SOAP_FMAC4 soap_get__ns1__updateChannelNameRes(struct soap *soap, struct _ns1__updateChannelNameRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateChannelNameRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateChannelNameReq(struct soap *soap, struct _ns1__updateChannelNameReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_string(soap, &a->ChannelName);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateChannelNameReq(struct soap *soap, const struct _ns1__updateChannelNameReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->ChannelName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateChannelNameReq(struct soap *soap, const char *tag, int id, const struct _ns1__updateChannelNameReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateChannelNameReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ChannelName", -1, &a->ChannelName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateChannelNameReq * SOAP_FMAC4 soap_in__ns1__updateChannelNameReq(struct soap *soap, const char *tag, struct _ns1__updateChannelNameReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_ChannelName = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateChannelNameReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateChannelNameReq, sizeof(struct _ns1__updateChannelNameReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateChannelNameReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_ChannelName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ChannelName", &a->ChannelName, "xsd:string"))
				{	soap_flag_ChannelName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateChannelNameReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateChannelNameReq, 0, sizeof(struct _ns1__updateChannelNameReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateChannelNameReq(struct soap *soap, const struct _ns1__updateChannelNameReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateChannelNameReq);
	if (soap_out__ns1__updateChannelNameReq(soap, tag?tag:"ns1:updateChannelNameReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateChannelNameReq * SOAP_FMAC4 soap_get__ns1__updateChannelNameReq(struct soap *soap, struct _ns1__updateChannelNameReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateChannelNameReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__userLogoutRes(struct soap *soap, struct _ns1__userLogoutRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__userLogoutRes(struct soap *soap, const struct _ns1__userLogoutRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__userLogoutRes(struct soap *soap, const char *tag, int id, const struct _ns1__userLogoutRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__userLogoutRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__userLogoutRes * SOAP_FMAC4 soap_in__ns1__userLogoutRes(struct soap *soap, const char *tag, struct _ns1__userLogoutRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__userLogoutRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__userLogoutRes, sizeof(struct _ns1__userLogoutRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__userLogoutRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLogoutRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__userLogoutRes, 0, sizeof(struct _ns1__userLogoutRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__userLogoutRes(struct soap *soap, const struct _ns1__userLogoutRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__userLogoutRes);
	if (soap_out__ns1__userLogoutRes(soap, tag?tag:"ns1:userLogoutRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLogoutRes * SOAP_FMAC4 soap_get__ns1__userLogoutRes(struct soap *soap, struct _ns1__userLogoutRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__userLogoutRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__userLogoutReq(struct soap *soap, struct _ns1__userLogoutReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__userLogoutReq(struct soap *soap, const struct _ns1__userLogoutReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__userLogoutReq(struct soap *soap, const char *tag, int id, const struct _ns1__userLogoutReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__userLogoutReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__userLogoutReq * SOAP_FMAC4 soap_in__ns1__userLogoutReq(struct soap *soap, const char *tag, struct _ns1__userLogoutReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__userLogoutReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__userLogoutReq, sizeof(struct _ns1__userLogoutReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__userLogoutReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLogoutReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__userLogoutReq, 0, sizeof(struct _ns1__userLogoutReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__userLogoutReq(struct soap *soap, const struct _ns1__userLogoutReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__userLogoutReq);
	if (soap_out__ns1__userLogoutReq(soap, tag?tag:"ns1:userLogoutReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLogoutReq * SOAP_FMAC4 soap_get__ns1__userLogoutReq(struct soap *soap, struct _ns1__userLogoutReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__userLogoutReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDeviceBondedRes(struct soap *soap, struct _ns1__queryDeviceBondedRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_xsd__boolean(soap, &a->HasBonded);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDeviceBondedRes(struct soap *soap, const struct _ns1__queryDeviceBondedRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->HasBonded, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDeviceBondedRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryDeviceBondedRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDeviceBondedRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:HasBonded", -1, &a->HasBonded, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDeviceBondedRes * SOAP_FMAC4 soap_in__ns1__queryDeviceBondedRes(struct soap *soap, const char *tag, struct _ns1__queryDeviceBondedRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_HasBonded = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDeviceBondedRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDeviceBondedRes, sizeof(struct _ns1__queryDeviceBondedRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDeviceBondedRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_HasBonded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:HasBonded", &a->HasBonded, "xsd:boolean"))
				{	soap_flag_HasBonded--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceBondedRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDeviceBondedRes, 0, sizeof(struct _ns1__queryDeviceBondedRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_HasBonded > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDeviceBondedRes(struct soap *soap, const struct _ns1__queryDeviceBondedRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDeviceBondedRes);
	if (soap_out__ns1__queryDeviceBondedRes(soap, tag?tag:"ns1:queryDeviceBondedRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceBondedRes * SOAP_FMAC4 soap_get__ns1__queryDeviceBondedRes(struct soap *soap, struct _ns1__queryDeviceBondedRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDeviceBondedRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDeviceBondedReq(struct soap *soap, struct _ns1__queryDeviceBondedReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->DevID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDeviceBondedReq(struct soap *soap, const struct _ns1__queryDeviceBondedReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DevID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDeviceBondedReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryDeviceBondedReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDeviceBondedReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDeviceBondedReq * SOAP_FMAC4 soap_in__ns1__queryDeviceBondedReq(struct soap *soap, const char *tag, struct _ns1__queryDeviceBondedReq *a, const char *type)
{
	size_t soap_flag_DevID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDeviceBondedReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDeviceBondedReq, sizeof(struct _ns1__queryDeviceBondedReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDeviceBondedReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceBondedReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDeviceBondedReq, 0, sizeof(struct _ns1__queryDeviceBondedReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDeviceBondedReq(struct soap *soap, const struct _ns1__queryDeviceBondedReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDeviceBondedReq);
	if (soap_out__ns1__queryDeviceBondedReq(soap, tag?tag:"ns1:queryDeviceBondedReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceBondedReq * SOAP_FMAC4 soap_get__ns1__queryDeviceBondedReq(struct soap *soap, struct _ns1__queryDeviceBondedReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDeviceBondedReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryClientVersionRes(struct soap *soap, struct _ns1__queryClientVersionRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->Version);
	soap_default_string(soap, &a->DownloadAddress);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryClientVersionRes(struct soap *soap, const struct _ns1__queryClientVersionRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Version);
	soap_serialize_string(soap, &a->DownloadAddress);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryClientVersionRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryClientVersionRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryClientVersionRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Version", -1, &a->Version, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DownloadAddress", -1, &a->DownloadAddress, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryClientVersionRes * SOAP_FMAC4 soap_in__ns1__queryClientVersionRes(struct soap *soap, const char *tag, struct _ns1__queryClientVersionRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_Version = 1;
	size_t soap_flag_DownloadAddress = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryClientVersionRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryClientVersionRes, sizeof(struct _ns1__queryClientVersionRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryClientVersionRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_Version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Version", &a->Version, "xsd:string"))
				{	soap_flag_Version--;
					continue;
				}
			if (soap_flag_DownloadAddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DownloadAddress", &a->DownloadAddress, "xsd:string"))
				{	soap_flag_DownloadAddress--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryClientVersionRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryClientVersionRes, 0, sizeof(struct _ns1__queryClientVersionRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryClientVersionRes(struct soap *soap, const struct _ns1__queryClientVersionRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryClientVersionRes);
	if (soap_out__ns1__queryClientVersionRes(soap, tag?tag:"ns1:queryClientVersionRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryClientVersionRes * SOAP_FMAC4 soap_get__ns1__queryClientVersionRes(struct soap *soap, struct _ns1__queryClientVersionRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryClientVersionRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryClientVersionReq(struct soap *soap, struct _ns1__queryClientVersionReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUClientType(soap, &a->ClientType);
	soap_default_string(soap, &a->ApplicationID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryClientVersionReq(struct soap *soap, const struct _ns1__queryClientVersionReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ApplicationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryClientVersionReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryClientVersionReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryClientVersionReq), type))
		return soap->error;
	if (soap_out_ns1__MCUClientType(soap, "ns1:ClientType", -1, &a->ClientType, ""))
		return soap->error;
	if (a->ApplicationID)
	{	if (soap_out_string(soap, "ns1:ApplicationID", -1, &a->ApplicationID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:ApplicationID"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryClientVersionReq * SOAP_FMAC4 soap_in__ns1__queryClientVersionReq(struct soap *soap, const char *tag, struct _ns1__queryClientVersionReq *a, const char *type)
{
	size_t soap_flag_ClientType = 1;
	size_t soap_flag_ApplicationID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryClientVersionReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryClientVersionReq, sizeof(struct _ns1__queryClientVersionReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryClientVersionReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ClientType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUClientType(soap, "ns1:ClientType", &a->ClientType, "ns1:MCUClientType"))
				{	soap_flag_ClientType--;
					continue;
				}
			if (soap_flag_ApplicationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ApplicationID", &a->ApplicationID, "xsd:string"))
				{	soap_flag_ApplicationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryClientVersionReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryClientVersionReq, 0, sizeof(struct _ns1__queryClientVersionReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ClientType > 0 || soap_flag_ApplicationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryClientVersionReq(struct soap *soap, const struct _ns1__queryClientVersionReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryClientVersionReq);
	if (soap_out__ns1__queryClientVersionReq(soap, tag?tag:"ns1:queryClientVersionReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryClientVersionReq * SOAP_FMAC4 soap_get__ns1__queryClientVersionReq(struct soap *soap, struct _ns1__queryClientVersionReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryClientVersionReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryAndroidTokenRes(struct soap *soap, struct _ns1__queryAndroidTokenRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->UDID);
	soap_default_string(soap, &a->DeviceToken);
	soap_default_xsd__boolean(soap, &a->APNs);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryAndroidTokenRes(struct soap *soap, const struct _ns1__queryAndroidTokenRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->UDID);
	soap_serialize_string(soap, &a->DeviceToken);
	soap_embedded(soap, &a->APNs, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryAndroidTokenRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryAndroidTokenRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryAndroidTokenRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:UDID", -1, &a->UDID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DeviceToken", -1, &a->DeviceToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:APNs", -1, &a->APNs, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryAndroidTokenRes * SOAP_FMAC4 soap_in__ns1__queryAndroidTokenRes(struct soap *soap, const char *tag, struct _ns1__queryAndroidTokenRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_UDID = 1;
	size_t soap_flag_DeviceToken = 1;
	size_t soap_flag_APNs = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryAndroidTokenRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryAndroidTokenRes, sizeof(struct _ns1__queryAndroidTokenRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryAndroidTokenRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_UDID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UDID", &a->UDID, "xsd:string"))
				{	soap_flag_UDID--;
					continue;
				}
			if (soap_flag_DeviceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DeviceToken", &a->DeviceToken, "xsd:string"))
				{	soap_flag_DeviceToken--;
					continue;
				}
			if (soap_flag_APNs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:APNs", &a->APNs, "xsd:boolean"))
				{	soap_flag_APNs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryAndroidTokenRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryAndroidTokenRes, 0, sizeof(struct _ns1__queryAndroidTokenRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_APNs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryAndroidTokenRes(struct soap *soap, const struct _ns1__queryAndroidTokenRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryAndroidTokenRes);
	if (soap_out__ns1__queryAndroidTokenRes(soap, tag?tag:"ns1:queryAndroidTokenRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryAndroidTokenRes * SOAP_FMAC4 soap_get__ns1__queryAndroidTokenRes(struct soap *soap, struct _ns1__queryAndroidTokenRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryAndroidTokenRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryAndroidTokenReq(struct soap *soap, struct _ns1__queryAndroidTokenReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->UDID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryAndroidTokenReq(struct soap *soap, const struct _ns1__queryAndroidTokenReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->UDID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryAndroidTokenReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryAndroidTokenReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryAndroidTokenReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:UDID", -1, &a->UDID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryAndroidTokenReq * SOAP_FMAC4 soap_in__ns1__queryAndroidTokenReq(struct soap *soap, const char *tag, struct _ns1__queryAndroidTokenReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_UDID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryAndroidTokenReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryAndroidTokenReq, sizeof(struct _ns1__queryAndroidTokenReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryAndroidTokenReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_UDID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UDID", &a->UDID, "xsd:string"))
				{	soap_flag_UDID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryAndroidTokenReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryAndroidTokenReq, 0, sizeof(struct _ns1__queryAndroidTokenReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryAndroidTokenReq(struct soap *soap, const struct _ns1__queryAndroidTokenReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryAndroidTokenReq);
	if (soap_out__ns1__queryAndroidTokenReq(soap, tag?tag:"ns1:queryAndroidTokenReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryAndroidTokenReq * SOAP_FMAC4 soap_get__ns1__queryAndroidTokenReq(struct soap *soap, struct _ns1__queryAndroidTokenReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryAndroidTokenReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryAppleTokenRes(struct soap *soap, struct _ns1__queryAppleTokenRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->AppleUDID);
	soap_default_string(soap, &a->DeviceToken);
	soap_default_xsd__boolean(soap, &a->APNs);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryAppleTokenRes(struct soap *soap, const struct _ns1__queryAppleTokenRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->AppleUDID);
	soap_serialize_string(soap, &a->DeviceToken);
	soap_embedded(soap, &a->APNs, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryAppleTokenRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryAppleTokenRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryAppleTokenRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:AppleUDID", -1, &a->AppleUDID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DeviceToken", -1, &a->DeviceToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:APNs", -1, &a->APNs, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryAppleTokenRes * SOAP_FMAC4 soap_in__ns1__queryAppleTokenRes(struct soap *soap, const char *tag, struct _ns1__queryAppleTokenRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_AppleUDID = 1;
	size_t soap_flag_DeviceToken = 1;
	size_t soap_flag_APNs = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryAppleTokenRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryAppleTokenRes, sizeof(struct _ns1__queryAppleTokenRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryAppleTokenRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_AppleUDID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AppleUDID", &a->AppleUDID, "xsd:string"))
				{	soap_flag_AppleUDID--;
					continue;
				}
			if (soap_flag_DeviceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DeviceToken", &a->DeviceToken, "xsd:string"))
				{	soap_flag_DeviceToken--;
					continue;
				}
			if (soap_flag_APNs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:APNs", &a->APNs, "xsd:boolean"))
				{	soap_flag_APNs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryAppleTokenRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryAppleTokenRes, 0, sizeof(struct _ns1__queryAppleTokenRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_APNs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryAppleTokenRes(struct soap *soap, const struct _ns1__queryAppleTokenRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryAppleTokenRes);
	if (soap_out__ns1__queryAppleTokenRes(soap, tag?tag:"ns1:queryAppleTokenRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryAppleTokenRes * SOAP_FMAC4 soap_get__ns1__queryAppleTokenRes(struct soap *soap, struct _ns1__queryAppleTokenRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryAppleTokenRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryAppleTokenReq(struct soap *soap, struct _ns1__queryAppleTokenReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->AppleUDID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryAppleTokenReq(struct soap *soap, const struct _ns1__queryAppleTokenReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->AppleUDID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryAppleTokenReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryAppleTokenReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryAppleTokenReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:AppleUDID", -1, &a->AppleUDID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryAppleTokenReq * SOAP_FMAC4 soap_in__ns1__queryAppleTokenReq(struct soap *soap, const char *tag, struct _ns1__queryAppleTokenReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_AppleUDID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryAppleTokenReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryAppleTokenReq, sizeof(struct _ns1__queryAppleTokenReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryAppleTokenReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_AppleUDID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AppleUDID", &a->AppleUDID, "xsd:string"))
				{	soap_flag_AppleUDID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryAppleTokenReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryAppleTokenReq, 0, sizeof(struct _ns1__queryAppleTokenReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryAppleTokenReq(struct soap *soap, const struct _ns1__queryAppleTokenReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryAppleTokenReq);
	if (soap_out__ns1__queryAppleTokenReq(soap, tag?tag:"ns1:queryAppleTokenReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryAppleTokenReq * SOAP_FMAC4 soap_get__ns1__queryAppleTokenReq(struct soap *soap, struct _ns1__queryAppleTokenReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryAppleTokenReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDeviceSharingSourceRes(struct soap *soap, struct _ns1__queryDeviceSharingSourceRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->SharingSourceAccount);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDeviceSharingSourceRes(struct soap *soap, const struct _ns1__queryDeviceSharingSourceRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SharingSourceAccount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDeviceSharingSourceRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryDeviceSharingSourceRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDeviceSharingSourceRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SharingSourceAccount", -1, &a->SharingSourceAccount, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharingSourceRes * SOAP_FMAC4 soap_in__ns1__queryDeviceSharingSourceRes(struct soap *soap, const char *tag, struct _ns1__queryDeviceSharingSourceRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_SharingSourceAccount = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDeviceSharingSourceRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDeviceSharingSourceRes, sizeof(struct _ns1__queryDeviceSharingSourceRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDeviceSharingSourceRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_SharingSourceAccount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SharingSourceAccount", &a->SharingSourceAccount, "xsd:string"))
				{	soap_flag_SharingSourceAccount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceSharingSourceRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDeviceSharingSourceRes, 0, sizeof(struct _ns1__queryDeviceSharingSourceRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDeviceSharingSourceRes(struct soap *soap, const struct _ns1__queryDeviceSharingSourceRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDeviceSharingSourceRes);
	if (soap_out__ns1__queryDeviceSharingSourceRes(soap, tag?tag:"ns1:queryDeviceSharingSourceRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharingSourceRes * SOAP_FMAC4 soap_get__ns1__queryDeviceSharingSourceRes(struct soap *soap, struct _ns1__queryDeviceSharingSourceRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDeviceSharingSourceRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDeviceSharingSourceReq(struct soap *soap, struct _ns1__queryDeviceSharingSourceReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDeviceSharingSourceReq(struct soap *soap, const struct _ns1__queryDeviceSharingSourceReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDeviceSharingSourceReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryDeviceSharingSourceReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDeviceSharingSourceReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharingSourceReq * SOAP_FMAC4 soap_in__ns1__queryDeviceSharingSourceReq(struct soap *soap, const char *tag, struct _ns1__queryDeviceSharingSourceReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDeviceSharingSourceReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDeviceSharingSourceReq, sizeof(struct _ns1__queryDeviceSharingSourceReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDeviceSharingSourceReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceSharingSourceReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDeviceSharingSourceReq, 0, sizeof(struct _ns1__queryDeviceSharingSourceReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDeviceSharingSourceReq(struct soap *soap, const struct _ns1__queryDeviceSharingSourceReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDeviceSharingSourceReq);
	if (soap_out__ns1__queryDeviceSharingSourceReq(soap, tag?tag:"ns1:queryDeviceSharingSourceReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharingSourceReq * SOAP_FMAC4 soap_get__ns1__queryDeviceSharingSourceReq(struct soap *soap, struct _ns1__queryDeviceSharingSourceReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDeviceSharingSourceReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDeviceSharerRes(struct soap *soap, struct _ns1__queryDeviceSharerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->SharerList = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDeviceSharerRes(struct soap *soap, const struct _ns1__queryDeviceSharerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfDeviceSharer(soap, &a->SharerList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDeviceSharerRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryDeviceSharerRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDeviceSharerRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfDeviceSharer(soap, "ns1:SharerList", -1, &a->SharerList, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharerRes * SOAP_FMAC4 soap_in__ns1__queryDeviceSharerRes(struct soap *soap, const char *tag, struct _ns1__queryDeviceSharerRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_SharerList = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDeviceSharerRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDeviceSharerRes, sizeof(struct _ns1__queryDeviceSharerRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDeviceSharerRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_SharerList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDeviceSharer(soap, "ns1:SharerList", &a->SharerList, "ns1:ArrayOfDeviceSharer"))
				{	soap_flag_SharerList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceSharerRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDeviceSharerRes, 0, sizeof(struct _ns1__queryDeviceSharerRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDeviceSharerRes(struct soap *soap, const struct _ns1__queryDeviceSharerRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDeviceSharerRes);
	if (soap_out__ns1__queryDeviceSharerRes(soap, tag?tag:"ns1:queryDeviceSharerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharerRes * SOAP_FMAC4 soap_get__ns1__queryDeviceSharerRes(struct soap *soap, struct _ns1__queryDeviceSharerRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDeviceSharerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDeviceSharerReq(struct soap *soap, struct _ns1__queryDeviceSharerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDeviceSharerReq(struct soap *soap, const struct _ns1__queryDeviceSharerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDeviceSharerReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryDeviceSharerReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDeviceSharerReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharerReq * SOAP_FMAC4 soap_in__ns1__queryDeviceSharerReq(struct soap *soap, const char *tag, struct _ns1__queryDeviceSharerReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDeviceSharerReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDeviceSharerReq, sizeof(struct _ns1__queryDeviceSharerReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDeviceSharerReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceSharerReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDeviceSharerReq, 0, sizeof(struct _ns1__queryDeviceSharerReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDeviceSharerReq(struct soap *soap, const struct _ns1__queryDeviceSharerReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDeviceSharerReq);
	if (soap_out__ns1__queryDeviceSharerReq(soap, tag?tag:"ns1:queryDeviceSharerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharerReq * SOAP_FMAC4 soap_get__ns1__queryDeviceSharerReq(struct soap *soap, struct _ns1__queryDeviceSharerReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDeviceSharerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__nullifyDeviceSharerRes(struct soap *soap, struct _ns1__nullifyDeviceSharerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__nullifyDeviceSharerRes(struct soap *soap, const struct _ns1__nullifyDeviceSharerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__nullifyDeviceSharerRes(struct soap *soap, const char *tag, int id, const struct _ns1__nullifyDeviceSharerRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__nullifyDeviceSharerRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceSharerRes * SOAP_FMAC4 soap_in__ns1__nullifyDeviceSharerRes(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceSharerRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__nullifyDeviceSharerRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__nullifyDeviceSharerRes, sizeof(struct _ns1__nullifyDeviceSharerRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__nullifyDeviceSharerRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceSharerRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__nullifyDeviceSharerRes, 0, sizeof(struct _ns1__nullifyDeviceSharerRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__nullifyDeviceSharerRes(struct soap *soap, const struct _ns1__nullifyDeviceSharerRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__nullifyDeviceSharerRes);
	if (soap_out__ns1__nullifyDeviceSharerRes(soap, tag?tag:"ns1:nullifyDeviceSharerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceSharerRes * SOAP_FMAC4 soap_get__ns1__nullifyDeviceSharerRes(struct soap *soap, struct _ns1__nullifyDeviceSharerRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__nullifyDeviceSharerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__nullifyDeviceSharerReq(struct soap *soap, struct _ns1__nullifyDeviceSharerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_string(soap, &a->SharerAccount);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__nullifyDeviceSharerReq(struct soap *soap, const struct _ns1__nullifyDeviceSharerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->SharerAccount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__nullifyDeviceSharerReq(struct soap *soap, const char *tag, int id, const struct _ns1__nullifyDeviceSharerReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__nullifyDeviceSharerReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SharerAccount", -1, &a->SharerAccount, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceSharerReq * SOAP_FMAC4 soap_in__ns1__nullifyDeviceSharerReq(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceSharerReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_SharerAccount = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__nullifyDeviceSharerReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__nullifyDeviceSharerReq, sizeof(struct _ns1__nullifyDeviceSharerReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__nullifyDeviceSharerReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_SharerAccount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SharerAccount", &a->SharerAccount, "xsd:string"))
				{	soap_flag_SharerAccount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceSharerReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__nullifyDeviceSharerReq, 0, sizeof(struct _ns1__nullifyDeviceSharerReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__nullifyDeviceSharerReq(struct soap *soap, const struct _ns1__nullifyDeviceSharerReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__nullifyDeviceSharerReq);
	if (soap_out__ns1__nullifyDeviceSharerReq(soap, tag?tag:"ns1:nullifyDeviceSharerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceSharerReq * SOAP_FMAC4 soap_get__ns1__nullifyDeviceSharerReq(struct soap *soap, struct _ns1__nullifyDeviceSharerReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__nullifyDeviceSharerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__addDeviceSharerRes(struct soap *soap, struct _ns1__addDeviceSharerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__addDeviceSharerRes(struct soap *soap, const struct _ns1__addDeviceSharerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addDeviceSharerRes(struct soap *soap, const char *tag, int id, const struct _ns1__addDeviceSharerRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addDeviceSharerRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__addDeviceSharerRes * SOAP_FMAC4 soap_in__ns1__addDeviceSharerRes(struct soap *soap, const char *tag, struct _ns1__addDeviceSharerRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__addDeviceSharerRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addDeviceSharerRes, sizeof(struct _ns1__addDeviceSharerRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__addDeviceSharerRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceSharerRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addDeviceSharerRes, 0, sizeof(struct _ns1__addDeviceSharerRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__addDeviceSharerRes(struct soap *soap, const struct _ns1__addDeviceSharerRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__addDeviceSharerRes);
	if (soap_out__ns1__addDeviceSharerRes(soap, tag?tag:"ns1:addDeviceSharerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceSharerRes * SOAP_FMAC4 soap_get__ns1__addDeviceSharerRes(struct soap *soap, struct _ns1__addDeviceSharerRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addDeviceSharerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__addDeviceSharerReq(struct soap *soap, struct _ns1__addDeviceSharerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_string(soap, &a->SharerAccount);
	soap_default_int(soap, &a->SharingPriority);
	soap_default_string(soap, &a->SharingName);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__addDeviceSharerReq(struct soap *soap, const struct _ns1__addDeviceSharerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->SharerAccount);
	soap_embedded(soap, &a->SharingPriority, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->SharingName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addDeviceSharerReq(struct soap *soap, const char *tag, int id, const struct _ns1__addDeviceSharerReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addDeviceSharerReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SharerAccount", -1, &a->SharerAccount, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:SharingPriority", -1, &a->SharingPriority, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SharingName", -1, &a->SharingName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__addDeviceSharerReq * SOAP_FMAC4 soap_in__ns1__addDeviceSharerReq(struct soap *soap, const char *tag, struct _ns1__addDeviceSharerReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_SharerAccount = 1;
	size_t soap_flag_SharingPriority = 1;
	size_t soap_flag_SharingName = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__addDeviceSharerReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addDeviceSharerReq, sizeof(struct _ns1__addDeviceSharerReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__addDeviceSharerReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_SharerAccount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SharerAccount", &a->SharerAccount, "xsd:string"))
				{	soap_flag_SharerAccount--;
					continue;
				}
			if (soap_flag_SharingPriority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:SharingPriority", &a->SharingPriority, "xsd:int"))
				{	soap_flag_SharingPriority--;
					continue;
				}
			if (soap_flag_SharingName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SharingName", &a->SharingName, "xsd:string"))
				{	soap_flag_SharingName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceSharerReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addDeviceSharerReq, 0, sizeof(struct _ns1__addDeviceSharerReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_SharingPriority > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__addDeviceSharerReq(struct soap *soap, const struct _ns1__addDeviceSharerReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__addDeviceSharerReq);
	if (soap_out__ns1__addDeviceSharerReq(soap, tag?tag:"ns1:addDeviceSharerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceSharerReq * SOAP_FMAC4 soap_get__ns1__addDeviceSharerReq(struct soap *soap, struct _ns1__addDeviceSharerReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addDeviceSharerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDeviceStatusRes(struct soap *soap, struct _ns1__queryDeviceStatusRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_int(soap, &a->PageNo);
	soap_default_int(soap, &a->PageCount);
	soap_default_int(soap, &a->RecordCount);
	a->NodeList = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDeviceStatusRes(struct soap *soap, const struct _ns1__queryDeviceStatusRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->PageNo, SOAP_TYPE_int);
	soap_embedded(soap, &a->PageCount, SOAP_TYPE_int);
	soap_embedded(soap, &a->RecordCount, SOAP_TYPE_int);
	soap_serialize_PointerTons1__ArrayOfNodeDetails(soap, &a->NodeList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDeviceStatusRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryDeviceStatusRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDeviceStatusRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PageNo", -1, &a->PageNo, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PageCount", -1, &a->PageCount, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:RecordCount", -1, &a->RecordCount, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfNodeDetails(soap, "ns1:NodeList", -1, &a->NodeList, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDeviceStatusRes * SOAP_FMAC4 soap_in__ns1__queryDeviceStatusRes(struct soap *soap, const char *tag, struct _ns1__queryDeviceStatusRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_PageNo = 1;
	size_t soap_flag_PageCount = 1;
	size_t soap_flag_RecordCount = 1;
	size_t soap_flag_NodeList = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDeviceStatusRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDeviceStatusRes, sizeof(struct _ns1__queryDeviceStatusRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDeviceStatusRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_PageNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PageNo", &a->PageNo, "xsd:int"))
				{	soap_flag_PageNo--;
					continue;
				}
			if (soap_flag_PageCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PageCount", &a->PageCount, "xsd:int"))
				{	soap_flag_PageCount--;
					continue;
				}
			if (soap_flag_RecordCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:RecordCount", &a->RecordCount, "xsd:int"))
				{	soap_flag_RecordCount--;
					continue;
				}
			if (soap_flag_NodeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfNodeDetails(soap, "ns1:NodeList", &a->NodeList, "ns1:ArrayOfNodeDetails"))
				{	soap_flag_NodeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceStatusRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDeviceStatusRes, 0, sizeof(struct _ns1__queryDeviceStatusRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_PageNo > 0 || soap_flag_PageCount > 0 || soap_flag_RecordCount > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDeviceStatusRes(struct soap *soap, const struct _ns1__queryDeviceStatusRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDeviceStatusRes);
	if (soap_out__ns1__queryDeviceStatusRes(soap, tag?tag:"ns1:queryDeviceStatusRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceStatusRes * SOAP_FMAC4 soap_get__ns1__queryDeviceStatusRes(struct soap *soap, struct _ns1__queryDeviceStatusRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDeviceStatusRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDeviceStatusReq(struct soap *soap, struct _ns1__queryDeviceStatusReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	a->PageNo = NULL;
	soap_default_string(soap, &a->SearchID);
	a->PageSize = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDeviceStatusReq(struct soap *soap, const struct _ns1__queryDeviceStatusReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_PointerToint(soap, &a->PageNo);
	soap_serialize_string(soap, &a->SearchID);
	soap_serialize_PointerToint(soap, &a->PageSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDeviceStatusReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryDeviceStatusReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDeviceStatusReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:PageNo", -1, &a->PageNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SearchID", -1, &a->SearchID, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:PageSize", -1, &a->PageSize, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDeviceStatusReq * SOAP_FMAC4 soap_in__ns1__queryDeviceStatusReq(struct soap *soap, const char *tag, struct _ns1__queryDeviceStatusReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_PageNo = 1;
	size_t soap_flag_SearchID = 1;
	size_t soap_flag_PageSize = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDeviceStatusReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDeviceStatusReq, sizeof(struct _ns1__queryDeviceStatusReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDeviceStatusReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_PageNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:PageNo", &a->PageNo, "xsd:int"))
				{	soap_flag_PageNo--;
					continue;
				}
			if (soap_flag_SearchID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SearchID", &a->SearchID, "xsd:string"))
				{	soap_flag_SearchID--;
					continue;
				}
			if (soap_flag_PageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:PageSize", &a->PageSize, "xsd:int"))
				{	soap_flag_PageSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceStatusReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDeviceStatusReq, 0, sizeof(struct _ns1__queryDeviceStatusReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDeviceStatusReq(struct soap *soap, const struct _ns1__queryDeviceStatusReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDeviceStatusReq);
	if (soap_out__ns1__queryDeviceStatusReq(soap, tag?tag:"ns1:queryDeviceStatusReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceStatusReq * SOAP_FMAC4 soap_get__ns1__queryDeviceStatusReq(struct soap *soap, struct _ns1__queryDeviceStatusReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDeviceStatusReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAndroidTokenRes(struct soap *soap, struct _ns1__updateAndroidTokenRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAndroidTokenRes(struct soap *soap, const struct _ns1__updateAndroidTokenRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAndroidTokenRes(struct soap *soap, const char *tag, int id, const struct _ns1__updateAndroidTokenRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAndroidTokenRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAndroidTokenRes * SOAP_FMAC4 soap_in__ns1__updateAndroidTokenRes(struct soap *soap, const char *tag, struct _ns1__updateAndroidTokenRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAndroidTokenRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAndroidTokenRes, sizeof(struct _ns1__updateAndroidTokenRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAndroidTokenRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAndroidTokenRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAndroidTokenRes, 0, sizeof(struct _ns1__updateAndroidTokenRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAndroidTokenRes(struct soap *soap, const struct _ns1__updateAndroidTokenRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAndroidTokenRes);
	if (soap_out__ns1__updateAndroidTokenRes(soap, tag?tag:"ns1:updateAndroidTokenRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAndroidTokenRes * SOAP_FMAC4 soap_get__ns1__updateAndroidTokenRes(struct soap *soap, struct _ns1__updateAndroidTokenRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAndroidTokenRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAndroidTokenReq(struct soap *soap, struct _ns1__updateAndroidTokenReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->UDID);
	soap_default_string(soap, &a->DeviceToken);
	soap_default_xsd__boolean(soap, &a->APNs);
	soap_default_string(soap, &a->AndroidOS);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAndroidTokenReq(struct soap *soap, const struct _ns1__updateAndroidTokenReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->UDID);
	soap_serialize_string(soap, &a->DeviceToken);
	soap_embedded(soap, &a->APNs, SOAP_TYPE_xsd__boolean);
	soap_serialize_string(soap, &a->AndroidOS);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAndroidTokenReq(struct soap *soap, const char *tag, int id, const struct _ns1__updateAndroidTokenReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAndroidTokenReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:UDID", -1, &a->UDID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DeviceToken", -1, &a->DeviceToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:APNs", -1, &a->APNs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:AndroidOS", -1, &a->AndroidOS, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAndroidTokenReq * SOAP_FMAC4 soap_in__ns1__updateAndroidTokenReq(struct soap *soap, const char *tag, struct _ns1__updateAndroidTokenReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_UDID = 1;
	size_t soap_flag_DeviceToken = 1;
	size_t soap_flag_APNs = 1;
	size_t soap_flag_AndroidOS = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAndroidTokenReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAndroidTokenReq, sizeof(struct _ns1__updateAndroidTokenReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAndroidTokenReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_UDID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UDID", &a->UDID, "xsd:string"))
				{	soap_flag_UDID--;
					continue;
				}
			if (soap_flag_DeviceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DeviceToken", &a->DeviceToken, "xsd:string"))
				{	soap_flag_DeviceToken--;
					continue;
				}
			if (soap_flag_APNs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:APNs", &a->APNs, "xsd:boolean"))
				{	soap_flag_APNs--;
					continue;
				}
			if (soap_flag_AndroidOS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AndroidOS", &a->AndroidOS, "xsd:string"))
				{	soap_flag_AndroidOS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAndroidTokenReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAndroidTokenReq, 0, sizeof(struct _ns1__updateAndroidTokenReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_APNs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAndroidTokenReq(struct soap *soap, const struct _ns1__updateAndroidTokenReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAndroidTokenReq);
	if (soap_out__ns1__updateAndroidTokenReq(soap, tag?tag:"ns1:updateAndroidTokenReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAndroidTokenReq * SOAP_FMAC4 soap_get__ns1__updateAndroidTokenReq(struct soap *soap, struct _ns1__updateAndroidTokenReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAndroidTokenReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryPUEventLogRes(struct soap *soap, struct _ns1__queryPUEventLogRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_int(soap, &a->PageNo);
	soap_default_int(soap, &a->PageCount);
	soap_default_int(soap, &a->RecordCount);
	a->Log = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryPUEventLogRes(struct soap *soap, const struct _ns1__queryPUEventLogRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->PageNo, SOAP_TYPE_int);
	soap_embedded(soap, &a->PageCount, SOAP_TYPE_int);
	soap_embedded(soap, &a->RecordCount, SOAP_TYPE_int);
	soap_serialize_PointerTons1__ArrayOfPUEventLog(soap, &a->Log);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryPUEventLogRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryPUEventLogRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryPUEventLogRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PageNo", -1, &a->PageNo, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PageCount", -1, &a->PageCount, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:RecordCount", -1, &a->RecordCount, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfPUEventLog(soap, "ns1:Log", -1, &a->Log, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryPUEventLogRes * SOAP_FMAC4 soap_in__ns1__queryPUEventLogRes(struct soap *soap, const char *tag, struct _ns1__queryPUEventLogRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_PageNo = 1;
	size_t soap_flag_PageCount = 1;
	size_t soap_flag_RecordCount = 1;
	size_t soap_flag_Log = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryPUEventLogRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryPUEventLogRes, sizeof(struct _ns1__queryPUEventLogRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryPUEventLogRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_PageNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PageNo", &a->PageNo, "xsd:int"))
				{	soap_flag_PageNo--;
					continue;
				}
			if (soap_flag_PageCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PageCount", &a->PageCount, "xsd:int"))
				{	soap_flag_PageCount--;
					continue;
				}
			if (soap_flag_RecordCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:RecordCount", &a->RecordCount, "xsd:int"))
				{	soap_flag_RecordCount--;
					continue;
				}
			if (soap_flag_Log && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPUEventLog(soap, "ns1:Log", &a->Log, "ns1:ArrayOfPUEventLog"))
				{	soap_flag_Log--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryPUEventLogRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryPUEventLogRes, 0, sizeof(struct _ns1__queryPUEventLogRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_PageNo > 0 || soap_flag_PageCount > 0 || soap_flag_RecordCount > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryPUEventLogRes(struct soap *soap, const struct _ns1__queryPUEventLogRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryPUEventLogRes);
	if (soap_out__ns1__queryPUEventLogRes(soap, tag?tag:"ns1:queryPUEventLogRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryPUEventLogRes * SOAP_FMAC4 soap_get__ns1__queryPUEventLogRes(struct soap *soap, struct _ns1__queryPUEventLogRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryPUEventLogRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryPUEventLogReq(struct soap *soap, struct _ns1__queryPUEventLogReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->EventType = NULL;
	a->EventState = NULL;
	soap_default_time(soap, &a->StartTime);
	soap_default_time(soap, &a->EndTime);
	a->PageNo = NULL;
	soap_default_string(soap, &a->SearchID);
	a->PageSize = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryPUEventLogReq(struct soap *soap, const struct _ns1__queryPUEventLogReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_serialize_PointerTons1__EventType(soap, &a->EventType);
	soap_serialize_PointerTons1__EventState(soap, &a->EventState);
	soap_embedded(soap, &a->StartTime, SOAP_TYPE_time);
	soap_embedded(soap, &a->EndTime, SOAP_TYPE_time);
	soap_serialize_PointerToint(soap, &a->PageNo);
	soap_serialize_string(soap, &a->SearchID);
	soap_serialize_PointerToint(soap, &a->PageSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryPUEventLogReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryPUEventLogReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryPUEventLogReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_PointerTons1__EventType(soap, "ns1:EventType", -1, &a->EventType, ""))
		return soap->error;
	if (soap_out_PointerTons1__EventState(soap, "ns1:EventState", -1, &a->EventState, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:StartTime", -1, &a->StartTime, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:EndTime", -1, &a->EndTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:PageNo", -1, &a->PageNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SearchID", -1, &a->SearchID, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:PageSize", -1, &a->PageSize, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryPUEventLogReq * SOAP_FMAC4 soap_in__ns1__queryPUEventLogReq(struct soap *soap, const char *tag, struct _ns1__queryPUEventLogReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_EventType = 1;
	size_t soap_flag_EventState = 1;
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_EndTime = 1;
	size_t soap_flag_PageNo = 1;
	size_t soap_flag_SearchID = 1;
	size_t soap_flag_PageSize = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryPUEventLogReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryPUEventLogReq, sizeof(struct _ns1__queryPUEventLogReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryPUEventLogReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_EventType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__EventType(soap, "ns1:EventType", &a->EventType, "ns1:EventType"))
				{	soap_flag_EventType--;
					continue;
				}
			if (soap_flag_EventState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__EventState(soap, "ns1:EventState", &a->EventState, "ns1:EventState"))
				{	soap_flag_EventState--;
					continue;
				}
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:StartTime", &a->StartTime, "xsd:dateTime"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_EndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:EndTime", &a->EndTime, "xsd:dateTime"))
				{	soap_flag_EndTime--;
					continue;
				}
			if (soap_flag_PageNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:PageNo", &a->PageNo, "xsd:int"))
				{	soap_flag_PageNo--;
					continue;
				}
			if (soap_flag_SearchID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SearchID", &a->SearchID, "xsd:string"))
				{	soap_flag_SearchID--;
					continue;
				}
			if (soap_flag_PageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:PageSize", &a->PageSize, "xsd:int"))
				{	soap_flag_PageSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryPUEventLogReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryPUEventLogReq, 0, sizeof(struct _ns1__queryPUEventLogReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartTime > 0 || soap_flag_EndTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryPUEventLogReq(struct soap *soap, const struct _ns1__queryPUEventLogReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryPUEventLogReq);
	if (soap_out__ns1__queryPUEventLogReq(soap, tag?tag:"ns1:queryPUEventLogReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryPUEventLogReq * SOAP_FMAC4 soap_get__ns1__queryPUEventLogReq(struct soap *soap, struct _ns1__queryPUEventLogReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryPUEventLogReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryPUOnOffLogRes(struct soap *soap, struct _ns1__queryPUOnOffLogRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_int(soap, &a->PageNo);
	soap_default_int(soap, &a->PageCount);
	soap_default_int(soap, &a->RecordCount);
	a->Log = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryPUOnOffLogRes(struct soap *soap, const struct _ns1__queryPUOnOffLogRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->PageNo, SOAP_TYPE_int);
	soap_embedded(soap, &a->PageCount, SOAP_TYPE_int);
	soap_embedded(soap, &a->RecordCount, SOAP_TYPE_int);
	soap_serialize_PointerTons1__ArrayOfPUOnOffLog(soap, &a->Log);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryPUOnOffLogRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryPUOnOffLogRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryPUOnOffLogRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PageNo", -1, &a->PageNo, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PageCount", -1, &a->PageCount, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:RecordCount", -1, &a->RecordCount, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfPUOnOffLog(soap, "ns1:Log", -1, &a->Log, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryPUOnOffLogRes * SOAP_FMAC4 soap_in__ns1__queryPUOnOffLogRes(struct soap *soap, const char *tag, struct _ns1__queryPUOnOffLogRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_PageNo = 1;
	size_t soap_flag_PageCount = 1;
	size_t soap_flag_RecordCount = 1;
	size_t soap_flag_Log = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryPUOnOffLogRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryPUOnOffLogRes, sizeof(struct _ns1__queryPUOnOffLogRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryPUOnOffLogRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_PageNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PageNo", &a->PageNo, "xsd:int"))
				{	soap_flag_PageNo--;
					continue;
				}
			if (soap_flag_PageCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PageCount", &a->PageCount, "xsd:int"))
				{	soap_flag_PageCount--;
					continue;
				}
			if (soap_flag_RecordCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:RecordCount", &a->RecordCount, "xsd:int"))
				{	soap_flag_RecordCount--;
					continue;
				}
			if (soap_flag_Log && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPUOnOffLog(soap, "ns1:Log", &a->Log, "ns1:ArrayOfPUOnOffLog"))
				{	soap_flag_Log--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryPUOnOffLogRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryPUOnOffLogRes, 0, sizeof(struct _ns1__queryPUOnOffLogRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_PageNo > 0 || soap_flag_PageCount > 0 || soap_flag_RecordCount > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryPUOnOffLogRes(struct soap *soap, const struct _ns1__queryPUOnOffLogRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryPUOnOffLogRes);
	if (soap_out__ns1__queryPUOnOffLogRes(soap, tag?tag:"ns1:queryPUOnOffLogRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryPUOnOffLogRes * SOAP_FMAC4 soap_get__ns1__queryPUOnOffLogRes(struct soap *soap, struct _ns1__queryPUOnOffLogRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryPUOnOffLogRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryPUOnOffLogReq(struct soap *soap, struct _ns1__queryPUOnOffLogReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_time(soap, &a->StartTime);
	soap_default_time(soap, &a->EndTime);
	a->PageNo = NULL;
	soap_default_string(soap, &a->SearchID);
	a->PageSize = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryPUOnOffLogReq(struct soap *soap, const struct _ns1__queryPUOnOffLogReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->StartTime, SOAP_TYPE_time);
	soap_embedded(soap, &a->EndTime, SOAP_TYPE_time);
	soap_serialize_PointerToint(soap, &a->PageNo);
	soap_serialize_string(soap, &a->SearchID);
	soap_serialize_PointerToint(soap, &a->PageSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryPUOnOffLogReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryPUOnOffLogReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryPUOnOffLogReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:StartTime", -1, &a->StartTime, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:EndTime", -1, &a->EndTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:PageNo", -1, &a->PageNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SearchID", -1, &a->SearchID, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:PageSize", -1, &a->PageSize, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryPUOnOffLogReq * SOAP_FMAC4 soap_in__ns1__queryPUOnOffLogReq(struct soap *soap, const char *tag, struct _ns1__queryPUOnOffLogReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_EndTime = 1;
	size_t soap_flag_PageNo = 1;
	size_t soap_flag_SearchID = 1;
	size_t soap_flag_PageSize = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryPUOnOffLogReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryPUOnOffLogReq, sizeof(struct _ns1__queryPUOnOffLogReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryPUOnOffLogReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:StartTime", &a->StartTime, "xsd:dateTime"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_EndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:EndTime", &a->EndTime, "xsd:dateTime"))
				{	soap_flag_EndTime--;
					continue;
				}
			if (soap_flag_PageNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:PageNo", &a->PageNo, "xsd:int"))
				{	soap_flag_PageNo--;
					continue;
				}
			if (soap_flag_SearchID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SearchID", &a->SearchID, "xsd:string"))
				{	soap_flag_SearchID--;
					continue;
				}
			if (soap_flag_PageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:PageSize", &a->PageSize, "xsd:int"))
				{	soap_flag_PageSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryPUOnOffLogReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryPUOnOffLogReq, 0, sizeof(struct _ns1__queryPUOnOffLogReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartTime > 0 || soap_flag_EndTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryPUOnOffLogReq(struct soap *soap, const struct _ns1__queryPUOnOffLogReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryPUOnOffLogReq);
	if (soap_out__ns1__queryPUOnOffLogReq(soap, tag?tag:"ns1:queryPUOnOffLogReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryPUOnOffLogReq * SOAP_FMAC4 soap_get__ns1__queryPUOnOffLogReq(struct soap *soap, struct _ns1__queryPUOnOffLogReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryPUOnOffLogReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__inviteKeepAliveRes(struct soap *soap, struct _ns1__inviteKeepAliveRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->DialogID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__inviteKeepAliveRes(struct soap *soap, const struct _ns1__inviteKeepAliveRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DialogID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__inviteKeepAliveRes(struct soap *soap, const char *tag, int id, const struct _ns1__inviteKeepAliveRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__inviteKeepAliveRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DialogID", -1, &a->DialogID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__inviteKeepAliveRes * SOAP_FMAC4 soap_in__ns1__inviteKeepAliveRes(struct soap *soap, const char *tag, struct _ns1__inviteKeepAliveRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_DialogID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__inviteKeepAliveRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__inviteKeepAliveRes, sizeof(struct _ns1__inviteKeepAliveRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__inviteKeepAliveRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_DialogID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DialogID", &a->DialogID, "xsd:string"))
				{	soap_flag_DialogID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__inviteKeepAliveRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__inviteKeepAliveRes, 0, sizeof(struct _ns1__inviteKeepAliveRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__inviteKeepAliveRes(struct soap *soap, const struct _ns1__inviteKeepAliveRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__inviteKeepAliveRes);
	if (soap_out__ns1__inviteKeepAliveRes(soap, tag?tag:"ns1:inviteKeepAliveRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__inviteKeepAliveRes * SOAP_FMAC4 soap_get__ns1__inviteKeepAliveRes(struct soap *soap, struct _ns1__inviteKeepAliveRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__inviteKeepAliveRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__inviteKeepAliveReq(struct soap *soap, struct _ns1__inviteKeepAliveReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DialogID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__inviteKeepAliveReq(struct soap *soap, const struct _ns1__inviteKeepAliveReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DialogID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__inviteKeepAliveReq(struct soap *soap, const char *tag, int id, const struct _ns1__inviteKeepAliveReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__inviteKeepAliveReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DialogID", -1, &a->DialogID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__inviteKeepAliveReq * SOAP_FMAC4 soap_in__ns1__inviteKeepAliveReq(struct soap *soap, const char *tag, struct _ns1__inviteKeepAliveReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DialogID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__inviteKeepAliveReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__inviteKeepAliveReq, sizeof(struct _ns1__inviteKeepAliveReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__inviteKeepAliveReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DialogID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DialogID", &a->DialogID, "xsd:string"))
				{	soap_flag_DialogID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__inviteKeepAliveReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__inviteKeepAliveReq, 0, sizeof(struct _ns1__inviteKeepAliveReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__inviteKeepAliveReq(struct soap *soap, const struct _ns1__inviteKeepAliveReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__inviteKeepAliveReq);
	if (soap_out__ns1__inviteKeepAliveReq(soap, tag?tag:"ns1:inviteKeepAliveReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__inviteKeepAliveReq * SOAP_FMAC4 soap_get__ns1__inviteKeepAliveReq(struct soap *soap, struct _ns1__inviteKeepAliveReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__inviteKeepAliveReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__notifyNATResultRes(struct soap *soap, struct _ns1__notifyNATResultRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__notifyNATResultRes(struct soap *soap, const struct _ns1__notifyNATResultRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__notifyNATResultRes(struct soap *soap, const char *tag, int id, const struct _ns1__notifyNATResultRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__notifyNATResultRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__notifyNATResultRes * SOAP_FMAC4 soap_in__ns1__notifyNATResultRes(struct soap *soap, const char *tag, struct _ns1__notifyNATResultRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__notifyNATResultRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__notifyNATResultRes, sizeof(struct _ns1__notifyNATResultRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__notifyNATResultRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__notifyNATResultRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__notifyNATResultRes, 0, sizeof(struct _ns1__notifyNATResultRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__notifyNATResultRes(struct soap *soap, const struct _ns1__notifyNATResultRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__notifyNATResultRes);
	if (soap_out__ns1__notifyNATResultRes(soap, tag?tag:"ns1:notifyNATResultRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__notifyNATResultRes * SOAP_FMAC4 soap_get__ns1__notifyNATResultRes(struct soap *soap, struct _ns1__notifyNATResultRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__notifyNATResultRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__notifyNATResultReq(struct soap *soap, struct _ns1__notifyNATResultReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DialogID);
	soap_default_ns1__NATType(soap, &a->NATType);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__notifyNATResultReq(struct soap *soap, const struct _ns1__notifyNATResultReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DialogID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__notifyNATResultReq(struct soap *soap, const char *tag, int id, const struct _ns1__notifyNATResultReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__notifyNATResultReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DialogID", -1, &a->DialogID, ""))
		return soap->error;
	if (soap_out_ns1__NATType(soap, "ns1:NATType", -1, &a->NATType, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__notifyNATResultReq * SOAP_FMAC4 soap_in__ns1__notifyNATResultReq(struct soap *soap, const char *tag, struct _ns1__notifyNATResultReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DialogID = 1;
	size_t soap_flag_NATType = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__notifyNATResultReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__notifyNATResultReq, sizeof(struct _ns1__notifyNATResultReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__notifyNATResultReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DialogID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DialogID", &a->DialogID, "xsd:string"))
				{	soap_flag_DialogID--;
					continue;
				}
			if (soap_flag_NATType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__NATType(soap, "ns1:NATType", &a->NATType, "ns1:NATType"))
				{	soap_flag_NATType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__notifyNATResultReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__notifyNATResultReq, 0, sizeof(struct _ns1__notifyNATResultReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NATType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__notifyNATResultReq(struct soap *soap, const struct _ns1__notifyNATResultReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__notifyNATResultReq);
	if (soap_out__ns1__notifyNATResultReq(soap, tag?tag:"ns1:notifyNATResultReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__notifyNATResultReq * SOAP_FMAC4 soap_get__ns1__notifyNATResultReq(struct soap *soap, struct _ns1__notifyNATResultReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__notifyNATResultReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__subscribeEMailRes(struct soap *soap, struct _ns1__subscribeEMailRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__subscribeEMailRes(struct soap *soap, const struct _ns1__subscribeEMailRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__subscribeEMailRes(struct soap *soap, const char *tag, int id, const struct _ns1__subscribeEMailRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__subscribeEMailRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__subscribeEMailRes * SOAP_FMAC4 soap_in__ns1__subscribeEMailRes(struct soap *soap, const char *tag, struct _ns1__subscribeEMailRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__subscribeEMailRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__subscribeEMailRes, sizeof(struct _ns1__subscribeEMailRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__subscribeEMailRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeEMailRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__subscribeEMailRes, 0, sizeof(struct _ns1__subscribeEMailRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__subscribeEMailRes(struct soap *soap, const struct _ns1__subscribeEMailRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__subscribeEMailRes);
	if (soap_out__ns1__subscribeEMailRes(soap, tag?tag:"ns1:subscribeEMailRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeEMailRes * SOAP_FMAC4 soap_get__ns1__subscribeEMailRes(struct soap *soap, struct _ns1__subscribeEMailRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__subscribeEMailRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__subscribeEMailReq(struct soap *soap, struct _ns1__subscribeEMailReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_int(soap, &a->SubscribedFlag);
	soap_default_string(soap, &a->DevID);
	a->ChannelNo = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__subscribeEMailReq(struct soap *soap, const struct _ns1__subscribeEMailReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_embedded(soap, &a->SubscribedFlag, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->DevID);
	soap_serialize_PointerToint(soap, &a->ChannelNo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__subscribeEMailReq(struct soap *soap, const char *tag, int id, const struct _ns1__subscribeEMailReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__subscribeEMailReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:SubscribedFlag", -1, &a->SubscribedFlag, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__subscribeEMailReq * SOAP_FMAC4 soap_in__ns1__subscribeEMailReq(struct soap *soap, const char *tag, struct _ns1__subscribeEMailReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_SubscribedFlag = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__subscribeEMailReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__subscribeEMailReq, sizeof(struct _ns1__subscribeEMailReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__subscribeEMailReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_SubscribedFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:SubscribedFlag", &a->SubscribedFlag, "xsd:int"))
				{	soap_flag_SubscribedFlag--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeEMailReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__subscribeEMailReq, 0, sizeof(struct _ns1__subscribeEMailReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscribedFlag > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__subscribeEMailReq(struct soap *soap, const struct _ns1__subscribeEMailReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__subscribeEMailReq);
	if (soap_out__ns1__subscribeEMailReq(soap, tag?tag:"ns1:subscribeEMailReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeEMailReq * SOAP_FMAC4 soap_get__ns1__subscribeEMailReq(struct soap *soap, struct _ns1__subscribeEMailReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__subscribeEMailReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__subscribeSMSRes(struct soap *soap, struct _ns1__subscribeSMSRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__subscribeSMSRes(struct soap *soap, const struct _ns1__subscribeSMSRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__subscribeSMSRes(struct soap *soap, const char *tag, int id, const struct _ns1__subscribeSMSRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__subscribeSMSRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__subscribeSMSRes * SOAP_FMAC4 soap_in__ns1__subscribeSMSRes(struct soap *soap, const char *tag, struct _ns1__subscribeSMSRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__subscribeSMSRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__subscribeSMSRes, sizeof(struct _ns1__subscribeSMSRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__subscribeSMSRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeSMSRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__subscribeSMSRes, 0, sizeof(struct _ns1__subscribeSMSRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__subscribeSMSRes(struct soap *soap, const struct _ns1__subscribeSMSRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__subscribeSMSRes);
	if (soap_out__ns1__subscribeSMSRes(soap, tag?tag:"ns1:subscribeSMSRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeSMSRes * SOAP_FMAC4 soap_get__ns1__subscribeSMSRes(struct soap *soap, struct _ns1__subscribeSMSRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__subscribeSMSRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__subscribeSMSReq(struct soap *soap, struct _ns1__subscribeSMSReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_int(soap, &a->SubscribedFlag);
	soap_default_string(soap, &a->DevID);
	a->ChannelNo = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__subscribeSMSReq(struct soap *soap, const struct _ns1__subscribeSMSReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_embedded(soap, &a->SubscribedFlag, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->DevID);
	soap_serialize_PointerToint(soap, &a->ChannelNo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__subscribeSMSReq(struct soap *soap, const char *tag, int id, const struct _ns1__subscribeSMSReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__subscribeSMSReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:SubscribedFlag", -1, &a->SubscribedFlag, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__subscribeSMSReq * SOAP_FMAC4 soap_in__ns1__subscribeSMSReq(struct soap *soap, const char *tag, struct _ns1__subscribeSMSReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_SubscribedFlag = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__subscribeSMSReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__subscribeSMSReq, sizeof(struct _ns1__subscribeSMSReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__subscribeSMSReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_SubscribedFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:SubscribedFlag", &a->SubscribedFlag, "xsd:int"))
				{	soap_flag_SubscribedFlag--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeSMSReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__subscribeSMSReq, 0, sizeof(struct _ns1__subscribeSMSReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscribedFlag > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__subscribeSMSReq(struct soap *soap, const struct _ns1__subscribeSMSReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__subscribeSMSReq);
	if (soap_out__ns1__subscribeSMSReq(soap, tag?tag:"ns1:subscribeSMSReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeSMSReq * SOAP_FMAC4 soap_get__ns1__subscribeSMSReq(struct soap *soap, struct _ns1__subscribeSMSReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__subscribeSMSReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getNATServerRes(struct soap *soap, struct _ns1__getNATServerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->STUNServerList = NULL;
	a->TURNServerList = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getNATServerRes(struct soap *soap, const struct _ns1__getNATServerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSTUNServer(soap, &a->STUNServerList);
	soap_serialize_PointerTons1__ArrayOfTURNServer(soap, &a->TURNServerList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getNATServerRes(struct soap *soap, const char *tag, int id, const struct _ns1__getNATServerRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getNATServerRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSTUNServer(soap, "ns1:STUNServerList", -1, &a->STUNServerList, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTURNServer(soap, "ns1:TURNServerList", -1, &a->TURNServerList, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getNATServerRes * SOAP_FMAC4 soap_in__ns1__getNATServerRes(struct soap *soap, const char *tag, struct _ns1__getNATServerRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_STUNServerList = 1;
	size_t soap_flag_TURNServerList = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getNATServerRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getNATServerRes, sizeof(struct _ns1__getNATServerRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getNATServerRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_STUNServerList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSTUNServer(soap, "ns1:STUNServerList", &a->STUNServerList, "ns1:ArrayOfSTUNServer"))
				{	soap_flag_STUNServerList--;
					continue;
				}
			if (soap_flag_TURNServerList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTURNServer(soap, "ns1:TURNServerList", &a->TURNServerList, "ns1:ArrayOfTURNServer"))
				{	soap_flag_TURNServerList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getNATServerRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getNATServerRes, 0, sizeof(struct _ns1__getNATServerRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getNATServerRes(struct soap *soap, const struct _ns1__getNATServerRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getNATServerRes);
	if (soap_out__ns1__getNATServerRes(soap, tag?tag:"ns1:getNATServerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getNATServerRes * SOAP_FMAC4 soap_get__ns1__getNATServerRes(struct soap *soap, struct _ns1__getNATServerRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getNATServerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getNATServerReq(struct soap *soap, struct _ns1__getNATServerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getNATServerReq(struct soap *soap, const struct _ns1__getNATServerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getNATServerReq(struct soap *soap, const char *tag, int id, const struct _ns1__getNATServerReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getNATServerReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getNATServerReq * SOAP_FMAC4 soap_in__ns1__getNATServerReq(struct soap *soap, const char *tag, struct _ns1__getNATServerReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getNATServerReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getNATServerReq, sizeof(struct _ns1__getNATServerReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getNATServerReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getNATServerReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getNATServerReq, 0, sizeof(struct _ns1__getNATServerReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getNATServerReq(struct soap *soap, const struct _ns1__getNATServerReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getNATServerReq);
	if (soap_out__ns1__getNATServerReq(soap, tag?tag:"ns1:getNATServerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getNATServerReq * SOAP_FMAC4 soap_get__ns1__getNATServerReq(struct soap *soap, struct _ns1__getNATServerReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getNATServerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__byeRes(struct soap *soap, struct _ns1__byeRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__byeRes(struct soap *soap, const struct _ns1__byeRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__byeRes(struct soap *soap, const char *tag, int id, const struct _ns1__byeRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__byeRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__byeRes * SOAP_FMAC4 soap_in__ns1__byeRes(struct soap *soap, const char *tag, struct _ns1__byeRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__byeRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__byeRes, sizeof(struct _ns1__byeRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__byeRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__byeRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__byeRes, 0, sizeof(struct _ns1__byeRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__byeRes(struct soap *soap, const struct _ns1__byeRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__byeRes);
	if (soap_out__ns1__byeRes(soap, tag?tag:"ns1:byeRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__byeRes * SOAP_FMAC4 soap_get__ns1__byeRes(struct soap *soap, struct _ns1__byeRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__byeRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__byeReq(struct soap *soap, struct _ns1__byeReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__StreamType(soap, &a->StreamType);
	soap_default_string(soap, &a->DialogID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__byeReq(struct soap *soap, const struct _ns1__byeReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->DialogID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__byeReq(struct soap *soap, const char *tag, int id, const struct _ns1__byeReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__byeReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__StreamType(soap, "ns1:StreamType", -1, &a->StreamType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DialogID", -1, &a->DialogID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__byeReq * SOAP_FMAC4 soap_in__ns1__byeReq(struct soap *soap, const char *tag, struct _ns1__byeReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_StreamType = 1;
	size_t soap_flag_DialogID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__byeReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__byeReq, sizeof(struct _ns1__byeReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__byeReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_StreamType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StreamType(soap, "ns1:StreamType", &a->StreamType, "ns1:StreamType"))
				{	soap_flag_StreamType--;
					continue;
				}
			if (soap_flag_DialogID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DialogID", &a->DialogID, "xsd:string"))
				{	soap_flag_DialogID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__byeReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__byeReq, 0, sizeof(struct _ns1__byeReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_StreamType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__byeReq(struct soap *soap, const struct _ns1__byeReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__byeReq);
	if (soap_out__ns1__byeReq(soap, tag?tag:"ns1:byeReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__byeReq * SOAP_FMAC4 soap_get__ns1__byeReq(struct soap *soap, struct _ns1__byeReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__byeReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setAuxiliaryRes(struct soap *soap, struct _ns1__setAuxiliaryRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setAuxiliaryRes(struct soap *soap, const struct _ns1__setAuxiliaryRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setAuxiliaryRes(struct soap *soap, const char *tag, int id, const struct _ns1__setAuxiliaryRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setAuxiliaryRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryRes * SOAP_FMAC4 soap_in__ns1__setAuxiliaryRes(struct soap *soap, const char *tag, struct _ns1__setAuxiliaryRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setAuxiliaryRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setAuxiliaryRes, sizeof(struct _ns1__setAuxiliaryRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setAuxiliaryRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setAuxiliaryRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setAuxiliaryRes, 0, sizeof(struct _ns1__setAuxiliaryRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setAuxiliaryRes(struct soap *soap, const struct _ns1__setAuxiliaryRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setAuxiliaryRes);
	if (soap_out__ns1__setAuxiliaryRes(soap, tag?tag:"ns1:setAuxiliaryRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryRes * SOAP_FMAC4 soap_get__ns1__setAuxiliaryRes(struct soap *soap, struct _ns1__setAuxiliaryRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setAuxiliaryRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setAuxiliaryReq(struct soap *soap, struct _ns1__setAuxiliaryReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->Auxiliary = NULL;
	a->AuxiliaryState = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setAuxiliaryReq(struct soap *soap, const struct _ns1__setAuxiliaryReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_serialize_PointerTons1__AuxiliaryType(soap, &a->Auxiliary);
	soap_serialize_PointerTons1__AuxiliaryState(soap, &a->AuxiliaryState);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setAuxiliaryReq(struct soap *soap, const char *tag, int id, const struct _ns1__setAuxiliaryReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setAuxiliaryReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_PointerTons1__AuxiliaryType(soap, "ns1:Auxiliary", -1, &a->Auxiliary, ""))
		return soap->error;
	if (soap_out_PointerTons1__AuxiliaryState(soap, "ns1:AuxiliaryState", -1, &a->AuxiliaryState, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryReq * SOAP_FMAC4 soap_in__ns1__setAuxiliaryReq(struct soap *soap, const char *tag, struct _ns1__setAuxiliaryReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_Auxiliary = 1;
	size_t soap_flag_AuxiliaryState = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setAuxiliaryReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setAuxiliaryReq, sizeof(struct _ns1__setAuxiliaryReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setAuxiliaryReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_Auxiliary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AuxiliaryType(soap, "ns1:Auxiliary", &a->Auxiliary, "ns1:AuxiliaryType"))
				{	soap_flag_Auxiliary--;
					continue;
				}
			if (soap_flag_AuxiliaryState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AuxiliaryState(soap, "ns1:AuxiliaryState", &a->AuxiliaryState, "ns1:AuxiliaryState"))
				{	soap_flag_AuxiliaryState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setAuxiliaryReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setAuxiliaryReq, 0, sizeof(struct _ns1__setAuxiliaryReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setAuxiliaryReq(struct soap *soap, const struct _ns1__setAuxiliaryReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setAuxiliaryReq);
	if (soap_out__ns1__setAuxiliaryReq(soap, tag?tag:"ns1:setAuxiliaryReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryReq * SOAP_FMAC4 soap_get__ns1__setAuxiliaryReq(struct soap *soap, struct _ns1__setAuxiliaryReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setAuxiliaryReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAuxiliaryRes(struct soap *soap, struct _ns1__getAuxiliaryRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->AuxiliaryState = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAuxiliaryRes(struct soap *soap, const struct _ns1__getAuxiliaryRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AuxiliaryState(soap, &a->AuxiliaryState);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAuxiliaryRes(struct soap *soap, const char *tag, int id, const struct _ns1__getAuxiliaryRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAuxiliaryRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__AuxiliaryState(soap, "ns1:AuxiliaryState", -1, &a->AuxiliaryState, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryRes * SOAP_FMAC4 soap_in__ns1__getAuxiliaryRes(struct soap *soap, const char *tag, struct _ns1__getAuxiliaryRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_AuxiliaryState = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAuxiliaryRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAuxiliaryRes, sizeof(struct _ns1__getAuxiliaryRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAuxiliaryRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_AuxiliaryState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AuxiliaryState(soap, "ns1:AuxiliaryState", &a->AuxiliaryState, "ns1:AuxiliaryState"))
				{	soap_flag_AuxiliaryState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAuxiliaryRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAuxiliaryRes, 0, sizeof(struct _ns1__getAuxiliaryRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAuxiliaryRes(struct soap *soap, const struct _ns1__getAuxiliaryRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAuxiliaryRes);
	if (soap_out__ns1__getAuxiliaryRes(soap, tag?tag:"ns1:getAuxiliaryRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryRes * SOAP_FMAC4 soap_get__ns1__getAuxiliaryRes(struct soap *soap, struct _ns1__getAuxiliaryRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAuxiliaryRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAuxiliaryReq(struct soap *soap, struct _ns1__getAuxiliaryReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_ns1__AuxiliaryType(soap, &a->Auxiliary);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAuxiliaryReq(struct soap *soap, const struct _ns1__getAuxiliaryReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->Auxiliary, SOAP_TYPE_ns1__AuxiliaryType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAuxiliaryReq(struct soap *soap, const char *tag, int id, const struct _ns1__getAuxiliaryReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAuxiliaryReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_ns1__AuxiliaryType(soap, "ns1:Auxiliary", -1, &a->Auxiliary, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryReq * SOAP_FMAC4 soap_in__ns1__getAuxiliaryReq(struct soap *soap, const char *tag, struct _ns1__getAuxiliaryReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_Auxiliary = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAuxiliaryReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAuxiliaryReq, sizeof(struct _ns1__getAuxiliaryReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAuxiliaryReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_Auxiliary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__AuxiliaryType(soap, "ns1:Auxiliary", &a->Auxiliary, "ns1:AuxiliaryType"))
				{	soap_flag_Auxiliary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAuxiliaryReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAuxiliaryReq, 0, sizeof(struct _ns1__getAuxiliaryReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Auxiliary > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAuxiliaryReq(struct soap *soap, const struct _ns1__getAuxiliaryReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAuxiliaryReq);
	if (soap_out__ns1__getAuxiliaryReq(soap, tag?tag:"ns1:getAuxiliaryReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryReq * SOAP_FMAC4 soap_get__ns1__getAuxiliaryReq(struct soap *soap, struct _ns1__getAuxiliaryReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAuxiliaryReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getBackPasswordRes(struct soap *soap, struct _ns1__getBackPasswordRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->Address);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getBackPasswordRes(struct soap *soap, const struct _ns1__getBackPasswordRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Address);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getBackPasswordRes(struct soap *soap, const char *tag, int id, const struct _ns1__getBackPasswordRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getBackPasswordRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Address", -1, &a->Address, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getBackPasswordRes * SOAP_FMAC4 soap_in__ns1__getBackPasswordRes(struct soap *soap, const char *tag, struct _ns1__getBackPasswordRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_Address = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getBackPasswordRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getBackPasswordRes, sizeof(struct _ns1__getBackPasswordRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getBackPasswordRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Address", &a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getBackPasswordRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getBackPasswordRes, 0, sizeof(struct _ns1__getBackPasswordRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getBackPasswordRes(struct soap *soap, const struct _ns1__getBackPasswordRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getBackPasswordRes);
	if (soap_out__ns1__getBackPasswordRes(soap, tag?tag:"ns1:getBackPasswordRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getBackPasswordRes * SOAP_FMAC4 soap_get__ns1__getBackPasswordRes(struct soap *soap, struct _ns1__getBackPasswordRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getBackPasswordRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getBackPasswordReq(struct soap *soap, struct _ns1__getBackPasswordReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_ns1__DeliveryType(soap, &a->GetBackType);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getBackPasswordReq(struct soap *soap, const struct _ns1__getBackPasswordReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getBackPasswordReq(struct soap *soap, const char *tag, int id, const struct _ns1__getBackPasswordReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getBackPasswordReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_ns1__DeliveryType(soap, "ns1:GetBackType", -1, &a->GetBackType, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getBackPasswordReq * SOAP_FMAC4 soap_in__ns1__getBackPasswordReq(struct soap *soap, const char *tag, struct _ns1__getBackPasswordReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_GetBackType = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getBackPasswordReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getBackPasswordReq, sizeof(struct _ns1__getBackPasswordReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getBackPasswordReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_GetBackType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__DeliveryType(soap, "ns1:GetBackType", &a->GetBackType, "ns1:DeliveryType"))
				{	soap_flag_GetBackType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getBackPasswordReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getBackPasswordReq, 0, sizeof(struct _ns1__getBackPasswordReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetBackType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getBackPasswordReq(struct soap *soap, const struct _ns1__getBackPasswordReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getBackPasswordReq);
	if (soap_out__ns1__getBackPasswordReq(soap, tag?tag:"ns1:getBackPasswordReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getBackPasswordReq * SOAP_FMAC4 soap_get__ns1__getBackPasswordReq(struct soap *soap, struct _ns1__getBackPasswordReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getBackPasswordReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAccountRes(struct soap *soap, struct _ns1__getAccountRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Email);
	soap_default_string(soap, &a->MobileTel);
	a->Country = NULL;
	a->CountryTelCode = NULL;
	soap_default_string(soap, &a->IDCard);
	soap_default_string(soap, &a->Account);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAccountRes(struct soap *soap, const struct _ns1__getAccountRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_string(soap, &a->Email);
	soap_serialize_string(soap, &a->MobileTel);
	soap_serialize_PointerTons1__CountryAbbr2ISO3166(soap, &a->Country);
	soap_serialize_PointerTons1__CountryAbbr2ISO3166(soap, &a->CountryTelCode);
	soap_serialize_string(soap, &a->IDCard);
	soap_serialize_string(soap, &a->Account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAccountRes(struct soap *soap, const char *tag, int id, const struct _ns1__getAccountRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAccountRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Email", -1, &a->Email, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:MobileTel", -1, &a->MobileTel, ""))
		return soap->error;
	if (soap_out_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:Country", -1, &a->Country, ""))
		return soap->error;
	if (soap_out_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:CountryTelCode", -1, &a->CountryTelCode, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:IDCard", -1, &a->IDCard, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAccountRes * SOAP_FMAC4 soap_in__ns1__getAccountRes(struct soap *soap, const char *tag, struct _ns1__getAccountRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_Username = 1;
	size_t soap_flag_Email = 1;
	size_t soap_flag_MobileTel = 1;
	size_t soap_flag_Country = 1;
	size_t soap_flag_CountryTelCode = 1;
	size_t soap_flag_IDCard = 1;
	size_t soap_flag_Account = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAccountRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAccountRes, sizeof(struct _ns1__getAccountRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAccountRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Email && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Email", &a->Email, "xsd:string"))
				{	soap_flag_Email--;
					continue;
				}
			if (soap_flag_MobileTel && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:MobileTel", &a->MobileTel, "xsd:string"))
				{	soap_flag_MobileTel--;
					continue;
				}
			if (soap_flag_Country && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:Country", &a->Country, "ns1:CountryAbbr2ISO3166"))
				{	soap_flag_Country--;
					continue;
				}
			if (soap_flag_CountryTelCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:CountryTelCode", &a->CountryTelCode, "ns1:CountryAbbr2ISO3166"))
				{	soap_flag_CountryTelCode--;
					continue;
				}
			if (soap_flag_IDCard && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:IDCard", &a->IDCard, "xsd:string"))
				{	soap_flag_IDCard--;
					continue;
				}
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAccountRes, 0, sizeof(struct _ns1__getAccountRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAccountRes(struct soap *soap, const struct _ns1__getAccountRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAccountRes);
	if (soap_out__ns1__getAccountRes(soap, tag?tag:"ns1:getAccountRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountRes * SOAP_FMAC4 soap_get__ns1__getAccountRes(struct soap *soap, struct _ns1__getAccountRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAccountRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAccountReq(struct soap *soap, struct _ns1__getAccountReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAccountReq(struct soap *soap, const struct _ns1__getAccountReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAccountReq(struct soap *soap, const char *tag, int id, const struct _ns1__getAccountReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAccountReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAccountReq * SOAP_FMAC4 soap_in__ns1__getAccountReq(struct soap *soap, const char *tag, struct _ns1__getAccountReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAccountReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAccountReq, sizeof(struct _ns1__getAccountReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAccountReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAccountReq, 0, sizeof(struct _ns1__getAccountReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAccountReq(struct soap *soap, const struct _ns1__getAccountReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAccountReq);
	if (soap_out__ns1__getAccountReq(soap, tag?tag:"ns1:getAccountReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountReq * SOAP_FMAC4 soap_get__ns1__getAccountReq(struct soap *soap, struct _ns1__getAccountReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAccountReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAppleTokenRes(struct soap *soap, struct _ns1__updateAppleTokenRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAppleTokenRes(struct soap *soap, const struct _ns1__updateAppleTokenRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAppleTokenRes(struct soap *soap, const char *tag, int id, const struct _ns1__updateAppleTokenRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAppleTokenRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenRes * SOAP_FMAC4 soap_in__ns1__updateAppleTokenRes(struct soap *soap, const char *tag, struct _ns1__updateAppleTokenRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAppleTokenRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAppleTokenRes, sizeof(struct _ns1__updateAppleTokenRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAppleTokenRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAppleTokenRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAppleTokenRes, 0, sizeof(struct _ns1__updateAppleTokenRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAppleTokenRes(struct soap *soap, const struct _ns1__updateAppleTokenRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAppleTokenRes);
	if (soap_out__ns1__updateAppleTokenRes(soap, tag?tag:"ns1:updateAppleTokenRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenRes * SOAP_FMAC4 soap_get__ns1__updateAppleTokenRes(struct soap *soap, struct _ns1__updateAppleTokenRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAppleTokenRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAppleTokenReq(struct soap *soap, struct _ns1__updateAppleTokenReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->AppleUDID);
	soap_default_string(soap, &a->DeviceToken);
	soap_default_xsd__boolean(soap, &a->APNs);
	soap_default_string(soap, &a->AppleOS);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAppleTokenReq(struct soap *soap, const struct _ns1__updateAppleTokenReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->AppleUDID);
	soap_serialize_string(soap, &a->DeviceToken);
	soap_embedded(soap, &a->APNs, SOAP_TYPE_xsd__boolean);
	soap_serialize_string(soap, &a->AppleOS);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAppleTokenReq(struct soap *soap, const char *tag, int id, const struct _ns1__updateAppleTokenReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAppleTokenReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:AppleUDID", -1, &a->AppleUDID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DeviceToken", -1, &a->DeviceToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:APNs", -1, &a->APNs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:AppleOS", -1, &a->AppleOS, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenReq * SOAP_FMAC4 soap_in__ns1__updateAppleTokenReq(struct soap *soap, const char *tag, struct _ns1__updateAppleTokenReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_AppleUDID = 1;
	size_t soap_flag_DeviceToken = 1;
	size_t soap_flag_APNs = 1;
	size_t soap_flag_AppleOS = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAppleTokenReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAppleTokenReq, sizeof(struct _ns1__updateAppleTokenReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAppleTokenReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_AppleUDID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AppleUDID", &a->AppleUDID, "xsd:string"))
				{	soap_flag_AppleUDID--;
					continue;
				}
			if (soap_flag_DeviceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DeviceToken", &a->DeviceToken, "xsd:string"))
				{	soap_flag_DeviceToken--;
					continue;
				}
			if (soap_flag_APNs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:APNs", &a->APNs, "xsd:boolean"))
				{	soap_flag_APNs--;
					continue;
				}
			if (soap_flag_AppleOS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AppleOS", &a->AppleOS, "xsd:string"))
				{	soap_flag_AppleOS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAppleTokenReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAppleTokenReq, 0, sizeof(struct _ns1__updateAppleTokenReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_APNs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAppleTokenReq(struct soap *soap, const struct _ns1__updateAppleTokenReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAppleTokenReq);
	if (soap_out__ns1__updateAppleTokenReq(soap, tag?tag:"ns1:updateAppleTokenReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenReq * SOAP_FMAC4 soap_get__ns1__updateAppleTokenReq(struct soap *soap, struct _ns1__updateAppleTokenReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAppleTokenReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDeviceRes(struct soap *soap, struct _ns1__queryDeviceRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->NodeList = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDeviceRes(struct soap *soap, const struct _ns1__queryDeviceRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfNodeDetails(soap, &a->NodeList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDeviceRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryDeviceRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDeviceRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfNodeDetails(soap, "ns1:NodeList", -1, &a->NodeList, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDeviceRes * SOAP_FMAC4 soap_in__ns1__queryDeviceRes(struct soap *soap, const char *tag, struct _ns1__queryDeviceRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_NodeList = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDeviceRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDeviceRes, sizeof(struct _ns1__queryDeviceRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDeviceRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_NodeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfNodeDetails(soap, "ns1:NodeList", &a->NodeList, "ns1:ArrayOfNodeDetails"))
				{	soap_flag_NodeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDeviceRes, 0, sizeof(struct _ns1__queryDeviceRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDeviceRes(struct soap *soap, const struct _ns1__queryDeviceRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDeviceRes);
	if (soap_out__ns1__queryDeviceRes(soap, tag?tag:"ns1:queryDeviceRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceRes * SOAP_FMAC4 soap_get__ns1__queryDeviceRes(struct soap *soap, struct _ns1__queryDeviceRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDeviceRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDeviceReq(struct soap *soap, struct _ns1__queryDeviceReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDeviceReq(struct soap *soap, const struct _ns1__queryDeviceReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDeviceReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryDeviceReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDeviceReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDeviceReq * SOAP_FMAC4 soap_in__ns1__queryDeviceReq(struct soap *soap, const char *tag, struct _ns1__queryDeviceReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDeviceReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDeviceReq, sizeof(struct _ns1__queryDeviceReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDeviceReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDeviceReq, 0, sizeof(struct _ns1__queryDeviceReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDeviceReq(struct soap *soap, const struct _ns1__queryDeviceReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDeviceReq);
	if (soap_out__ns1__queryDeviceReq(soap, tag?tag:"ns1:queryDeviceReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceReq * SOAP_FMAC4 soap_get__ns1__queryDeviceReq(struct soap *soap, struct _ns1__queryDeviceReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDeviceReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updatePasswordRes(struct soap *soap, struct _ns1__updatePasswordRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updatePasswordRes(struct soap *soap, const struct _ns1__updatePasswordRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updatePasswordRes(struct soap *soap, const char *tag, int id, const struct _ns1__updatePasswordRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updatePasswordRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updatePasswordRes * SOAP_FMAC4 soap_in__ns1__updatePasswordRes(struct soap *soap, const char *tag, struct _ns1__updatePasswordRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updatePasswordRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updatePasswordRes, sizeof(struct _ns1__updatePasswordRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updatePasswordRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updatePasswordRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updatePasswordRes, 0, sizeof(struct _ns1__updatePasswordRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updatePasswordRes(struct soap *soap, const struct _ns1__updatePasswordRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updatePasswordRes);
	if (soap_out__ns1__updatePasswordRes(soap, tag?tag:"ns1:updatePasswordRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updatePasswordRes * SOAP_FMAC4 soap_get__ns1__updatePasswordRes(struct soap *soap, struct _ns1__updatePasswordRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updatePasswordRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updatePasswordReq(struct soap *soap, struct _ns1__updatePasswordReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->Password);
	soap_default_string(soap, &a->NewPassword);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updatePasswordReq(struct soap *soap, const struct _ns1__updatePasswordReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->Password);
	soap_serialize_string(soap, &a->NewPassword);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updatePasswordReq(struct soap *soap, const char *tag, int id, const struct _ns1__updatePasswordReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updatePasswordReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:NewPassword", -1, &a->NewPassword, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updatePasswordReq * SOAP_FMAC4 soap_in__ns1__updatePasswordReq(struct soap *soap, const char *tag, struct _ns1__updatePasswordReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_NewPassword = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updatePasswordReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updatePasswordReq, sizeof(struct _ns1__updatePasswordReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updatePasswordReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_NewPassword && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:NewPassword", &a->NewPassword, "xsd:string"))
				{	soap_flag_NewPassword--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updatePasswordReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updatePasswordReq, 0, sizeof(struct _ns1__updatePasswordReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updatePasswordReq(struct soap *soap, const struct _ns1__updatePasswordReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updatePasswordReq);
	if (soap_out__ns1__updatePasswordReq(soap, tag?tag:"ns1:updatePasswordReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updatePasswordReq * SOAP_FMAC4 soap_get__ns1__updatePasswordReq(struct soap *soap, struct _ns1__updatePasswordReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updatePasswordReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAccountRes(struct soap *soap, struct _ns1__updateAccountRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAccountRes(struct soap *soap, const struct _ns1__updateAccountRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAccountRes(struct soap *soap, const char *tag, int id, const struct _ns1__updateAccountRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAccountRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAccountRes * SOAP_FMAC4 soap_in__ns1__updateAccountRes(struct soap *soap, const char *tag, struct _ns1__updateAccountRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAccountRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAccountRes, sizeof(struct _ns1__updateAccountRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAccountRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAccountRes, 0, sizeof(struct _ns1__updateAccountRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAccountRes(struct soap *soap, const struct _ns1__updateAccountRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAccountRes);
	if (soap_out__ns1__updateAccountRes(soap, tag?tag:"ns1:updateAccountRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountRes * SOAP_FMAC4 soap_get__ns1__updateAccountRes(struct soap *soap, struct _ns1__updateAccountRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAccountRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAccountReq(struct soap *soap, struct _ns1__updateAccountReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->MobileTel);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAccountReq(struct soap *soap, const struct _ns1__updateAccountReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->Username);
	soap_serialize_string(soap, &a->MobileTel);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAccountReq(struct soap *soap, const char *tag, int id, const struct _ns1__updateAccountReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAccountReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:MobileTel", -1, &a->MobileTel, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAccountReq * SOAP_FMAC4 soap_in__ns1__updateAccountReq(struct soap *soap, const char *tag, struct _ns1__updateAccountReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_Username = 1;
	size_t soap_flag_MobileTel = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAccountReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAccountReq, sizeof(struct _ns1__updateAccountReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAccountReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_MobileTel && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:MobileTel", &a->MobileTel, "xsd:string"))
				{	soap_flag_MobileTel--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAccountReq, 0, sizeof(struct _ns1__updateAccountReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAccountReq(struct soap *soap, const struct _ns1__updateAccountReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAccountReq);
	if (soap_out__ns1__updateAccountReq(soap, tag?tag:"ns1:updateAccountReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountReq * SOAP_FMAC4 soap_get__ns1__updateAccountReq(struct soap *soap, struct _ns1__updateAccountReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAccountReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__createAccountRes(struct soap *soap, struct _ns1__createAccountRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__createAccountRes(struct soap *soap, const struct _ns1__createAccountRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createAccountRes(struct soap *soap, const char *tag, int id, const struct _ns1__createAccountRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createAccountRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__createAccountRes * SOAP_FMAC4 soap_in__ns1__createAccountRes(struct soap *soap, const char *tag, struct _ns1__createAccountRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__createAccountRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createAccountRes, sizeof(struct _ns1__createAccountRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__createAccountRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__createAccountRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__createAccountRes, 0, sizeof(struct _ns1__createAccountRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__createAccountRes(struct soap *soap, const struct _ns1__createAccountRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__createAccountRes);
	if (soap_out__ns1__createAccountRes(soap, tag?tag:"ns1:createAccountRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createAccountRes * SOAP_FMAC4 soap_get__ns1__createAccountRes(struct soap *soap, struct _ns1__createAccountRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createAccountRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__createAccountReq(struct soap *soap, struct _ns1__createAccountReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Password);
	soap_default_string(soap, &a->Email);
	soap_default_string(soap, &a->MobileTel);
	a->SecurityQuestion = NULL;
	soap_default_string(soap, &a->SecurityAnswer);
	a->Country = NULL;
	a->CountryTelCode = NULL;
	soap_default_string(soap, &a->IDCard);
	soap_default_string(soap, &a->ApplicationID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__createAccountReq(struct soap *soap, const struct _ns1__createAccountReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->Username);
	soap_serialize_string(soap, &a->Password);
	soap_serialize_string(soap, &a->Email);
	soap_serialize_string(soap, &a->MobileTel);
	soap_serialize_PointerToint(soap, &a->SecurityQuestion);
	soap_serialize_string(soap, &a->SecurityAnswer);
	soap_serialize_PointerTons1__CountryAbbr2ISO3166(soap, &a->Country);
	soap_serialize_PointerTons1__CountryAbbr2ISO3166(soap, &a->CountryTelCode);
	soap_serialize_string(soap, &a->IDCard);
	soap_serialize_string(soap, &a->ApplicationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createAccountReq(struct soap *soap, const char *tag, int id, const struct _ns1__createAccountReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createAccountReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Email", -1, &a->Email, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:MobileTel", -1, &a->MobileTel, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:SecurityQuestion", -1, &a->SecurityQuestion, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SecurityAnswer", -1, &a->SecurityAnswer, ""))
		return soap->error;
	if (soap_out_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:Country", -1, &a->Country, ""))
		return soap->error;
	if (soap_out_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:CountryTelCode", -1, &a->CountryTelCode, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:IDCard", -1, &a->IDCard, ""))
		return soap->error;
	if (a->ApplicationID)
	{	if (soap_out_string(soap, "ns1:ApplicationID", -1, &a->ApplicationID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:ApplicationID"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__createAccountReq * SOAP_FMAC4 soap_in__ns1__createAccountReq(struct soap *soap, const char *tag, struct _ns1__createAccountReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Email = 1;
	size_t soap_flag_MobileTel = 1;
	size_t soap_flag_SecurityQuestion = 1;
	size_t soap_flag_SecurityAnswer = 1;
	size_t soap_flag_Country = 1;
	size_t soap_flag_CountryTelCode = 1;
	size_t soap_flag_IDCard = 1;
	size_t soap_flag_ApplicationID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__createAccountReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createAccountReq, sizeof(struct _ns1__createAccountReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__createAccountReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Email && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Email", &a->Email, "xsd:string"))
				{	soap_flag_Email--;
					continue;
				}
			if (soap_flag_MobileTel && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:MobileTel", &a->MobileTel, "xsd:string"))
				{	soap_flag_MobileTel--;
					continue;
				}
			if (soap_flag_SecurityQuestion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:SecurityQuestion", &a->SecurityQuestion, "xsd:int"))
				{	soap_flag_SecurityQuestion--;
					continue;
				}
			if (soap_flag_SecurityAnswer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SecurityAnswer", &a->SecurityAnswer, "xsd:string"))
				{	soap_flag_SecurityAnswer--;
					continue;
				}
			if (soap_flag_Country && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:Country", &a->Country, "ns1:CountryAbbr2ISO3166"))
				{	soap_flag_Country--;
					continue;
				}
			if (soap_flag_CountryTelCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:CountryTelCode", &a->CountryTelCode, "ns1:CountryAbbr2ISO3166"))
				{	soap_flag_CountryTelCode--;
					continue;
				}
			if (soap_flag_IDCard && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:IDCard", &a->IDCard, "xsd:string"))
				{	soap_flag_IDCard--;
					continue;
				}
			if (soap_flag_ApplicationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ApplicationID", &a->ApplicationID, "xsd:string"))
				{	soap_flag_ApplicationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__createAccountReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__createAccountReq, 0, sizeof(struct _ns1__createAccountReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ApplicationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__createAccountReq(struct soap *soap, const struct _ns1__createAccountReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__createAccountReq);
	if (soap_out__ns1__createAccountReq(soap, tag?tag:"ns1:createAccountReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createAccountReq * SOAP_FMAC4 soap_get__ns1__createAccountReq(struct soap *soap, struct _ns1__createAccountReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createAccountReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPictureRes(struct soap *soap, struct _ns1__getPictureRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->PictureID);
	soap_default_string(soap, &a->Picture);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPictureRes(struct soap *soap, const struct _ns1__getPictureRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->PictureID);
	soap_serialize_string(soap, &a->Picture);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPictureRes(struct soap *soap, const char *tag, int id, const struct _ns1__getPictureRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPictureRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:PictureID", -1, &a->PictureID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Picture", -1, &a->Picture, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPictureRes * SOAP_FMAC4 soap_in__ns1__getPictureRes(struct soap *soap, const char *tag, struct _ns1__getPictureRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_PictureID = 1;
	size_t soap_flag_Picture = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPictureRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPictureRes, sizeof(struct _ns1__getPictureRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPictureRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_PictureID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PictureID", &a->PictureID, "xsd:string"))
				{	soap_flag_PictureID--;
					continue;
				}
			if (soap_flag_Picture && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Picture", &a->Picture, "xsd:string"))
				{	soap_flag_Picture--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPictureRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPictureRes, 0, sizeof(struct _ns1__getPictureRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPictureRes(struct soap *soap, const struct _ns1__getPictureRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPictureRes);
	if (soap_out__ns1__getPictureRes(soap, tag?tag:"ns1:getPictureRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPictureRes * SOAP_FMAC4 soap_get__ns1__getPictureRes(struct soap *soap, struct _ns1__getPictureRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPictureRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPictureReq(struct soap *soap, struct _ns1__getPictureReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->PictureID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPictureReq(struct soap *soap, const struct _ns1__getPictureReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->PictureID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPictureReq(struct soap *soap, const char *tag, int id, const struct _ns1__getPictureReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPictureReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:PictureID", -1, &a->PictureID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPictureReq * SOAP_FMAC4 soap_in__ns1__getPictureReq(struct soap *soap, const char *tag, struct _ns1__getPictureReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_PictureID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPictureReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPictureReq, sizeof(struct _ns1__getPictureReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPictureReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_PictureID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PictureID", &a->PictureID, "xsd:string"))
				{	soap_flag_PictureID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPictureReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPictureReq, 0, sizeof(struct _ns1__getPictureReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPictureReq(struct soap *soap, const struct _ns1__getPictureReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPictureReq);
	if (soap_out__ns1__getPictureReq(soap, tag?tag:"ns1:getPictureReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPictureReq * SOAP_FMAC4 soap_get__ns1__getPictureReq(struct soap *soap, struct _ns1__getPictureReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPictureReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__flaggedNoticeStatusRes(struct soap *soap, struct _ns1__flaggedNoticeStatusRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__flaggedNoticeStatusRes(struct soap *soap, const struct _ns1__flaggedNoticeStatusRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__flaggedNoticeStatusRes(struct soap *soap, const char *tag, int id, const struct _ns1__flaggedNoticeStatusRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__flaggedNoticeStatusRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__flaggedNoticeStatusRes * SOAP_FMAC4 soap_in__ns1__flaggedNoticeStatusRes(struct soap *soap, const char *tag, struct _ns1__flaggedNoticeStatusRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__flaggedNoticeStatusRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__flaggedNoticeStatusRes, sizeof(struct _ns1__flaggedNoticeStatusRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__flaggedNoticeStatusRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__flaggedNoticeStatusRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__flaggedNoticeStatusRes, 0, sizeof(struct _ns1__flaggedNoticeStatusRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__flaggedNoticeStatusRes(struct soap *soap, const struct _ns1__flaggedNoticeStatusRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__flaggedNoticeStatusRes);
	if (soap_out__ns1__flaggedNoticeStatusRes(soap, tag?tag:"ns1:flaggedNoticeStatusRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__flaggedNoticeStatusRes * SOAP_FMAC4 soap_get__ns1__flaggedNoticeStatusRes(struct soap *soap, struct _ns1__flaggedNoticeStatusRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__flaggedNoticeStatusRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__flaggedNoticeStatusReq(struct soap *soap, struct _ns1__flaggedNoticeStatusReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_ns1__NoticeStatus(soap, &a->Status);
	a->NoticeID = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__flaggedNoticeStatusReq(struct soap *soap, const struct _ns1__flaggedNoticeStatusReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_embedded(soap, &a->Status, SOAP_TYPE_ns1__NoticeStatus);
	soap_serialize_PointerTons1__ArrayOfString(soap, &a->NoticeID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__flaggedNoticeStatusReq(struct soap *soap, const char *tag, int id, const struct _ns1__flaggedNoticeStatusReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__flaggedNoticeStatusReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_ns1__NoticeStatus(soap, "ns1:Status", -1, &a->Status, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:NoticeID", -1, &a->NoticeID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__flaggedNoticeStatusReq * SOAP_FMAC4 soap_in__ns1__flaggedNoticeStatusReq(struct soap *soap, const char *tag, struct _ns1__flaggedNoticeStatusReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_Status = 1;
	size_t soap_flag_NoticeID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__flaggedNoticeStatusReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__flaggedNoticeStatusReq, sizeof(struct _ns1__flaggedNoticeStatusReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__flaggedNoticeStatusReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__NoticeStatus(soap, "ns1:Status", &a->Status, "ns1:NoticeStatus"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap_flag_NoticeID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:NoticeID", &a->NoticeID, "ns1:ArrayOfString"))
				{	soap_flag_NoticeID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__flaggedNoticeStatusReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__flaggedNoticeStatusReq, 0, sizeof(struct _ns1__flaggedNoticeStatusReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__flaggedNoticeStatusReq(struct soap *soap, const struct _ns1__flaggedNoticeStatusReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__flaggedNoticeStatusReq);
	if (soap_out__ns1__flaggedNoticeStatusReq(soap, tag?tag:"ns1:flaggedNoticeStatusReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__flaggedNoticeStatusReq * SOAP_FMAC4 soap_get__ns1__flaggedNoticeStatusReq(struct soap *soap, struct _ns1__flaggedNoticeStatusReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__flaggedNoticeStatusReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryNoticesRes(struct soap *soap, struct _ns1__queryNoticesRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_int(soap, &a->PageNo);
	soap_default_int(soap, &a->PageCount);
	soap_default_int(soap, &a->RecordCount);
	a->Notice = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryNoticesRes(struct soap *soap, const struct _ns1__queryNoticesRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->PageNo, SOAP_TYPE_int);
	soap_embedded(soap, &a->PageCount, SOAP_TYPE_int);
	soap_embedded(soap, &a->RecordCount, SOAP_TYPE_int);
	soap_serialize_PointerTons1__ArrayOfNotice(soap, &a->Notice);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryNoticesRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryNoticesRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryNoticesRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PageNo", -1, &a->PageNo, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PageCount", -1, &a->PageCount, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:RecordCount", -1, &a->RecordCount, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfNotice(soap, "ns1:Notice", -1, &a->Notice, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryNoticesRes * SOAP_FMAC4 soap_in__ns1__queryNoticesRes(struct soap *soap, const char *tag, struct _ns1__queryNoticesRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_PageNo = 1;
	size_t soap_flag_PageCount = 1;
	size_t soap_flag_RecordCount = 1;
	size_t soap_flag_Notice = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryNoticesRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryNoticesRes, sizeof(struct _ns1__queryNoticesRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryNoticesRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_PageNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PageNo", &a->PageNo, "xsd:int"))
				{	soap_flag_PageNo--;
					continue;
				}
			if (soap_flag_PageCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PageCount", &a->PageCount, "xsd:int"))
				{	soap_flag_PageCount--;
					continue;
				}
			if (soap_flag_RecordCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:RecordCount", &a->RecordCount, "xsd:int"))
				{	soap_flag_RecordCount--;
					continue;
				}
			if (soap_flag_Notice && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfNotice(soap, "ns1:Notice", &a->Notice, "ns1:ArrayOfNotice"))
				{	soap_flag_Notice--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryNoticesRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryNoticesRes, 0, sizeof(struct _ns1__queryNoticesRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_PageNo > 0 || soap_flag_PageCount > 0 || soap_flag_RecordCount > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryNoticesRes(struct soap *soap, const struct _ns1__queryNoticesRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryNoticesRes);
	if (soap_out__ns1__queryNoticesRes(soap, tag?tag:"ns1:queryNoticesRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryNoticesRes * SOAP_FMAC4 soap_get__ns1__queryNoticesRes(struct soap *soap, struct _ns1__queryNoticesRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryNoticesRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryNoticesReq(struct soap *soap, struct _ns1__queryNoticesReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	a->PageNo = NULL;
	soap_default_string(soap, &a->SearchID);
	a->PageSize = NULL;
	a->Status = NULL;
	a->Time = NULL;
	soap_default_string(soap, &a->Sender);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryNoticesReq(struct soap *soap, const struct _ns1__queryNoticesReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_PointerToint(soap, &a->PageNo);
	soap_serialize_string(soap, &a->SearchID);
	soap_serialize_PointerToint(soap, &a->PageSize);
	soap_serialize_PointerTons1__NoticeStatus(soap, &a->Status);
	soap_serialize_PointerTotime(soap, &a->Time);
	soap_serialize_string(soap, &a->Sender);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryNoticesReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryNoticesReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryNoticesReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:PageNo", -1, &a->PageNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SearchID", -1, &a->SearchID, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:PageSize", -1, &a->PageSize, ""))
		return soap->error;
	if (soap_out_PointerTons1__NoticeStatus(soap, "ns1:Status", -1, &a->Status, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Time", -1, &a->Time, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Sender", -1, &a->Sender, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryNoticesReq * SOAP_FMAC4 soap_in__ns1__queryNoticesReq(struct soap *soap, const char *tag, struct _ns1__queryNoticesReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_PageNo = 1;
	size_t soap_flag_SearchID = 1;
	size_t soap_flag_PageSize = 1;
	size_t soap_flag_Status = 1;
	size_t soap_flag_Time = 1;
	size_t soap_flag_Sender = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryNoticesReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryNoticesReq, sizeof(struct _ns1__queryNoticesReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryNoticesReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_PageNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:PageNo", &a->PageNo, "xsd:int"))
				{	soap_flag_PageNo--;
					continue;
				}
			if (soap_flag_SearchID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SearchID", &a->SearchID, "xsd:string"))
				{	soap_flag_SearchID--;
					continue;
				}
			if (soap_flag_PageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:PageSize", &a->PageSize, "xsd:int"))
				{	soap_flag_PageSize--;
					continue;
				}
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__NoticeStatus(soap, "ns1:Status", &a->Status, "ns1:NoticeStatus"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_Sender && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Sender", &a->Sender, "xsd:string"))
				{	soap_flag_Sender--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryNoticesReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryNoticesReq, 0, sizeof(struct _ns1__queryNoticesReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryNoticesReq(struct soap *soap, const struct _ns1__queryNoticesReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryNoticesReq);
	if (soap_out__ns1__queryNoticesReq(soap, tag?tag:"ns1:queryNoticesReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryNoticesReq * SOAP_FMAC4 soap_get__ns1__queryNoticesReq(struct soap *soap, struct _ns1__queryNoticesReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryNoticesReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getDeviceMatchingResultRes(struct soap *soap, struct _ns1__getDeviceMatchingResultRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->DevID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getDeviceMatchingResultRes(struct soap *soap, const struct _ns1__getDeviceMatchingResultRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DevID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDeviceMatchingResultRes(struct soap *soap, const char *tag, int id, const struct _ns1__getDeviceMatchingResultRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDeviceMatchingResultRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingResultRes * SOAP_FMAC4 soap_in__ns1__getDeviceMatchingResultRes(struct soap *soap, const char *tag, struct _ns1__getDeviceMatchingResultRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_DevID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getDeviceMatchingResultRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDeviceMatchingResultRes, sizeof(struct _ns1__getDeviceMatchingResultRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getDeviceMatchingResultRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDeviceMatchingResultRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDeviceMatchingResultRes, 0, sizeof(struct _ns1__getDeviceMatchingResultRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getDeviceMatchingResultRes(struct soap *soap, const struct _ns1__getDeviceMatchingResultRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getDeviceMatchingResultRes);
	if (soap_out__ns1__getDeviceMatchingResultRes(soap, tag?tag:"ns1:getDeviceMatchingResultRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingResultRes * SOAP_FMAC4 soap_get__ns1__getDeviceMatchingResultRes(struct soap *soap, struct _ns1__getDeviceMatchingResultRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDeviceMatchingResultRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getDeviceMatchingResultReq(struct soap *soap, struct _ns1__getDeviceMatchingResultReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->MatchingCode);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getDeviceMatchingResultReq(struct soap *soap, const struct _ns1__getDeviceMatchingResultReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->MatchingCode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDeviceMatchingResultReq(struct soap *soap, const char *tag, int id, const struct _ns1__getDeviceMatchingResultReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDeviceMatchingResultReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:MatchingCode", -1, &a->MatchingCode, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingResultReq * SOAP_FMAC4 soap_in__ns1__getDeviceMatchingResultReq(struct soap *soap, const char *tag, struct _ns1__getDeviceMatchingResultReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_MatchingCode = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getDeviceMatchingResultReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDeviceMatchingResultReq, sizeof(struct _ns1__getDeviceMatchingResultReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getDeviceMatchingResultReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_MatchingCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:MatchingCode", &a->MatchingCode, "xsd:string"))
				{	soap_flag_MatchingCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDeviceMatchingResultReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDeviceMatchingResultReq, 0, sizeof(struct _ns1__getDeviceMatchingResultReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getDeviceMatchingResultReq(struct soap *soap, const struct _ns1__getDeviceMatchingResultReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getDeviceMatchingResultReq);
	if (soap_out__ns1__getDeviceMatchingResultReq(soap, tag?tag:"ns1:getDeviceMatchingResultReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingResultReq * SOAP_FMAC4 soap_get__ns1__getDeviceMatchingResultReq(struct soap *soap, struct _ns1__getDeviceMatchingResultReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDeviceMatchingResultReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getDeviceMatchingCodeRes(struct soap *soap, struct _ns1__getDeviceMatchingCodeRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->MatchingCode);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getDeviceMatchingCodeRes(struct soap *soap, const struct _ns1__getDeviceMatchingCodeRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->MatchingCode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDeviceMatchingCodeRes(struct soap *soap, const char *tag, int id, const struct _ns1__getDeviceMatchingCodeRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDeviceMatchingCodeRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:MatchingCode", -1, &a->MatchingCode, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingCodeRes * SOAP_FMAC4 soap_in__ns1__getDeviceMatchingCodeRes(struct soap *soap, const char *tag, struct _ns1__getDeviceMatchingCodeRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_MatchingCode = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getDeviceMatchingCodeRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDeviceMatchingCodeRes, sizeof(struct _ns1__getDeviceMatchingCodeRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getDeviceMatchingCodeRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_MatchingCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:MatchingCode", &a->MatchingCode, "xsd:string"))
				{	soap_flag_MatchingCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDeviceMatchingCodeRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDeviceMatchingCodeRes, 0, sizeof(struct _ns1__getDeviceMatchingCodeRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getDeviceMatchingCodeRes(struct soap *soap, const struct _ns1__getDeviceMatchingCodeRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getDeviceMatchingCodeRes);
	if (soap_out__ns1__getDeviceMatchingCodeRes(soap, tag?tag:"ns1:getDeviceMatchingCodeRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingCodeRes * SOAP_FMAC4 soap_get__ns1__getDeviceMatchingCodeRes(struct soap *soap, struct _ns1__getDeviceMatchingCodeRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDeviceMatchingCodeRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getDeviceMatchingCodeReq(struct soap *soap, struct _ns1__getDeviceMatchingCodeReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getDeviceMatchingCodeReq(struct soap *soap, const struct _ns1__getDeviceMatchingCodeReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDeviceMatchingCodeReq(struct soap *soap, const char *tag, int id, const struct _ns1__getDeviceMatchingCodeReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDeviceMatchingCodeReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingCodeReq * SOAP_FMAC4 soap_in__ns1__getDeviceMatchingCodeReq(struct soap *soap, const char *tag, struct _ns1__getDeviceMatchingCodeReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getDeviceMatchingCodeReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDeviceMatchingCodeReq, sizeof(struct _ns1__getDeviceMatchingCodeReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getDeviceMatchingCodeReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDeviceMatchingCodeReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDeviceMatchingCodeReq, 0, sizeof(struct _ns1__getDeviceMatchingCodeReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getDeviceMatchingCodeReq(struct soap *soap, const struct _ns1__getDeviceMatchingCodeReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getDeviceMatchingCodeReq);
	if (soap_out__ns1__getDeviceMatchingCodeReq(soap, tag?tag:"ns1:getDeviceMatchingCodeReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingCodeReq * SOAP_FMAC4 soap_get__ns1__getDeviceMatchingCodeReq(struct soap *soap, struct _ns1__getDeviceMatchingCodeReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDeviceMatchingCodeReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getDynamicPasswordRes(struct soap *soap, struct _ns1__getDynamicPasswordRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getDynamicPasswordRes(struct soap *soap, const struct _ns1__getDynamicPasswordRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDynamicPasswordRes(struct soap *soap, const char *tag, int id, const struct _ns1__getDynamicPasswordRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDynamicPasswordRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getDynamicPasswordRes * SOAP_FMAC4 soap_in__ns1__getDynamicPasswordRes(struct soap *soap, const char *tag, struct _ns1__getDynamicPasswordRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getDynamicPasswordRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDynamicPasswordRes, sizeof(struct _ns1__getDynamicPasswordRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getDynamicPasswordRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDynamicPasswordRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDynamicPasswordRes, 0, sizeof(struct _ns1__getDynamicPasswordRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getDynamicPasswordRes(struct soap *soap, const struct _ns1__getDynamicPasswordRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getDynamicPasswordRes);
	if (soap_out__ns1__getDynamicPasswordRes(soap, tag?tag:"ns1:getDynamicPasswordRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDynamicPasswordRes * SOAP_FMAC4 soap_get__ns1__getDynamicPasswordRes(struct soap *soap, struct _ns1__getDynamicPasswordRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDynamicPasswordRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getDynamicPasswordReq(struct soap *soap, struct _ns1__getDynamicPasswordReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getDynamicPasswordReq(struct soap *soap, const struct _ns1__getDynamicPasswordReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDynamicPasswordReq(struct soap *soap, const char *tag, int id, const struct _ns1__getDynamicPasswordReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDynamicPasswordReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getDynamicPasswordReq * SOAP_FMAC4 soap_in__ns1__getDynamicPasswordReq(struct soap *soap, const char *tag, struct _ns1__getDynamicPasswordReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getDynamicPasswordReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDynamicPasswordReq, sizeof(struct _ns1__getDynamicPasswordReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getDynamicPasswordReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDynamicPasswordReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDynamicPasswordReq, 0, sizeof(struct _ns1__getDynamicPasswordReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getDynamicPasswordReq(struct soap *soap, const struct _ns1__getDynamicPasswordReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getDynamicPasswordReq);
	if (soap_out__ns1__getDynamicPasswordReq(soap, tag?tag:"ns1:getDynamicPasswordReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDynamicPasswordReq * SOAP_FMAC4 soap_get__ns1__getDynamicPasswordReq(struct soap *soap, struct _ns1__getDynamicPasswordReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDynamicPasswordReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getWirelessNetworkRes(struct soap *soap, struct _ns1__getWirelessNetworkRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_ns1__WirelessType(soap, &a->WirelessType);
	soap_default_string(soap, &a->SSID);
	soap_default_int(soap, &a->Intensity);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getWirelessNetworkRes(struct soap *soap, const struct _ns1__getWirelessNetworkRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SSID);
	soap_embedded(soap, &a->Intensity, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getWirelessNetworkRes(struct soap *soap, const char *tag, int id, const struct _ns1__getWirelessNetworkRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getWirelessNetworkRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_ns1__WirelessType(soap, "ns1:WirelessType", -1, &a->WirelessType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SSID", -1, &a->SSID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Intensity", -1, &a->Intensity, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getWirelessNetworkRes * SOAP_FMAC4 soap_in__ns1__getWirelessNetworkRes(struct soap *soap, const char *tag, struct _ns1__getWirelessNetworkRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_WirelessType = 1;
	size_t soap_flag_SSID = 1;
	size_t soap_flag_Intensity = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getWirelessNetworkRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getWirelessNetworkRes, sizeof(struct _ns1__getWirelessNetworkRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getWirelessNetworkRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_WirelessType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__WirelessType(soap, "ns1:WirelessType", &a->WirelessType, "ns1:WirelessType"))
				{	soap_flag_WirelessType--;
					continue;
				}
			if (soap_flag_SSID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SSID", &a->SSID, "xsd:string"))
				{	soap_flag_SSID--;
					continue;
				}
			if (soap_flag_Intensity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Intensity", &a->Intensity, "xsd:int"))
				{	soap_flag_Intensity--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getWirelessNetworkRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getWirelessNetworkRes, 0, sizeof(struct _ns1__getWirelessNetworkRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_WirelessType > 0 || soap_flag_Intensity > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getWirelessNetworkRes(struct soap *soap, const struct _ns1__getWirelessNetworkRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getWirelessNetworkRes);
	if (soap_out__ns1__getWirelessNetworkRes(soap, tag?tag:"ns1:getWirelessNetworkRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getWirelessNetworkRes * SOAP_FMAC4 soap_get__ns1__getWirelessNetworkRes(struct soap *soap, struct _ns1__getWirelessNetworkRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getWirelessNetworkRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getWirelessNetworkReq(struct soap *soap, struct _ns1__getWirelessNetworkReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getWirelessNetworkReq(struct soap *soap, const struct _ns1__getWirelessNetworkReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getWirelessNetworkReq(struct soap *soap, const char *tag, int id, const struct _ns1__getWirelessNetworkReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getWirelessNetworkReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getWirelessNetworkReq * SOAP_FMAC4 soap_in__ns1__getWirelessNetworkReq(struct soap *soap, const char *tag, struct _ns1__getWirelessNetworkReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getWirelessNetworkReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getWirelessNetworkReq, sizeof(struct _ns1__getWirelessNetworkReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getWirelessNetworkReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getWirelessNetworkReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getWirelessNetworkReq, 0, sizeof(struct _ns1__getWirelessNetworkReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getWirelessNetworkReq(struct soap *soap, const struct _ns1__getWirelessNetworkReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getWirelessNetworkReq);
	if (soap_out__ns1__getWirelessNetworkReq(soap, tag?tag:"ns1:getWirelessNetworkReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getWirelessNetworkReq * SOAP_FMAC4 soap_get__ns1__getWirelessNetworkReq(struct soap *soap, struct _ns1__getWirelessNetworkReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getWirelessNetworkReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setRelayRes(struct soap *soap, struct _ns1__setRelayRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setRelayRes(struct soap *soap, const struct _ns1__setRelayRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setRelayRes(struct soap *soap, const char *tag, int id, const struct _ns1__setRelayRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setRelayRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setRelayRes * SOAP_FMAC4 soap_in__ns1__setRelayRes(struct soap *soap, const char *tag, struct _ns1__setRelayRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setRelayRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setRelayRes, sizeof(struct _ns1__setRelayRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setRelayRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setRelayRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setRelayRes, 0, sizeof(struct _ns1__setRelayRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setRelayRes(struct soap *soap, const struct _ns1__setRelayRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setRelayRes);
	if (soap_out__ns1__setRelayRes(soap, tag?tag:"ns1:setRelayRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setRelayRes * SOAP_FMAC4 soap_get__ns1__setRelayRes(struct soap *soap, struct _ns1__setRelayRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setRelayRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setRelayReq(struct soap *soap, struct _ns1__setRelayReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->__sizeRelay = 0;
	a->Relay = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setRelayReq(struct soap *soap, const struct _ns1__setRelayReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	if (a->Relay)
	{	int i;
		for (i = 0; i < a->__sizeRelay; i++)
		{
			soap_embedded(soap, a->Relay + i, SOAP_TYPE_ns1__Relay);
			soap_serialize_ns1__Relay(soap, a->Relay + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setRelayReq(struct soap *soap, const char *tag, int id, const struct _ns1__setRelayReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setRelayReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (a->Relay)
	{	int i;
		for (i = 0; i < a->__sizeRelay; i++)
			if (soap_out_ns1__Relay(soap, "ns1:Relay", -1, a->Relay + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setRelayReq * SOAP_FMAC4 soap_in__ns1__setRelayReq(struct soap *soap, const char *tag, struct _ns1__setRelayReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	struct soap_blist *soap_blist_Relay = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setRelayReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setRelayReq, sizeof(struct _ns1__setRelayReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setRelayReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Relay", 1, NULL))
			{	if (a->Relay == NULL)
				{	if (soap_blist_Relay == NULL)
						soap_blist_Relay = soap_new_block(soap);
					a->Relay = (struct ns1__Relay *)soap_push_block(soap, soap_blist_Relay, sizeof(struct ns1__Relay));
					if (a->Relay == NULL)
						return NULL;
					soap_default_ns1__Relay(soap, a->Relay);
				}
				soap_revert(soap);
				if (soap_in_ns1__Relay(soap, "ns1:Relay", a->Relay, "ns1:Relay"))
				{	a->__sizeRelay++;
					a->Relay = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Relay)
			soap_pop_block(soap, soap_blist_Relay);
		if (a->__sizeRelay)
			a->Relay = (struct ns1__Relay *)soap_save_block(soap, soap_blist_Relay, NULL, 1);
		else
		{	a->Relay = NULL;
			if (soap_blist_Relay)
				soap_end_block(soap, soap_blist_Relay);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setRelayReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setRelayReq, 0, sizeof(struct _ns1__setRelayReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setRelayReq(struct soap *soap, const struct _ns1__setRelayReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setRelayReq);
	if (soap_out__ns1__setRelayReq(soap, tag?tag:"ns1:setRelayReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setRelayReq * SOAP_FMAC4 soap_get__ns1__setRelayReq(struct soap *soap, struct _ns1__setRelayReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setRelayReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getRelayRes(struct soap *soap, struct _ns1__getRelayRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeRelay = 0;
	a->Relay = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getRelayRes(struct soap *soap, const struct _ns1__getRelayRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Relay)
	{	int i;
		for (i = 0; i < a->__sizeRelay; i++)
		{
			soap_embedded(soap, a->Relay + i, SOAP_TYPE_ns1__Relay);
			soap_serialize_ns1__Relay(soap, a->Relay + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRelayRes(struct soap *soap, const char *tag, int id, const struct _ns1__getRelayRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRelayRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Relay)
	{	int i;
		for (i = 0; i < a->__sizeRelay; i++)
			if (soap_out_ns1__Relay(soap, "ns1:Relay", -1, a->Relay + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getRelayRes * SOAP_FMAC4 soap_in__ns1__getRelayRes(struct soap *soap, const char *tag, struct _ns1__getRelayRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Relay = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getRelayRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRelayRes, sizeof(struct _ns1__getRelayRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getRelayRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Relay", 1, NULL))
			{	if (a->Relay == NULL)
				{	if (soap_blist_Relay == NULL)
						soap_blist_Relay = soap_new_block(soap);
					a->Relay = (struct ns1__Relay *)soap_push_block(soap, soap_blist_Relay, sizeof(struct ns1__Relay));
					if (a->Relay == NULL)
						return NULL;
					soap_default_ns1__Relay(soap, a->Relay);
				}
				soap_revert(soap);
				if (soap_in_ns1__Relay(soap, "ns1:Relay", a->Relay, "ns1:Relay"))
				{	a->__sizeRelay++;
					a->Relay = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Relay)
			soap_pop_block(soap, soap_blist_Relay);
		if (a->__sizeRelay)
			a->Relay = (struct ns1__Relay *)soap_save_block(soap, soap_blist_Relay, NULL, 1);
		else
		{	a->Relay = NULL;
			if (soap_blist_Relay)
				soap_end_block(soap, soap_blist_Relay);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getRelayRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRelayRes, 0, sizeof(struct _ns1__getRelayRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getRelayRes(struct soap *soap, const struct _ns1__getRelayRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getRelayRes);
	if (soap_out__ns1__getRelayRes(soap, tag?tag:"ns1:getRelayRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getRelayRes * SOAP_FMAC4 soap_get__ns1__getRelayRes(struct soap *soap, struct _ns1__getRelayRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRelayRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getRelayReq(struct soap *soap, struct _ns1__getRelayReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getRelayReq(struct soap *soap, const struct _ns1__getRelayReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRelayReq(struct soap *soap, const char *tag, int id, const struct _ns1__getRelayReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRelayReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getRelayReq * SOAP_FMAC4 soap_in__ns1__getRelayReq(struct soap *soap, const char *tag, struct _ns1__getRelayReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getRelayReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRelayReq, sizeof(struct _ns1__getRelayReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getRelayReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getRelayReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRelayReq, 0, sizeof(struct _ns1__getRelayReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getRelayReq(struct soap *soap, const struct _ns1__getRelayReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getRelayReq);
	if (soap_out__ns1__getRelayReq(soap, tag?tag:"ns1:getRelayReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getRelayReq * SOAP_FMAC4 soap_get__ns1__getRelayReq(struct soap *soap, struct _ns1__getRelayReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRelayReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setRecordParamRes(struct soap *soap, struct _ns1__setRecordParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setRecordParamRes(struct soap *soap, const struct _ns1__setRecordParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setRecordParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__setRecordParamRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setRecordParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setRecordParamRes * SOAP_FMAC4 soap_in__ns1__setRecordParamRes(struct soap *soap, const char *tag, struct _ns1__setRecordParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setRecordParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setRecordParamRes, sizeof(struct _ns1__setRecordParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setRecordParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setRecordParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setRecordParamRes, 0, sizeof(struct _ns1__setRecordParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setRecordParamRes(struct soap *soap, const struct _ns1__setRecordParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setRecordParamRes);
	if (soap_out__ns1__setRecordParamRes(soap, tag?tag:"ns1:setRecordParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setRecordParamRes * SOAP_FMAC4 soap_get__ns1__setRecordParamRes(struct soap *soap, struct _ns1__setRecordParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setRecordParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setRecordParamReq(struct soap *soap, struct _ns1__setRecordParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->WorkSheet = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setRecordParamReq(struct soap *soap, const struct _ns1__setRecordParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_PointerTons1__WorkSheet(soap, &a->WorkSheet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setRecordParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__setRecordParamReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setRecordParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_PointerTons1__WorkSheet(soap, "ns1:WorkSheet", -1, &a->WorkSheet, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setRecordParamReq * SOAP_FMAC4 soap_in__ns1__setRecordParamReq(struct soap *soap, const char *tag, struct _ns1__setRecordParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_WorkSheet = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setRecordParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setRecordParamReq, sizeof(struct _ns1__setRecordParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setRecordParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_WorkSheet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__WorkSheet(soap, "ns1:WorkSheet", &a->WorkSheet, "ns1:WorkSheet"))
				{	soap_flag_WorkSheet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setRecordParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setRecordParamReq, 0, sizeof(struct _ns1__setRecordParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setRecordParamReq(struct soap *soap, const struct _ns1__setRecordParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setRecordParamReq);
	if (soap_out__ns1__setRecordParamReq(soap, tag?tag:"ns1:setRecordParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setRecordParamReq * SOAP_FMAC4 soap_get__ns1__setRecordParamReq(struct soap *soap, struct _ns1__setRecordParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setRecordParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getRecordParamRes(struct soap *soap, struct _ns1__getRecordParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->WorkSheet = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getRecordParamRes(struct soap *soap, const struct _ns1__getRecordParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__WorkSheet(soap, &a->WorkSheet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRecordParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__getRecordParamRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRecordParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__WorkSheet(soap, "ns1:WorkSheet", -1, &a->WorkSheet, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getRecordParamRes * SOAP_FMAC4 soap_in__ns1__getRecordParamRes(struct soap *soap, const char *tag, struct _ns1__getRecordParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_WorkSheet = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getRecordParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRecordParamRes, sizeof(struct _ns1__getRecordParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getRecordParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_WorkSheet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__WorkSheet(soap, "ns1:WorkSheet", &a->WorkSheet, "ns1:WorkSheet"))
				{	soap_flag_WorkSheet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getRecordParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRecordParamRes, 0, sizeof(struct _ns1__getRecordParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getRecordParamRes(struct soap *soap, const struct _ns1__getRecordParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getRecordParamRes);
	if (soap_out__ns1__getRecordParamRes(soap, tag?tag:"ns1:getRecordParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getRecordParamRes * SOAP_FMAC4 soap_get__ns1__getRecordParamRes(struct soap *soap, struct _ns1__getRecordParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRecordParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getRecordParamReq(struct soap *soap, struct _ns1__getRecordParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getRecordParamReq(struct soap *soap, const struct _ns1__getRecordParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRecordParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__getRecordParamReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRecordParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getRecordParamReq * SOAP_FMAC4 soap_in__ns1__getRecordParamReq(struct soap *soap, const char *tag, struct _ns1__getRecordParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getRecordParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRecordParamReq, sizeof(struct _ns1__getRecordParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getRecordParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getRecordParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRecordParamReq, 0, sizeof(struct _ns1__getRecordParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getRecordParamReq(struct soap *soap, const struct _ns1__getRecordParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getRecordParamReq);
	if (soap_out__ns1__getRecordParamReq(soap, tag?tag:"ns1:getRecordParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getRecordParamReq * SOAP_FMAC4 soap_get__ns1__getRecordParamReq(struct soap *soap, struct _ns1__getRecordParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRecordParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setPushWorkSheetRes(struct soap *soap, struct _ns1__setPushWorkSheetRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setPushWorkSheetRes(struct soap *soap, const struct _ns1__setPushWorkSheetRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setPushWorkSheetRes(struct soap *soap, const char *tag, int id, const struct _ns1__setPushWorkSheetRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setPushWorkSheetRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setPushWorkSheetRes * SOAP_FMAC4 soap_in__ns1__setPushWorkSheetRes(struct soap *soap, const char *tag, struct _ns1__setPushWorkSheetRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setPushWorkSheetRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setPushWorkSheetRes, sizeof(struct _ns1__setPushWorkSheetRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setPushWorkSheetRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPushWorkSheetRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setPushWorkSheetRes, 0, sizeof(struct _ns1__setPushWorkSheetRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setPushWorkSheetRes(struct soap *soap, const struct _ns1__setPushWorkSheetRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setPushWorkSheetRes);
	if (soap_out__ns1__setPushWorkSheetRes(soap, tag?tag:"ns1:setPushWorkSheetRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPushWorkSheetRes * SOAP_FMAC4 soap_get__ns1__setPushWorkSheetRes(struct soap *soap, struct _ns1__setPushWorkSheetRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setPushWorkSheetRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setPushWorkSheetReq(struct soap *soap, struct _ns1__setPushWorkSheetReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->WorkSheet = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setPushWorkSheetReq(struct soap *soap, const struct _ns1__setPushWorkSheetReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_PointerTons1__WorkSheet(soap, &a->WorkSheet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setPushWorkSheetReq(struct soap *soap, const char *tag, int id, const struct _ns1__setPushWorkSheetReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setPushWorkSheetReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_PointerTons1__WorkSheet(soap, "ns1:WorkSheet", -1, &a->WorkSheet, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setPushWorkSheetReq * SOAP_FMAC4 soap_in__ns1__setPushWorkSheetReq(struct soap *soap, const char *tag, struct _ns1__setPushWorkSheetReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_WorkSheet = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setPushWorkSheetReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setPushWorkSheetReq, sizeof(struct _ns1__setPushWorkSheetReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setPushWorkSheetReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_WorkSheet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__WorkSheet(soap, "ns1:WorkSheet", &a->WorkSheet, "ns1:WorkSheet"))
				{	soap_flag_WorkSheet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPushWorkSheetReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setPushWorkSheetReq, 0, sizeof(struct _ns1__setPushWorkSheetReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setPushWorkSheetReq(struct soap *soap, const struct _ns1__setPushWorkSheetReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setPushWorkSheetReq);
	if (soap_out__ns1__setPushWorkSheetReq(soap, tag?tag:"ns1:setPushWorkSheetReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPushWorkSheetReq * SOAP_FMAC4 soap_get__ns1__setPushWorkSheetReq(struct soap *soap, struct _ns1__setPushWorkSheetReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setPushWorkSheetReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPushWorkSheetRes(struct soap *soap, struct _ns1__getPushWorkSheetRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->WorkSheet = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPushWorkSheetRes(struct soap *soap, const struct _ns1__getPushWorkSheetRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__WorkSheet(soap, &a->WorkSheet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPushWorkSheetRes(struct soap *soap, const char *tag, int id, const struct _ns1__getPushWorkSheetRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPushWorkSheetRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__WorkSheet(soap, "ns1:WorkSheet", -1, &a->WorkSheet, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPushWorkSheetRes * SOAP_FMAC4 soap_in__ns1__getPushWorkSheetRes(struct soap *soap, const char *tag, struct _ns1__getPushWorkSheetRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_WorkSheet = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPushWorkSheetRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPushWorkSheetRes, sizeof(struct _ns1__getPushWorkSheetRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPushWorkSheetRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_WorkSheet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__WorkSheet(soap, "ns1:WorkSheet", &a->WorkSheet, "ns1:WorkSheet"))
				{	soap_flag_WorkSheet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPushWorkSheetRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPushWorkSheetRes, 0, sizeof(struct _ns1__getPushWorkSheetRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPushWorkSheetRes(struct soap *soap, const struct _ns1__getPushWorkSheetRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPushWorkSheetRes);
	if (soap_out__ns1__getPushWorkSheetRes(soap, tag?tag:"ns1:getPushWorkSheetRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPushWorkSheetRes * SOAP_FMAC4 soap_get__ns1__getPushWorkSheetRes(struct soap *soap, struct _ns1__getPushWorkSheetRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPushWorkSheetRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPushWorkSheetReq(struct soap *soap, struct _ns1__getPushWorkSheetReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPushWorkSheetReq(struct soap *soap, const struct _ns1__getPushWorkSheetReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPushWorkSheetReq(struct soap *soap, const char *tag, int id, const struct _ns1__getPushWorkSheetReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPushWorkSheetReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPushWorkSheetReq * SOAP_FMAC4 soap_in__ns1__getPushWorkSheetReq(struct soap *soap, const char *tag, struct _ns1__getPushWorkSheetReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPushWorkSheetReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPushWorkSheetReq, sizeof(struct _ns1__getPushWorkSheetReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPushWorkSheetReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPushWorkSheetReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPushWorkSheetReq, 0, sizeof(struct _ns1__getPushWorkSheetReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPushWorkSheetReq(struct soap *soap, const struct _ns1__getPushWorkSheetReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPushWorkSheetReq);
	if (soap_out__ns1__getPushWorkSheetReq(soap, tag?tag:"ns1:getPushWorkSheetReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPushWorkSheetReq * SOAP_FMAC4 soap_get__ns1__getPushWorkSheetReq(struct soap *soap, struct _ns1__getPushWorkSheetReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPushWorkSheetReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__subscribeAndroidPushRes(struct soap *soap, struct _ns1__subscribeAndroidPushRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__subscribeAndroidPushRes(struct soap *soap, const struct _ns1__subscribeAndroidPushRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__subscribeAndroidPushRes(struct soap *soap, const char *tag, int id, const struct _ns1__subscribeAndroidPushRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__subscribeAndroidPushRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__subscribeAndroidPushRes * SOAP_FMAC4 soap_in__ns1__subscribeAndroidPushRes(struct soap *soap, const char *tag, struct _ns1__subscribeAndroidPushRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__subscribeAndroidPushRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__subscribeAndroidPushRes, sizeof(struct _ns1__subscribeAndroidPushRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__subscribeAndroidPushRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeAndroidPushRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__subscribeAndroidPushRes, 0, sizeof(struct _ns1__subscribeAndroidPushRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__subscribeAndroidPushRes(struct soap *soap, const struct _ns1__subscribeAndroidPushRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__subscribeAndroidPushRes);
	if (soap_out__ns1__subscribeAndroidPushRes(soap, tag?tag:"ns1:subscribeAndroidPushRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeAndroidPushRes * SOAP_FMAC4 soap_get__ns1__subscribeAndroidPushRes(struct soap *soap, struct _ns1__subscribeAndroidPushRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__subscribeAndroidPushRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__subscribeAndroidPushReq(struct soap *soap, struct _ns1__subscribeAndroidPushReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_int(soap, &a->SubscribedFlag);
	soap_default_string(soap, &a->DevID);
	a->ChannelNo = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__subscribeAndroidPushReq(struct soap *soap, const struct _ns1__subscribeAndroidPushReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_embedded(soap, &a->SubscribedFlag, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->DevID);
	soap_serialize_PointerToint(soap, &a->ChannelNo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__subscribeAndroidPushReq(struct soap *soap, const char *tag, int id, const struct _ns1__subscribeAndroidPushReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__subscribeAndroidPushReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:SubscribedFlag", -1, &a->SubscribedFlag, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__subscribeAndroidPushReq * SOAP_FMAC4 soap_in__ns1__subscribeAndroidPushReq(struct soap *soap, const char *tag, struct _ns1__subscribeAndroidPushReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_SubscribedFlag = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__subscribeAndroidPushReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__subscribeAndroidPushReq, sizeof(struct _ns1__subscribeAndroidPushReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__subscribeAndroidPushReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_SubscribedFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:SubscribedFlag", &a->SubscribedFlag, "xsd:int"))
				{	soap_flag_SubscribedFlag--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeAndroidPushReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__subscribeAndroidPushReq, 0, sizeof(struct _ns1__subscribeAndroidPushReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscribedFlag > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__subscribeAndroidPushReq(struct soap *soap, const struct _ns1__subscribeAndroidPushReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__subscribeAndroidPushReq);
	if (soap_out__ns1__subscribeAndroidPushReq(soap, tag?tag:"ns1:subscribeAndroidPushReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeAndroidPushReq * SOAP_FMAC4 soap_get__ns1__subscribeAndroidPushReq(struct soap *soap, struct _ns1__subscribeAndroidPushReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__subscribeAndroidPushReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__subscribeApplePushRes(struct soap *soap, struct _ns1__subscribeApplePushRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__subscribeApplePushRes(struct soap *soap, const struct _ns1__subscribeApplePushRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__subscribeApplePushRes(struct soap *soap, const char *tag, int id, const struct _ns1__subscribeApplePushRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__subscribeApplePushRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__subscribeApplePushRes * SOAP_FMAC4 soap_in__ns1__subscribeApplePushRes(struct soap *soap, const char *tag, struct _ns1__subscribeApplePushRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__subscribeApplePushRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__subscribeApplePushRes, sizeof(struct _ns1__subscribeApplePushRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__subscribeApplePushRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeApplePushRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__subscribeApplePushRes, 0, sizeof(struct _ns1__subscribeApplePushRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__subscribeApplePushRes(struct soap *soap, const struct _ns1__subscribeApplePushRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__subscribeApplePushRes);
	if (soap_out__ns1__subscribeApplePushRes(soap, tag?tag:"ns1:subscribeApplePushRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeApplePushRes * SOAP_FMAC4 soap_get__ns1__subscribeApplePushRes(struct soap *soap, struct _ns1__subscribeApplePushRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__subscribeApplePushRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__subscribeApplePushReq(struct soap *soap, struct _ns1__subscribeApplePushReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_int(soap, &a->SubscribedFlag);
	soap_default_string(soap, &a->DevID);
	a->ChannelNo = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__subscribeApplePushReq(struct soap *soap, const struct _ns1__subscribeApplePushReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_embedded(soap, &a->SubscribedFlag, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->DevID);
	soap_serialize_PointerToint(soap, &a->ChannelNo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__subscribeApplePushReq(struct soap *soap, const char *tag, int id, const struct _ns1__subscribeApplePushReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__subscribeApplePushReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:SubscribedFlag", -1, &a->SubscribedFlag, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__subscribeApplePushReq * SOAP_FMAC4 soap_in__ns1__subscribeApplePushReq(struct soap *soap, const char *tag, struct _ns1__subscribeApplePushReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_SubscribedFlag = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__subscribeApplePushReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__subscribeApplePushReq, sizeof(struct _ns1__subscribeApplePushReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__subscribeApplePushReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_SubscribedFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:SubscribedFlag", &a->SubscribedFlag, "xsd:int"))
				{	soap_flag_SubscribedFlag--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeApplePushReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__subscribeApplePushReq, 0, sizeof(struct _ns1__subscribeApplePushReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscribedFlag > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__subscribeApplePushReq(struct soap *soap, const struct _ns1__subscribeApplePushReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__subscribeApplePushReq);
	if (soap_out__ns1__subscribeApplePushReq(soap, tag?tag:"ns1:subscribeApplePushReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeApplePushReq * SOAP_FMAC4 soap_get__ns1__subscribeApplePushReq(struct soap *soap, struct _ns1__subscribeApplePushReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__subscribeApplePushReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__VODRecord(struct soap *soap, struct ns1__VODRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->StartTime);
	soap_default_time(soap, &a->EndTime);
	a->FileSize = NULL;
	soap_default_string(soap, &a->ContentType);
	soap_default_string(soap, &a->Desc);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__VODRecord(struct soap *soap, const struct ns1__VODRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->StartTime, SOAP_TYPE_time);
	soap_embedded(soap, &a->EndTime, SOAP_TYPE_time);
	soap_serialize_PointerToLONG64(soap, &a->FileSize);
	soap_serialize_string(soap, &a->ContentType);
	soap_serialize_string(soap, &a->Desc);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__VODRecord(struct soap *soap, const char *tag, int id, const struct ns1__VODRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__VODRecord), type))
		return soap->error;
	if (soap_out_time(soap, "ns1:StartTime", -1, &a->StartTime, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:EndTime", -1, &a->EndTime, ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "ns1:FileSize", -1, &a->FileSize, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ContentType", -1, &a->ContentType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Desc", -1, &a->Desc, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__VODRecord * SOAP_FMAC4 soap_in_ns1__VODRecord(struct soap *soap, const char *tag, struct ns1__VODRecord *a, const char *type)
{
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_EndTime = 1;
	size_t soap_flag_FileSize = 1;
	size_t soap_flag_ContentType = 1;
	size_t soap_flag_Desc = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__VODRecord *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__VODRecord, sizeof(struct ns1__VODRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__VODRecord(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:StartTime", &a->StartTime, "xsd:dateTime"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_EndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:EndTime", &a->EndTime, "xsd:dateTime"))
				{	soap_flag_EndTime--;
					continue;
				}
			if (soap_flag_FileSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns1:FileSize", &a->FileSize, "xsd:long"))
				{	soap_flag_FileSize--;
					continue;
				}
			if (soap_flag_ContentType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ContentType", &a->ContentType, "xsd:string"))
				{	soap_flag_ContentType--;
					continue;
				}
			if (soap_flag_Desc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Desc", &a->Desc, "xsd:string"))
				{	soap_flag_Desc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__VODRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__VODRecord, 0, sizeof(struct ns1__VODRecord), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartTime > 0 || soap_flag_EndTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__VODRecord(struct soap *soap, const struct ns1__VODRecord *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__VODRecord);
	if (soap_out_ns1__VODRecord(soap, tag?tag:"ns1:VODRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VODRecord * SOAP_FMAC4 soap_get_ns1__VODRecord(struct soap *soap, struct ns1__VODRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__VODRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PrivacyMaskRegion(struct soap *soap, struct ns1__PrivacyMaskRegion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Left);
	soap_default_int(soap, &a->Top);
	soap_default_int(soap, &a->Right);
	soap_default_int(soap, &a->Bottom);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__PrivacyMaskRegion(struct soap *soap, const struct ns1__PrivacyMaskRegion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Left, SOAP_TYPE_int);
	soap_embedded(soap, &a->Top, SOAP_TYPE_int);
	soap_embedded(soap, &a->Right, SOAP_TYPE_int);
	soap_embedded(soap, &a->Bottom, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PrivacyMaskRegion(struct soap *soap, const char *tag, int id, const struct ns1__PrivacyMaskRegion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PrivacyMaskRegion), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:Left", -1, &a->Left, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Top", -1, &a->Top, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Right", -1, &a->Right, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Bottom", -1, &a->Bottom, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__PrivacyMaskRegion * SOAP_FMAC4 soap_in_ns1__PrivacyMaskRegion(struct soap *soap, const char *tag, struct ns1__PrivacyMaskRegion *a, const char *type)
{
	size_t soap_flag_Left = 1;
	size_t soap_flag_Top = 1;
	size_t soap_flag_Right = 1;
	size_t soap_flag_Bottom = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__PrivacyMaskRegion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PrivacyMaskRegion, sizeof(struct ns1__PrivacyMaskRegion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__PrivacyMaskRegion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Left && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Left", &a->Left, "xsd:int"))
				{	soap_flag_Left--;
					continue;
				}
			if (soap_flag_Top && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Top", &a->Top, "xsd:int"))
				{	soap_flag_Top--;
					continue;
				}
			if (soap_flag_Right && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Right", &a->Right, "xsd:int"))
				{	soap_flag_Right--;
					continue;
				}
			if (soap_flag_Bottom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Bottom", &a->Bottom, "xsd:int"))
				{	soap_flag_Bottom--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__PrivacyMaskRegion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PrivacyMaskRegion, 0, sizeof(struct ns1__PrivacyMaskRegion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Left > 0 || soap_flag_Top > 0 || soap_flag_Right > 0 || soap_flag_Bottom > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PrivacyMaskRegion(struct soap *soap, const struct ns1__PrivacyMaskRegion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PrivacyMaskRegion);
	if (soap_out_ns1__PrivacyMaskRegion(soap, tag?tag:"ns1:PrivacyMaskRegion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__PrivacyMaskRegion * SOAP_FMAC4 soap_get_ns1__PrivacyMaskRegion(struct soap *soap, struct ns1__PrivacyMaskRegion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PrivacyMaskRegion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__VMDGrid(struct soap *soap, struct ns1__VMDGrid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRow = 0;
	a->Row = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__VMDGrid(struct soap *soap, const struct ns1__VMDGrid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Row)
	{	int i;
		for (i = 0; i < a->__sizeRow; i++)
		{
			soap_serialize_string(soap, a->Row + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__VMDGrid(struct soap *soap, const char *tag, int id, const struct ns1__VMDGrid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__VMDGrid), type))
		return soap->error;
	if (a->Row)
	{	int i;
		for (i = 0; i < a->__sizeRow; i++)
			if (soap_out_string(soap, "ns1:Row", -1, a->Row + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__VMDGrid * SOAP_FMAC4 soap_in_ns1__VMDGrid(struct soap *soap, const char *tag, struct ns1__VMDGrid *a, const char *type)
{
	struct soap_blist *soap_blist_Row = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__VMDGrid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__VMDGrid, sizeof(struct ns1__VMDGrid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__VMDGrid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Row", 1, NULL))
			{	if (a->Row == NULL)
				{	if (soap_blist_Row == NULL)
						soap_blist_Row = soap_new_block(soap);
					a->Row = (char **)soap_push_block(soap, soap_blist_Row, sizeof(char *));
					if (a->Row == NULL)
						return NULL;
					*a->Row = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns1:Row", a->Row, "xsd:string"))
				{	a->__sizeRow++;
					a->Row = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Row)
			soap_pop_block(soap, soap_blist_Row);
		if (a->__sizeRow)
			a->Row = (char **)soap_save_block(soap, soap_blist_Row, NULL, 1);
		else
		{	a->Row = NULL;
			if (soap_blist_Row)
				soap_end_block(soap, soap_blist_Row);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__VMDGrid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__VMDGrid, 0, sizeof(struct ns1__VMDGrid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__VMDGrid(struct soap *soap, const struct ns1__VMDGrid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__VMDGrid);
	if (soap_out_ns1__VMDGrid(soap, tag?tag:"ns1:VMDGrid", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VMDGrid * SOAP_FMAC4 soap_get_ns1__VMDGrid(struct soap *soap, struct ns1__VMDGrid *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__VMDGrid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DevLog(struct soap *soap, struct ns1__DevLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_string(soap, &a->ChannelName);
	soap_default_int(soap, &a->LogType);
	soap_default_string(soap, &a->LogDesc);
	soap_default_time(soap, &a->LogTime);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DevLog(struct soap *soap, const struct ns1__DevLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->ChannelName);
	soap_embedded(soap, &a->LogType, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->LogDesc);
	soap_embedded(soap, &a->LogTime, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DevLog(struct soap *soap, const char *tag, int id, const struct ns1__DevLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DevLog), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ChannelName", -1, &a->ChannelName, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:LogType", -1, &a->LogType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LogDesc", -1, &a->LogDesc, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:LogTime", -1, &a->LogTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DevLog * SOAP_FMAC4 soap_in_ns1__DevLog(struct soap *soap, const char *tag, struct ns1__DevLog *a, const char *type)
{
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_ChannelName = 1;
	size_t soap_flag_LogType = 1;
	size_t soap_flag_LogDesc = 1;
	size_t soap_flag_LogTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DevLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DevLog, sizeof(struct ns1__DevLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DevLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_ChannelName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ChannelName", &a->ChannelName, "xsd:string"))
				{	soap_flag_ChannelName--;
					continue;
				}
			if (soap_flag_LogType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:LogType", &a->LogType, "xsd:int"))
				{	soap_flag_LogType--;
					continue;
				}
			if (soap_flag_LogDesc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LogDesc", &a->LogDesc, "xsd:string"))
				{	soap_flag_LogDesc--;
					continue;
				}
			if (soap_flag_LogTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:LogTime", &a->LogTime, "xsd:dateTime"))
				{	soap_flag_LogTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DevLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DevLog, 0, sizeof(struct ns1__DevLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_LogType > 0 || soap_flag_LogTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DevLog(struct soap *soap, const struct ns1__DevLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DevLog);
	if (soap_out_ns1__DevLog(soap, tag?tag:"ns1:DevLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DevLog * SOAP_FMAC4 soap_get_ns1__DevLog(struct soap *soap, struct ns1__DevLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DevLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfDevLog(struct soap *soap, struct ns1__ArrayOfDevLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDevLog = 0;
	a->DevLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfDevLog(struct soap *soap, const struct ns1__ArrayOfDevLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->DevLog)
	{	int i;
		for (i = 0; i < a->__sizeDevLog; i++)
		{
			soap_embedded(soap, a->DevLog + i, SOAP_TYPE_ns1__DevLog);
			soap_serialize_ns1__DevLog(soap, a->DevLog + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDevLog(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfDevLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDevLog), type))
		return soap->error;
	if (a->DevLog)
	{	int i;
		for (i = 0; i < a->__sizeDevLog; i++)
			if (soap_out_ns1__DevLog(soap, "ns1:DevLog", -1, a->DevLog + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfDevLog * SOAP_FMAC4 soap_in_ns1__ArrayOfDevLog(struct soap *soap, const char *tag, struct ns1__ArrayOfDevLog *a, const char *type)
{
	struct soap_blist *soap_blist_DevLog = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfDevLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDevLog, sizeof(struct ns1__ArrayOfDevLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfDevLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:DevLog", 1, NULL))
			{	if (a->DevLog == NULL)
				{	if (soap_blist_DevLog == NULL)
						soap_blist_DevLog = soap_new_block(soap);
					a->DevLog = (struct ns1__DevLog *)soap_push_block(soap, soap_blist_DevLog, sizeof(struct ns1__DevLog));
					if (a->DevLog == NULL)
						return NULL;
					soap_default_ns1__DevLog(soap, a->DevLog);
				}
				soap_revert(soap);
				if (soap_in_ns1__DevLog(soap, "ns1:DevLog", a->DevLog, "ns1:DevLog"))
				{	a->__sizeDevLog++;
					a->DevLog = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->DevLog)
			soap_pop_block(soap, soap_blist_DevLog);
		if (a->__sizeDevLog)
			a->DevLog = (struct ns1__DevLog *)soap_save_block(soap, soap_blist_DevLog, NULL, 1);
		else
		{	a->DevLog = NULL;
			if (soap_blist_DevLog)
				soap_end_block(soap, soap_blist_DevLog);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfDevLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDevLog, 0, sizeof(struct ns1__ArrayOfDevLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfDevLog(struct soap *soap, const struct ns1__ArrayOfDevLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfDevLog);
	if (soap_out_ns1__ArrayOfDevLog(soap, tag?tag:"ns1:ArrayOfDevLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfDevLog * SOAP_FMAC4 soap_get_ns1__ArrayOfDevLog(struct soap *soap, struct ns1__ArrayOfDevLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDevLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PuLog(struct soap *soap, struct ns1__PuLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_string(soap, &a->ChannelName);
	soap_default_int(soap, &a->LogType);
	soap_default_string(soap, &a->LogDesc);
	soap_default_string(soap, &a->AddTime);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__PuLog(struct soap *soap, const struct ns1__PuLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->ChannelName);
	soap_embedded(soap, &a->LogType, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->LogDesc);
	soap_serialize_string(soap, &a->AddTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PuLog(struct soap *soap, const char *tag, int id, const struct ns1__PuLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PuLog), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ChannelName", -1, &a->ChannelName, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:LogType", -1, &a->LogType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LogDesc", -1, &a->LogDesc, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:AddTime", -1, &a->AddTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__PuLog * SOAP_FMAC4 soap_in_ns1__PuLog(struct soap *soap, const char *tag, struct ns1__PuLog *a, const char *type)
{
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_ChannelName = 1;
	size_t soap_flag_LogType = 1;
	size_t soap_flag_LogDesc = 1;
	size_t soap_flag_AddTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__PuLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PuLog, sizeof(struct ns1__PuLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__PuLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_ChannelName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ChannelName", &a->ChannelName, "xsd:string"))
				{	soap_flag_ChannelName--;
					continue;
				}
			if (soap_flag_LogType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:LogType", &a->LogType, "xsd:int"))
				{	soap_flag_LogType--;
					continue;
				}
			if (soap_flag_LogDesc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LogDesc", &a->LogDesc, "xsd:string"))
				{	soap_flag_LogDesc--;
					continue;
				}
			if (soap_flag_AddTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AddTime", &a->AddTime, "xsd:string"))
				{	soap_flag_AddTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__PuLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PuLog, 0, sizeof(struct ns1__PuLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_LogType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PuLog(struct soap *soap, const struct ns1__PuLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PuLog);
	if (soap_out_ns1__PuLog(soap, tag?tag:"ns1:PuLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__PuLog * SOAP_FMAC4 soap_get_ns1__PuLog(struct soap *soap, struct ns1__PuLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PuLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfPuLog(struct soap *soap, struct ns1__ArrayOfPuLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePuLog = 0;
	a->PuLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfPuLog(struct soap *soap, const struct ns1__ArrayOfPuLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->PuLog)
	{	int i;
		for (i = 0; i < a->__sizePuLog; i++)
		{
			soap_embedded(soap, a->PuLog + i, SOAP_TYPE_ns1__PuLog);
			soap_serialize_ns1__PuLog(soap, a->PuLog + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfPuLog(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfPuLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfPuLog), type))
		return soap->error;
	if (a->PuLog)
	{	int i;
		for (i = 0; i < a->__sizePuLog; i++)
			if (soap_out_ns1__PuLog(soap, "ns1:PuLog", -1, a->PuLog + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfPuLog * SOAP_FMAC4 soap_in_ns1__ArrayOfPuLog(struct soap *soap, const char *tag, struct ns1__ArrayOfPuLog *a, const char *type)
{
	struct soap_blist *soap_blist_PuLog = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfPuLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfPuLog, sizeof(struct ns1__ArrayOfPuLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfPuLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:PuLog", 1, NULL))
			{	if (a->PuLog == NULL)
				{	if (soap_blist_PuLog == NULL)
						soap_blist_PuLog = soap_new_block(soap);
					a->PuLog = (struct ns1__PuLog *)soap_push_block(soap, soap_blist_PuLog, sizeof(struct ns1__PuLog));
					if (a->PuLog == NULL)
						return NULL;
					soap_default_ns1__PuLog(soap, a->PuLog);
				}
				soap_revert(soap);
				if (soap_in_ns1__PuLog(soap, "ns1:PuLog", a->PuLog, "ns1:PuLog"))
				{	a->__sizePuLog++;
					a->PuLog = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PuLog)
			soap_pop_block(soap, soap_blist_PuLog);
		if (a->__sizePuLog)
			a->PuLog = (struct ns1__PuLog *)soap_save_block(soap, soap_blist_PuLog, NULL, 1);
		else
		{	a->PuLog = NULL;
			if (soap_blist_PuLog)
				soap_end_block(soap, soap_blist_PuLog);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfPuLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfPuLog, 0, sizeof(struct ns1__ArrayOfPuLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfPuLog(struct soap *soap, const struct ns1__ArrayOfPuLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfPuLog);
	if (soap_out_ns1__ArrayOfPuLog(soap, tag?tag:"ns1:ArrayOfPuLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfPuLog * SOAP_FMAC4 soap_get_ns1__ArrayOfPuLog(struct soap *soap, struct ns1__ArrayOfPuLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfPuLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Device(struct soap *soap, struct ns1__Device *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->DevID);
	soap_default_string(soap, &a->DevKey);
	soap_default_string(soap, &a->DevName);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Device(struct soap *soap, const struct ns1__Device *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DevID);
	soap_serialize_string(soap, &a->DevKey);
	soap_serialize_string(soap, &a->DevName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Device(struct soap *soap, const char *tag, int id, const struct ns1__Device *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Device), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevKey", -1, &a->DevKey, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevName", -1, &a->DevName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Device * SOAP_FMAC4 soap_in_ns1__Device(struct soap *soap, const char *tag, struct ns1__Device *a, const char *type)
{
	size_t soap_flag_DevID = 1;
	size_t soap_flag_DevKey = 1;
	size_t soap_flag_DevName = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Device *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Device, sizeof(struct ns1__Device), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Device(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_DevKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevKey", &a->DevKey, "xsd:string"))
				{	soap_flag_DevKey--;
					continue;
				}
			if (soap_flag_DevName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevName", &a->DevName, "xsd:string"))
				{	soap_flag_DevName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Device *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Device, 0, sizeof(struct ns1__Device), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Device(struct soap *soap, const struct ns1__Device *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Device);
	if (soap_out_ns1__Device(soap, tag?tag:"ns1:Device", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Device * SOAP_FMAC4 soap_get_ns1__Device(struct soap *soap, struct ns1__Device *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Device(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfDevice(struct soap *soap, struct ns1__ArrayOfDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDevice = 0;
	a->Device = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfDevice(struct soap *soap, const struct ns1__ArrayOfDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Device)
	{	int i;
		for (i = 0; i < a->__sizeDevice; i++)
		{
			soap_embedded(soap, a->Device + i, SOAP_TYPE_ns1__Device);
			soap_serialize_ns1__Device(soap, a->Device + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDevice(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfDevice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDevice), type))
		return soap->error;
	if (a->Device)
	{	int i;
		for (i = 0; i < a->__sizeDevice; i++)
			if (soap_out_ns1__Device(soap, "ns1:Device", -1, a->Device + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfDevice * SOAP_FMAC4 soap_in_ns1__ArrayOfDevice(struct soap *soap, const char *tag, struct ns1__ArrayOfDevice *a, const char *type)
{
	struct soap_blist *soap_blist_Device = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDevice, sizeof(struct ns1__ArrayOfDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Device", 1, NULL))
			{	if (a->Device == NULL)
				{	if (soap_blist_Device == NULL)
						soap_blist_Device = soap_new_block(soap);
					a->Device = (struct ns1__Device *)soap_push_block(soap, soap_blist_Device, sizeof(struct ns1__Device));
					if (a->Device == NULL)
						return NULL;
					soap_default_ns1__Device(soap, a->Device);
				}
				soap_revert(soap);
				if (soap_in_ns1__Device(soap, "ns1:Device", a->Device, "ns1:Device"))
				{	a->__sizeDevice++;
					a->Device = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Device)
			soap_pop_block(soap, soap_blist_Device);
		if (a->__sizeDevice)
			a->Device = (struct ns1__Device *)soap_save_block(soap, soap_blist_Device, NULL, 1);
		else
		{	a->Device = NULL;
			if (soap_blist_Device)
				soap_end_block(soap, soap_blist_Device);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDevice, 0, sizeof(struct ns1__ArrayOfDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfDevice(struct soap *soap, const struct ns1__ArrayOfDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfDevice);
	if (soap_out_ns1__ArrayOfDevice(soap, tag?tag:"ns1:ArrayOfDevice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfDevice * SOAP_FMAC4 soap_get_ns1__ArrayOfDevice(struct soap *soap, struct ns1__ArrayOfDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__userLoginRes(struct soap *soap, struct ns1__userLoginRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->LoginSession);
	a->NodeList = NULL;
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Account);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__userLoginRes(struct soap *soap, const struct ns1__userLoginRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_PointerTons1__ArrayOfDev(soap, &a->NodeList);
	soap_serialize_string(soap, &a->Username);
	soap_serialize_string(soap, &a->Account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__userLoginRes(struct soap *soap, const char *tag, int id, const struct ns1__userLoginRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__userLoginRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfDev(soap, "ns1:NodeList", -1, &a->NodeList, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__userLoginRes * SOAP_FMAC4 soap_in_ns1__userLoginRes(struct soap *soap, const char *tag, struct ns1__userLoginRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_NodeList = 1;
	size_t soap_flag_Username = 1;
	size_t soap_flag_Account = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__userLoginRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__userLoginRes, sizeof(struct ns1__userLoginRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__userLoginRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_NodeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDev(soap, "ns1:NodeList", &a->NodeList, "ns1:ArrayOfDev"))
				{	soap_flag_NodeList--;
					continue;
				}
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__userLoginRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__userLoginRes, 0, sizeof(struct ns1__userLoginRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__userLoginRes(struct soap *soap, const struct ns1__userLoginRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__userLoginRes);
	if (soap_out_ns1__userLoginRes(soap, tag?tag:"ns1:userLoginRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__userLoginRes * SOAP_FMAC4 soap_get_ns1__userLoginRes(struct soap *soap, struct ns1__userLoginRes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__userLoginRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__userLoginReq(struct soap *soap, struct ns1__userLoginReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_ns1__PwdType(soap, &a->PwdType);
	soap_default_string(soap, &a->Password);
	soap_default_string(soap, &a->Version);
	soap_default_ns1__NetworkOperator(soap, &a->NetworkOperator);
	soap_default_ns1__NetType(soap, &a->NetType);
	a->MCUDev = NULL;
	soap_default_string(soap, &a->ApplicationID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__userLoginReq(struct soap *soap, const struct ns1__userLoginReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->Password);
	soap_serialize_string(soap, &a->Version);
	soap_serialize_PointerTons1__MCUDev(soap, &a->MCUDev);
	soap_serialize_string(soap, &a->ApplicationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__userLoginReq(struct soap *soap, const char *tag, int id, const struct ns1__userLoginReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__userLoginReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_ns1__PwdType(soap, "ns1:PwdType", -1, &a->PwdType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Version", -1, &a->Version, ""))
		return soap->error;
	if (soap_out_ns1__NetworkOperator(soap, "ns1:NetworkOperator", -1, &a->NetworkOperator, ""))
		return soap->error;
	if (soap_out_ns1__NetType(soap, "ns1:NetType", -1, &a->NetType, ""))
		return soap->error;
	if (soap_out_PointerTons1__MCUDev(soap, "ns1:MCUDev", -1, &a->MCUDev, ""))
		return soap->error;
	if (a->ApplicationID)
	{	if (soap_out_string(soap, "ns1:ApplicationID", -1, &a->ApplicationID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:ApplicationID"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__userLoginReq * SOAP_FMAC4 soap_in_ns1__userLoginReq(struct soap *soap, const char *tag, struct ns1__userLoginReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_PwdType = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Version = 1;
	size_t soap_flag_NetworkOperator = 1;
	size_t soap_flag_NetType = 1;
	size_t soap_flag_MCUDev = 1;
	size_t soap_flag_ApplicationID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__userLoginReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__userLoginReq, sizeof(struct ns1__userLoginReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__userLoginReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_PwdType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__PwdType(soap, "ns1:PwdType", &a->PwdType, "ns1:PwdType"))
				{	soap_flag_PwdType--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Version", &a->Version, "xsd:string"))
				{	soap_flag_Version--;
					continue;
				}
			if (soap_flag_NetworkOperator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__NetworkOperator(soap, "ns1:NetworkOperator", &a->NetworkOperator, "ns1:NetworkOperator"))
				{	soap_flag_NetworkOperator--;
					continue;
				}
			if (soap_flag_NetType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__NetType(soap, "ns1:NetType", &a->NetType, "ns1:NetType"))
				{	soap_flag_NetType--;
					continue;
				}
			if (soap_flag_MCUDev && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MCUDev(soap, "ns1:MCUDev", &a->MCUDev, "ns1:MCUDev"))
				{	soap_flag_MCUDev--;
					continue;
				}
			if (soap_flag_ApplicationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ApplicationID", &a->ApplicationID, "xsd:string"))
				{	soap_flag_ApplicationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__userLoginReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__userLoginReq, 0, sizeof(struct ns1__userLoginReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PwdType > 0 || soap_flag_NetworkOperator > 0 || soap_flag_NetType > 0 || soap_flag_ApplicationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__userLoginReq(struct soap *soap, const struct ns1__userLoginReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__userLoginReq);
	if (soap_out_ns1__userLoginReq(soap, tag?tag:"ns1:userLoginReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__userLoginReq * SOAP_FMAC4 soap_get_ns1__userLoginReq(struct soap *soap, struct ns1__userLoginReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__userLoginReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeviceSharer(struct soap *soap, struct ns1__DeviceSharer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_int(soap, &a->SharingPriority);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeviceSharer(struct soap *soap, const struct ns1__DeviceSharer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_embedded(soap, &a->SharingPriority, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeviceSharer(struct soap *soap, const char *tag, int id, const struct ns1__DeviceSharer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeviceSharer), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:SharingPriority", -1, &a->SharingPriority, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeviceSharer * SOAP_FMAC4 soap_in_ns1__DeviceSharer(struct soap *soap, const char *tag, struct ns1__DeviceSharer *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_SharingPriority = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeviceSharer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeviceSharer, sizeof(struct ns1__DeviceSharer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeviceSharer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_SharingPriority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:SharingPriority", &a->SharingPriority, "xsd:int"))
				{	soap_flag_SharingPriority--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeviceSharer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeviceSharer, 0, sizeof(struct ns1__DeviceSharer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SharingPriority > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeviceSharer(struct soap *soap, const struct ns1__DeviceSharer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DeviceSharer);
	if (soap_out_ns1__DeviceSharer(soap, tag?tag:"ns1:DeviceSharer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeviceSharer * SOAP_FMAC4 soap_get_ns1__DeviceSharer(struct soap *soap, struct ns1__DeviceSharer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeviceSharer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfDeviceSharer(struct soap *soap, struct ns1__ArrayOfDeviceSharer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDeviceSharer = 0;
	a->DeviceSharer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfDeviceSharer(struct soap *soap, const struct ns1__ArrayOfDeviceSharer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->DeviceSharer)
	{	int i;
		for (i = 0; i < a->__sizeDeviceSharer; i++)
		{
			soap_embedded(soap, a->DeviceSharer + i, SOAP_TYPE_ns1__DeviceSharer);
			soap_serialize_ns1__DeviceSharer(soap, a->DeviceSharer + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDeviceSharer(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfDeviceSharer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDeviceSharer), type))
		return soap->error;
	if (a->DeviceSharer)
	{	int i;
		for (i = 0; i < a->__sizeDeviceSharer; i++)
			if (soap_out_ns1__DeviceSharer(soap, "ns1:DeviceSharer", -1, a->DeviceSharer + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfDeviceSharer * SOAP_FMAC4 soap_in_ns1__ArrayOfDeviceSharer(struct soap *soap, const char *tag, struct ns1__ArrayOfDeviceSharer *a, const char *type)
{
	struct soap_blist *soap_blist_DeviceSharer = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfDeviceSharer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDeviceSharer, sizeof(struct ns1__ArrayOfDeviceSharer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfDeviceSharer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:DeviceSharer", 1, NULL))
			{	if (a->DeviceSharer == NULL)
				{	if (soap_blist_DeviceSharer == NULL)
						soap_blist_DeviceSharer = soap_new_block(soap);
					a->DeviceSharer = (struct ns1__DeviceSharer *)soap_push_block(soap, soap_blist_DeviceSharer, sizeof(struct ns1__DeviceSharer));
					if (a->DeviceSharer == NULL)
						return NULL;
					soap_default_ns1__DeviceSharer(soap, a->DeviceSharer);
				}
				soap_revert(soap);
				if (soap_in_ns1__DeviceSharer(soap, "ns1:DeviceSharer", a->DeviceSharer, "ns1:DeviceSharer"))
				{	a->__sizeDeviceSharer++;
					a->DeviceSharer = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->DeviceSharer)
			soap_pop_block(soap, soap_blist_DeviceSharer);
		if (a->__sizeDeviceSharer)
			a->DeviceSharer = (struct ns1__DeviceSharer *)soap_save_block(soap, soap_blist_DeviceSharer, NULL, 1);
		else
		{	a->DeviceSharer = NULL;
			if (soap_blist_DeviceSharer)
				soap_end_block(soap, soap_blist_DeviceSharer);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfDeviceSharer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDeviceSharer, 0, sizeof(struct ns1__ArrayOfDeviceSharer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfDeviceSharer(struct soap *soap, const struct ns1__ArrayOfDeviceSharer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfDeviceSharer);
	if (soap_out_ns1__ArrayOfDeviceSharer(soap, tag?tag:"ns1:ArrayOfDeviceSharer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfDeviceSharer * SOAP_FMAC4 soap_get_ns1__ArrayOfDeviceSharer(struct soap *soap, struct ns1__ArrayOfDeviceSharer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDeviceSharer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PUEventLog(struct soap *soap, struct ns1__PUEventLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__EventType(soap, &a->EventType);
	soap_default_ns1__EventState(soap, &a->EventState);
	soap_default_string(soap, &a->EventDesc);
	soap_default_time(soap, &a->Time);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__PUEventLog(struct soap *soap, const struct ns1__PUEventLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_embedded(soap, &a->EventType, SOAP_TYPE_ns1__EventType);
	soap_embedded(soap, &a->EventState, SOAP_TYPE_ns1__EventState);
	soap_serialize_string(soap, &a->EventDesc);
	soap_embedded(soap, &a->Time, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PUEventLog(struct soap *soap, const char *tag, int id, const struct ns1__PUEventLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PUEventLog), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__EventType(soap, "ns1:EventType", -1, &a->EventType, ""))
		return soap->error;
	if (soap_out_ns1__EventState(soap, "ns1:EventState", -1, &a->EventState, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:EventDesc", -1, &a->EventDesc, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:Time", -1, &a->Time, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__PUEventLog * SOAP_FMAC4 soap_in_ns1__PUEventLog(struct soap *soap, const char *tag, struct ns1__PUEventLog *a, const char *type)
{
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_EventType = 1;
	size_t soap_flag_EventState = 1;
	size_t soap_flag_EventDesc = 1;
	size_t soap_flag_Time = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__PUEventLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PUEventLog, sizeof(struct ns1__PUEventLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__PUEventLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_EventType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__EventType(soap, "ns1:EventType", &a->EventType, "ns1:EventType"))
				{	soap_flag_EventType--;
					continue;
				}
			if (soap_flag_EventState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__EventState(soap, "ns1:EventState", &a->EventState, "ns1:EventState"))
				{	soap_flag_EventState--;
					continue;
				}
			if (soap_flag_EventDesc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:EventDesc", &a->EventDesc, "xsd:string"))
				{	soap_flag_EventDesc--;
					continue;
				}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__PUEventLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PUEventLog, 0, sizeof(struct ns1__PUEventLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_EventType > 0 || soap_flag_EventState > 0 || soap_flag_Time > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PUEventLog(struct soap *soap, const struct ns1__PUEventLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PUEventLog);
	if (soap_out_ns1__PUEventLog(soap, tag?tag:"ns1:PUEventLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__PUEventLog * SOAP_FMAC4 soap_get_ns1__PUEventLog(struct soap *soap, struct ns1__PUEventLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PUEventLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfPUEventLog(struct soap *soap, struct ns1__ArrayOfPUEventLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePUEventLog = 0;
	a->PUEventLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfPUEventLog(struct soap *soap, const struct ns1__ArrayOfPUEventLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->PUEventLog)
	{	int i;
		for (i = 0; i < a->__sizePUEventLog; i++)
		{
			soap_embedded(soap, a->PUEventLog + i, SOAP_TYPE_ns1__PUEventLog);
			soap_serialize_ns1__PUEventLog(soap, a->PUEventLog + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfPUEventLog(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfPUEventLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfPUEventLog), type))
		return soap->error;
	if (a->PUEventLog)
	{	int i;
		for (i = 0; i < a->__sizePUEventLog; i++)
			if (soap_out_ns1__PUEventLog(soap, "ns1:PUEventLog", -1, a->PUEventLog + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfPUEventLog * SOAP_FMAC4 soap_in_ns1__ArrayOfPUEventLog(struct soap *soap, const char *tag, struct ns1__ArrayOfPUEventLog *a, const char *type)
{
	struct soap_blist *soap_blist_PUEventLog = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfPUEventLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfPUEventLog, sizeof(struct ns1__ArrayOfPUEventLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfPUEventLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:PUEventLog", 1, NULL))
			{	if (a->PUEventLog == NULL)
				{	if (soap_blist_PUEventLog == NULL)
						soap_blist_PUEventLog = soap_new_block(soap);
					a->PUEventLog = (struct ns1__PUEventLog *)soap_push_block(soap, soap_blist_PUEventLog, sizeof(struct ns1__PUEventLog));
					if (a->PUEventLog == NULL)
						return NULL;
					soap_default_ns1__PUEventLog(soap, a->PUEventLog);
				}
				soap_revert(soap);
				if (soap_in_ns1__PUEventLog(soap, "ns1:PUEventLog", a->PUEventLog, "ns1:PUEventLog"))
				{	a->__sizePUEventLog++;
					a->PUEventLog = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PUEventLog)
			soap_pop_block(soap, soap_blist_PUEventLog);
		if (a->__sizePUEventLog)
			a->PUEventLog = (struct ns1__PUEventLog *)soap_save_block(soap, soap_blist_PUEventLog, NULL, 1);
		else
		{	a->PUEventLog = NULL;
			if (soap_blist_PUEventLog)
				soap_end_block(soap, soap_blist_PUEventLog);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfPUEventLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfPUEventLog, 0, sizeof(struct ns1__ArrayOfPUEventLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfPUEventLog(struct soap *soap, const struct ns1__ArrayOfPUEventLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfPUEventLog);
	if (soap_out_ns1__ArrayOfPUEventLog(soap, tag?tag:"ns1:ArrayOfPUEventLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfPUEventLog * SOAP_FMAC4 soap_get_ns1__ArrayOfPUEventLog(struct soap *soap, struct ns1__ArrayOfPUEventLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfPUEventLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PUOnOffLog(struct soap *soap, struct ns1__PUOnOffLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->DevID);
	soap_default_time(soap, &a->Time);
	soap_default_time(soap, &a->OffTime);
	soap_default_string(soap, &a->OffReason);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__PUOnOffLog(struct soap *soap, const struct ns1__PUOnOffLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->Time, SOAP_TYPE_time);
	soap_embedded(soap, &a->OffTime, SOAP_TYPE_time);
	soap_serialize_string(soap, &a->OffReason);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PUOnOffLog(struct soap *soap, const char *tag, int id, const struct ns1__PUOnOffLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PUOnOffLog), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:Time", -1, &a->Time, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:OffTime", -1, &a->OffTime, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:OffReason", -1, &a->OffReason, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__PUOnOffLog * SOAP_FMAC4 soap_in_ns1__PUOnOffLog(struct soap *soap, const char *tag, struct ns1__PUOnOffLog *a, const char *type)
{
	size_t soap_flag_DevID = 1;
	size_t soap_flag_Time = 1;
	size_t soap_flag_OffTime = 1;
	size_t soap_flag_OffReason = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__PUOnOffLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PUOnOffLog, sizeof(struct ns1__PUOnOffLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__PUOnOffLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_OffTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:OffTime", &a->OffTime, "xsd:dateTime"))
				{	soap_flag_OffTime--;
					continue;
				}
			if (soap_flag_OffReason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:OffReason", &a->OffReason, "xsd:string"))
				{	soap_flag_OffReason--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__PUOnOffLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PUOnOffLog, 0, sizeof(struct ns1__PUOnOffLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Time > 0 || soap_flag_OffTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PUOnOffLog(struct soap *soap, const struct ns1__PUOnOffLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PUOnOffLog);
	if (soap_out_ns1__PUOnOffLog(soap, tag?tag:"ns1:PUOnOffLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__PUOnOffLog * SOAP_FMAC4 soap_get_ns1__PUOnOffLog(struct soap *soap, struct ns1__PUOnOffLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PUOnOffLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfPUOnOffLog(struct soap *soap, struct ns1__ArrayOfPUOnOffLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePUOnOffLog = 0;
	a->PUOnOffLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfPUOnOffLog(struct soap *soap, const struct ns1__ArrayOfPUOnOffLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->PUOnOffLog)
	{	int i;
		for (i = 0; i < a->__sizePUOnOffLog; i++)
		{
			soap_embedded(soap, a->PUOnOffLog + i, SOAP_TYPE_ns1__PUOnOffLog);
			soap_serialize_ns1__PUOnOffLog(soap, a->PUOnOffLog + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfPUOnOffLog(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfPUOnOffLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfPUOnOffLog), type))
		return soap->error;
	if (a->PUOnOffLog)
	{	int i;
		for (i = 0; i < a->__sizePUOnOffLog; i++)
			if (soap_out_ns1__PUOnOffLog(soap, "ns1:PUOnOffLog", -1, a->PUOnOffLog + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfPUOnOffLog * SOAP_FMAC4 soap_in_ns1__ArrayOfPUOnOffLog(struct soap *soap, const char *tag, struct ns1__ArrayOfPUOnOffLog *a, const char *type)
{
	struct soap_blist *soap_blist_PUOnOffLog = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfPUOnOffLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfPUOnOffLog, sizeof(struct ns1__ArrayOfPUOnOffLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfPUOnOffLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:PUOnOffLog", 1, NULL))
			{	if (a->PUOnOffLog == NULL)
				{	if (soap_blist_PUOnOffLog == NULL)
						soap_blist_PUOnOffLog = soap_new_block(soap);
					a->PUOnOffLog = (struct ns1__PUOnOffLog *)soap_push_block(soap, soap_blist_PUOnOffLog, sizeof(struct ns1__PUOnOffLog));
					if (a->PUOnOffLog == NULL)
						return NULL;
					soap_default_ns1__PUOnOffLog(soap, a->PUOnOffLog);
				}
				soap_revert(soap);
				if (soap_in_ns1__PUOnOffLog(soap, "ns1:PUOnOffLog", a->PUOnOffLog, "ns1:PUOnOffLog"))
				{	a->__sizePUOnOffLog++;
					a->PUOnOffLog = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PUOnOffLog)
			soap_pop_block(soap, soap_blist_PUOnOffLog);
		if (a->__sizePUOnOffLog)
			a->PUOnOffLog = (struct ns1__PUOnOffLog *)soap_save_block(soap, soap_blist_PUOnOffLog, NULL, 1);
		else
		{	a->PUOnOffLog = NULL;
			if (soap_blist_PUOnOffLog)
				soap_end_block(soap, soap_blist_PUOnOffLog);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfPUOnOffLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfPUOnOffLog, 0, sizeof(struct ns1__ArrayOfPUOnOffLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfPUOnOffLog(struct soap *soap, const struct ns1__ArrayOfPUOnOffLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfPUOnOffLog);
	if (soap_out_ns1__ArrayOfPUOnOffLog(soap, tag?tag:"ns1:ArrayOfPUOnOffLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfPUOnOffLog * SOAP_FMAC4 soap_get_ns1__ArrayOfPUOnOffLog(struct soap *soap, struct ns1__ArrayOfPUOnOffLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfPUOnOffLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TURNServer(struct soap *soap, struct ns1__TURNServer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->IPv4Address);
	soap_default_string(soap, &a->IPv6Address);
	soap_default_int(soap, &a->Port);
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Password);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TURNServer(struct soap *soap, const struct ns1__TURNServer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->IPv4Address);
	soap_serialize_string(soap, &a->IPv6Address);
	soap_embedded(soap, &a->Port, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->Username);
	soap_serialize_string(soap, &a->Password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TURNServer(struct soap *soap, const char *tag, int id, const struct ns1__TURNServer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TURNServer), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:IPv4Address", -1, &a->IPv4Address, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:IPv6Address", -1, &a->IPv6Address, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Port", -1, &a->Port, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Password", -1, &a->Password, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TURNServer * SOAP_FMAC4 soap_in_ns1__TURNServer(struct soap *soap, const char *tag, struct ns1__TURNServer *a, const char *type)
{
	size_t soap_flag_IPv4Address = 1;
	size_t soap_flag_IPv6Address = 1;
	size_t soap_flag_Port = 1;
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TURNServer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TURNServer, sizeof(struct ns1__TURNServer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TURNServer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPv4Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:IPv4Address", &a->IPv4Address, "xsd:string"))
				{	soap_flag_IPv4Address--;
					continue;
				}
			if (soap_flag_IPv6Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:IPv6Address", &a->IPv6Address, "xsd:string"))
				{	soap_flag_IPv6Address--;
					continue;
				}
			if (soap_flag_Port && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Port", &a->Port, "xsd:int"))
				{	soap_flag_Port--;
					continue;
				}
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TURNServer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TURNServer, 0, sizeof(struct ns1__TURNServer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Port > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TURNServer(struct soap *soap, const struct ns1__TURNServer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TURNServer);
	if (soap_out_ns1__TURNServer(soap, tag?tag:"ns1:TURNServer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TURNServer * SOAP_FMAC4 soap_get_ns1__TURNServer(struct soap *soap, struct ns1__TURNServer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TURNServer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfTURNServer(struct soap *soap, struct ns1__ArrayOfTURNServer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTURNServer = 0;
	a->TURNServer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfTURNServer(struct soap *soap, const struct ns1__ArrayOfTURNServer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->TURNServer)
	{	int i;
		for (i = 0; i < a->__sizeTURNServer; i++)
		{
			soap_embedded(soap, a->TURNServer + i, SOAP_TYPE_ns1__TURNServer);
			soap_serialize_ns1__TURNServer(soap, a->TURNServer + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTURNServer(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfTURNServer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfTURNServer), type))
		return soap->error;
	if (a->TURNServer)
	{	int i;
		for (i = 0; i < a->__sizeTURNServer; i++)
			if (soap_out_ns1__TURNServer(soap, "ns1:TURNServer", -1, a->TURNServer + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfTURNServer * SOAP_FMAC4 soap_in_ns1__ArrayOfTURNServer(struct soap *soap, const char *tag, struct ns1__ArrayOfTURNServer *a, const char *type)
{
	struct soap_blist *soap_blist_TURNServer = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfTURNServer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfTURNServer, sizeof(struct ns1__ArrayOfTURNServer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfTURNServer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:TURNServer", 1, NULL))
			{	if (a->TURNServer == NULL)
				{	if (soap_blist_TURNServer == NULL)
						soap_blist_TURNServer = soap_new_block(soap);
					a->TURNServer = (struct ns1__TURNServer *)soap_push_block(soap, soap_blist_TURNServer, sizeof(struct ns1__TURNServer));
					if (a->TURNServer == NULL)
						return NULL;
					soap_default_ns1__TURNServer(soap, a->TURNServer);
				}
				soap_revert(soap);
				if (soap_in_ns1__TURNServer(soap, "ns1:TURNServer", a->TURNServer, "ns1:TURNServer"))
				{	a->__sizeTURNServer++;
					a->TURNServer = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TURNServer)
			soap_pop_block(soap, soap_blist_TURNServer);
		if (a->__sizeTURNServer)
			a->TURNServer = (struct ns1__TURNServer *)soap_save_block(soap, soap_blist_TURNServer, NULL, 1);
		else
		{	a->TURNServer = NULL;
			if (soap_blist_TURNServer)
				soap_end_block(soap, soap_blist_TURNServer);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTURNServer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfTURNServer, 0, sizeof(struct ns1__ArrayOfTURNServer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfTURNServer(struct soap *soap, const struct ns1__ArrayOfTURNServer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfTURNServer);
	if (soap_out_ns1__ArrayOfTURNServer(soap, tag?tag:"ns1:ArrayOfTURNServer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTURNServer * SOAP_FMAC4 soap_get_ns1__ArrayOfTURNServer(struct soap *soap, struct ns1__ArrayOfTURNServer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTURNServer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__STUNServer(struct soap *soap, struct ns1__STUNServer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->IPv4Address);
	soap_default_string(soap, &a->IPv6Address);
	soap_default_int(soap, &a->Port);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__STUNServer(struct soap *soap, const struct ns1__STUNServer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->IPv4Address);
	soap_serialize_string(soap, &a->IPv6Address);
	soap_embedded(soap, &a->Port, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__STUNServer(struct soap *soap, const char *tag, int id, const struct ns1__STUNServer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__STUNServer), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:IPv4Address", -1, &a->IPv4Address, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:IPv6Address", -1, &a->IPv6Address, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Port", -1, &a->Port, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__STUNServer * SOAP_FMAC4 soap_in_ns1__STUNServer(struct soap *soap, const char *tag, struct ns1__STUNServer *a, const char *type)
{
	size_t soap_flag_IPv4Address = 1;
	size_t soap_flag_IPv6Address = 1;
	size_t soap_flag_Port = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__STUNServer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__STUNServer, sizeof(struct ns1__STUNServer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__STUNServer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPv4Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:IPv4Address", &a->IPv4Address, "xsd:string"))
				{	soap_flag_IPv4Address--;
					continue;
				}
			if (soap_flag_IPv6Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:IPv6Address", &a->IPv6Address, "xsd:string"))
				{	soap_flag_IPv6Address--;
					continue;
				}
			if (soap_flag_Port && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Port", &a->Port, "xsd:int"))
				{	soap_flag_Port--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__STUNServer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__STUNServer, 0, sizeof(struct ns1__STUNServer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Port > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__STUNServer(struct soap *soap, const struct ns1__STUNServer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__STUNServer);
	if (soap_out_ns1__STUNServer(soap, tag?tag:"ns1:STUNServer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__STUNServer * SOAP_FMAC4 soap_get_ns1__STUNServer(struct soap *soap, struct ns1__STUNServer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__STUNServer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfSTUNServer(struct soap *soap, struct ns1__ArrayOfSTUNServer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSTUNServer = 0;
	a->STUNServer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfSTUNServer(struct soap *soap, const struct ns1__ArrayOfSTUNServer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->STUNServer)
	{	int i;
		for (i = 0; i < a->__sizeSTUNServer; i++)
		{
			soap_embedded(soap, a->STUNServer + i, SOAP_TYPE_ns1__STUNServer);
			soap_serialize_ns1__STUNServer(soap, a->STUNServer + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSTUNServer(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfSTUNServer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSTUNServer), type))
		return soap->error;
	if (a->STUNServer)
	{	int i;
		for (i = 0; i < a->__sizeSTUNServer; i++)
			if (soap_out_ns1__STUNServer(soap, "ns1:STUNServer", -1, a->STUNServer + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfSTUNServer * SOAP_FMAC4 soap_in_ns1__ArrayOfSTUNServer(struct soap *soap, const char *tag, struct ns1__ArrayOfSTUNServer *a, const char *type)
{
	struct soap_blist *soap_blist_STUNServer = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfSTUNServer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSTUNServer, sizeof(struct ns1__ArrayOfSTUNServer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfSTUNServer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:STUNServer", 1, NULL))
			{	if (a->STUNServer == NULL)
				{	if (soap_blist_STUNServer == NULL)
						soap_blist_STUNServer = soap_new_block(soap);
					a->STUNServer = (struct ns1__STUNServer *)soap_push_block(soap, soap_blist_STUNServer, sizeof(struct ns1__STUNServer));
					if (a->STUNServer == NULL)
						return NULL;
					soap_default_ns1__STUNServer(soap, a->STUNServer);
				}
				soap_revert(soap);
				if (soap_in_ns1__STUNServer(soap, "ns1:STUNServer", a->STUNServer, "ns1:STUNServer"))
				{	a->__sizeSTUNServer++;
					a->STUNServer = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->STUNServer)
			soap_pop_block(soap, soap_blist_STUNServer);
		if (a->__sizeSTUNServer)
			a->STUNServer = (struct ns1__STUNServer *)soap_save_block(soap, soap_blist_STUNServer, NULL, 1);
		else
		{	a->STUNServer = NULL;
			if (soap_blist_STUNServer)
				soap_end_block(soap, soap_blist_STUNServer);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfSTUNServer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSTUNServer, 0, sizeof(struct ns1__ArrayOfSTUNServer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfSTUNServer(struct soap *soap, const struct ns1__ArrayOfSTUNServer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSTUNServer);
	if (soap_out_ns1__ArrayOfSTUNServer(soap, tag?tag:"ns1:ArrayOfSTUNServer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfSTUNServer * SOAP_FMAC4 soap_get_ns1__ArrayOfSTUNServer(struct soap *soap, struct ns1__ArrayOfSTUNServer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSTUNServer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__inviteRes(struct soap *soap, struct ns1__inviteRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->DialogID);
	soap_default_string(soap, &a->SDPMessage);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__inviteRes(struct soap *soap, const struct ns1__inviteRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DialogID);
	soap_serialize_string(soap, &a->SDPMessage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__inviteRes(struct soap *soap, const char *tag, int id, const struct ns1__inviteRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__inviteRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DialogID", -1, &a->DialogID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SDPMessage", -1, &a->SDPMessage, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__inviteRes * SOAP_FMAC4 soap_in_ns1__inviteRes(struct soap *soap, const char *tag, struct ns1__inviteRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_DialogID = 1;
	size_t soap_flag_SDPMessage = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__inviteRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__inviteRes, sizeof(struct ns1__inviteRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__inviteRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_DialogID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DialogID", &a->DialogID, "xsd:string"))
				{	soap_flag_DialogID--;
					continue;
				}
			if (soap_flag_SDPMessage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SDPMessage", &a->SDPMessage, "xsd:string"))
				{	soap_flag_SDPMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__inviteRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__inviteRes, 0, sizeof(struct ns1__inviteRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__inviteRes(struct soap *soap, const struct ns1__inviteRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__inviteRes);
	if (soap_out_ns1__inviteRes(soap, tag?tag:"ns1:inviteRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__inviteRes * SOAP_FMAC4 soap_get_ns1__inviteRes(struct soap *soap, struct ns1__inviteRes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__inviteRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__inviteReq(struct soap *soap, struct ns1__inviteReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__StreamType(soap, &a->StreamType);
	soap_default_string(soap, &a->DialogID);
	soap_default_string(soap, &a->SDPMessage);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__inviteReq(struct soap *soap, const struct ns1__inviteReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->DialogID);
	soap_serialize_string(soap, &a->SDPMessage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__inviteReq(struct soap *soap, const char *tag, int id, const struct ns1__inviteReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__inviteReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__StreamType(soap, "ns1:StreamType", -1, &a->StreamType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DialogID", -1, &a->DialogID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SDPMessage", -1, &a->SDPMessage, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__inviteReq * SOAP_FMAC4 soap_in_ns1__inviteReq(struct soap *soap, const char *tag, struct ns1__inviteReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_StreamType = 1;
	size_t soap_flag_DialogID = 1;
	size_t soap_flag_SDPMessage = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__inviteReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__inviteReq, sizeof(struct ns1__inviteReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__inviteReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_StreamType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StreamType(soap, "ns1:StreamType", &a->StreamType, "ns1:StreamType"))
				{	soap_flag_StreamType--;
					continue;
				}
			if (soap_flag_DialogID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DialogID", &a->DialogID, "xsd:string"))
				{	soap_flag_DialogID--;
					continue;
				}
			if (soap_flag_SDPMessage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SDPMessage", &a->SDPMessage, "xsd:string"))
				{	soap_flag_SDPMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__inviteReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__inviteReq, 0, sizeof(struct ns1__inviteReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_StreamType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__inviteReq(struct soap *soap, const struct ns1__inviteReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__inviteReq);
	if (soap_out_ns1__inviteReq(soap, tag?tag:"ns1:inviteReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__inviteReq * SOAP_FMAC4 soap_get_ns1__inviteReq(struct soap *soap, struct ns1__inviteReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__inviteReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__WirelessNetwork(struct soap *soap, struct ns1__WirelessNetwork *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__WirelessType(soap, &a->WirelessType);
	soap_default_string(soap, &a->SSID);
	soap_default_int(soap, &a->Intensity);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__WirelessNetwork(struct soap *soap, const struct ns1__WirelessNetwork *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SSID);
	soap_embedded(soap, &a->Intensity, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WirelessNetwork(struct soap *soap, const char *tag, int id, const struct ns1__WirelessNetwork *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WirelessNetwork), type))
		return soap->error;
	if (soap_out_ns1__WirelessType(soap, "ns1:WirelessType", -1, &a->WirelessType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SSID", -1, &a->SSID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Intensity", -1, &a->Intensity, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__WirelessNetwork * SOAP_FMAC4 soap_in_ns1__WirelessNetwork(struct soap *soap, const char *tag, struct ns1__WirelessNetwork *a, const char *type)
{
	size_t soap_flag_WirelessType = 1;
	size_t soap_flag_SSID = 1;
	size_t soap_flag_Intensity = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__WirelessNetwork *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WirelessNetwork, sizeof(struct ns1__WirelessNetwork), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__WirelessNetwork(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WirelessType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__WirelessType(soap, "ns1:WirelessType", &a->WirelessType, "ns1:WirelessType"))
				{	soap_flag_WirelessType--;
					continue;
				}
			if (soap_flag_SSID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SSID", &a->SSID, "xsd:string"))
				{	soap_flag_SSID--;
					continue;
				}
			if (soap_flag_Intensity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Intensity", &a->Intensity, "xsd:int"))
				{	soap_flag_Intensity--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__WirelessNetwork *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__WirelessNetwork, 0, sizeof(struct ns1__WirelessNetwork), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_WirelessType > 0 || soap_flag_Intensity > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__WirelessNetwork(struct soap *soap, const struct ns1__WirelessNetwork *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__WirelessNetwork);
	if (soap_out_ns1__WirelessNetwork(soap, tag?tag:"ns1:WirelessNetwork", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__WirelessNetwork * SOAP_FMAC4 soap_get_ns1__WirelessNetwork(struct soap *soap, struct ns1__WirelessNetwork *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WirelessNetwork(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__NodeDetails(struct soap *soap, struct ns1__NodeDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_string(soap, &a->Name);
	soap_default_xsd__boolean(soap, &a->OnLine);
	soap_default_xsd__boolean(soap, &a->PtzFlag);
	soap_default_int(soap, &a->SecurityArea);
	soap_default_xsd__boolean(soap, &a->EStoreFlag);
	soap_default_string(soap, &a->UpnpIP);
	soap_default_int(soap, &a->UpnpPort);
	soap_default_string(soap, &a->DevVer);
	soap_default_int(soap, &a->CurVideoNum);
	soap_default_time(soap, &a->LastUpdated);
	soap_default_int(soap, &a->SMSSubscribedFlag);
	soap_default_int(soap, &a->EMailSubscribedFlag);
	soap_default_int(soap, &a->SharingFlag);
	soap_default_int(soap, &a->ApplePushSubscribedFlag);
	soap_default_int(soap, &a->AndroidPushSubscribedFlag);
	soap_default_int(soap, &a->InfraredFlag);
	soap_default_int(soap, &a->WirelessFlag);
	a->WirelessNetwork = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__NodeDetails(struct soap *soap, const struct ns1__NodeDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->Name);
	soap_embedded(soap, &a->OnLine, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->PtzFlag, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->SecurityArea, SOAP_TYPE_int);
	soap_embedded(soap, &a->EStoreFlag, SOAP_TYPE_xsd__boolean);
	soap_serialize_string(soap, &a->UpnpIP);
	soap_embedded(soap, &a->UpnpPort, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->DevVer);
	soap_embedded(soap, &a->CurVideoNum, SOAP_TYPE_int);
	soap_embedded(soap, &a->LastUpdated, SOAP_TYPE_time);
	soap_embedded(soap, &a->SMSSubscribedFlag, SOAP_TYPE_int);
	soap_embedded(soap, &a->EMailSubscribedFlag, SOAP_TYPE_int);
	soap_embedded(soap, &a->SharingFlag, SOAP_TYPE_int);
	soap_embedded(soap, &a->ApplePushSubscribedFlag, SOAP_TYPE_int);
	soap_embedded(soap, &a->AndroidPushSubscribedFlag, SOAP_TYPE_int);
	soap_embedded(soap, &a->InfraredFlag, SOAP_TYPE_int);
	soap_embedded(soap, &a->WirelessFlag, SOAP_TYPE_int);
	soap_serialize_PointerTons1__WirelessNetwork(soap, &a->WirelessNetwork);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NodeDetails(struct soap *soap, const char *tag, int id, const struct ns1__NodeDetails *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NodeDetails), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:OnLine", -1, &a->OnLine, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:PtzFlag", -1, &a->PtzFlag, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:SecurityArea", -1, &a->SecurityArea, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:EStoreFlag", -1, &a->EStoreFlag, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:UpnpIP", -1, &a->UpnpIP, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:UpnpPort", -1, &a->UpnpPort, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevVer", -1, &a->DevVer, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:CurVideoNum", -1, &a->CurVideoNum, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:LastUpdated", -1, &a->LastUpdated, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:SMSSubscribedFlag", -1, &a->SMSSubscribedFlag, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:EMailSubscribedFlag", -1, &a->EMailSubscribedFlag, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:SharingFlag", -1, &a->SharingFlag, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ApplePushSubscribedFlag", -1, &a->ApplePushSubscribedFlag, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:AndroidPushSubscribedFlag", -1, &a->AndroidPushSubscribedFlag, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:InfraredFlag", -1, &a->InfraredFlag, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:WirelessFlag", -1, &a->WirelessFlag, ""))
		return soap->error;
	if (soap_out_PointerTons1__WirelessNetwork(soap, "ns1:WirelessNetwork", -1, &a->WirelessNetwork, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__NodeDetails * SOAP_FMAC4 soap_in_ns1__NodeDetails(struct soap *soap, const char *tag, struct ns1__NodeDetails *a, const char *type)
{
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_OnLine = 1;
	size_t soap_flag_PtzFlag = 1;
	size_t soap_flag_SecurityArea = 1;
	size_t soap_flag_EStoreFlag = 1;
	size_t soap_flag_UpnpIP = 1;
	size_t soap_flag_UpnpPort = 1;
	size_t soap_flag_DevVer = 1;
	size_t soap_flag_CurVideoNum = 1;
	size_t soap_flag_LastUpdated = 1;
	size_t soap_flag_SMSSubscribedFlag = 1;
	size_t soap_flag_EMailSubscribedFlag = 1;
	size_t soap_flag_SharingFlag = 1;
	size_t soap_flag_ApplePushSubscribedFlag = 1;
	size_t soap_flag_AndroidPushSubscribedFlag = 1;
	size_t soap_flag_InfraredFlag = 1;
	size_t soap_flag_WirelessFlag = 1;
	size_t soap_flag_WirelessNetwork = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__NodeDetails *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NodeDetails, sizeof(struct ns1__NodeDetails), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__NodeDetails(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Name", &a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_OnLine && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:OnLine", &a->OnLine, "xsd:boolean"))
				{	soap_flag_OnLine--;
					continue;
				}
			if (soap_flag_PtzFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:PtzFlag", &a->PtzFlag, "xsd:boolean"))
				{	soap_flag_PtzFlag--;
					continue;
				}
			if (soap_flag_SecurityArea && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:SecurityArea", &a->SecurityArea, "xsd:int"))
				{	soap_flag_SecurityArea--;
					continue;
				}
			if (soap_flag_EStoreFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:EStoreFlag", &a->EStoreFlag, "xsd:boolean"))
				{	soap_flag_EStoreFlag--;
					continue;
				}
			if (soap_flag_UpnpIP && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpnpIP", &a->UpnpIP, "xsd:string"))
				{	soap_flag_UpnpIP--;
					continue;
				}
			if (soap_flag_UpnpPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:UpnpPort", &a->UpnpPort, "xsd:int"))
				{	soap_flag_UpnpPort--;
					continue;
				}
			if (soap_flag_DevVer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevVer", &a->DevVer, "xsd:string"))
				{	soap_flag_DevVer--;
					continue;
				}
			if (soap_flag_CurVideoNum && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:CurVideoNum", &a->CurVideoNum, "xsd:int"))
				{	soap_flag_CurVideoNum--;
					continue;
				}
			if (soap_flag_LastUpdated && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:LastUpdated", &a->LastUpdated, "xsd:dateTime"))
				{	soap_flag_LastUpdated--;
					continue;
				}
			if (soap_flag_SMSSubscribedFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:SMSSubscribedFlag", &a->SMSSubscribedFlag, "xsd:int"))
				{	soap_flag_SMSSubscribedFlag--;
					continue;
				}
			if (soap_flag_EMailSubscribedFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:EMailSubscribedFlag", &a->EMailSubscribedFlag, "xsd:int"))
				{	soap_flag_EMailSubscribedFlag--;
					continue;
				}
			if (soap_flag_SharingFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:SharingFlag", &a->SharingFlag, "xsd:int"))
				{	soap_flag_SharingFlag--;
					continue;
				}
			if (soap_flag_ApplePushSubscribedFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ApplePushSubscribedFlag", &a->ApplePushSubscribedFlag, "xsd:int"))
				{	soap_flag_ApplePushSubscribedFlag--;
					continue;
				}
			if (soap_flag_AndroidPushSubscribedFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:AndroidPushSubscribedFlag", &a->AndroidPushSubscribedFlag, "xsd:int"))
				{	soap_flag_AndroidPushSubscribedFlag--;
					continue;
				}
			if (soap_flag_InfraredFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:InfraredFlag", &a->InfraredFlag, "xsd:int"))
				{	soap_flag_InfraredFlag--;
					continue;
				}
			if (soap_flag_WirelessFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:WirelessFlag", &a->WirelessFlag, "xsd:int"))
				{	soap_flag_WirelessFlag--;
					continue;
				}
			if (soap_flag_WirelessNetwork && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__WirelessNetwork(soap, "ns1:WirelessNetwork", &a->WirelessNetwork, "ns1:WirelessNetwork"))
				{	soap_flag_WirelessNetwork--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__NodeDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NodeDetails, 0, sizeof(struct ns1__NodeDetails), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_OnLine > 0 || soap_flag_PtzFlag > 0 || soap_flag_SecurityArea > 0 || soap_flag_EStoreFlag > 0 || soap_flag_UpnpPort > 0 || soap_flag_CurVideoNum > 0 || soap_flag_LastUpdated > 0 || soap_flag_SMSSubscribedFlag > 0 || soap_flag_EMailSubscribedFlag > 0 || soap_flag_SharingFlag > 0 || soap_flag_ApplePushSubscribedFlag > 0 || soap_flag_AndroidPushSubscribedFlag > 0 || soap_flag_InfraredFlag > 0 || soap_flag_WirelessFlag > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__NodeDetails(struct soap *soap, const struct ns1__NodeDetails *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__NodeDetails);
	if (soap_out_ns1__NodeDetails(soap, tag?tag:"ns1:NodeDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__NodeDetails * SOAP_FMAC4 soap_get_ns1__NodeDetails(struct soap *soap, struct ns1__NodeDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NodeDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfNodeDetails(struct soap *soap, struct ns1__ArrayOfNodeDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNodeDetails = 0;
	a->NodeDetails = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfNodeDetails(struct soap *soap, const struct ns1__ArrayOfNodeDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NodeDetails)
	{	int i;
		for (i = 0; i < a->__sizeNodeDetails; i++)
		{
			soap_embedded(soap, a->NodeDetails + i, SOAP_TYPE_ns1__NodeDetails);
			soap_serialize_ns1__NodeDetails(soap, a->NodeDetails + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfNodeDetails(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfNodeDetails *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfNodeDetails), type))
		return soap->error;
	if (a->NodeDetails)
	{	int i;
		for (i = 0; i < a->__sizeNodeDetails; i++)
			if (soap_out_ns1__NodeDetails(soap, "ns1:NodeDetails", -1, a->NodeDetails + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfNodeDetails * SOAP_FMAC4 soap_in_ns1__ArrayOfNodeDetails(struct soap *soap, const char *tag, struct ns1__ArrayOfNodeDetails *a, const char *type)
{
	struct soap_blist *soap_blist_NodeDetails = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfNodeDetails *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfNodeDetails, sizeof(struct ns1__ArrayOfNodeDetails), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfNodeDetails(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:NodeDetails", 1, NULL))
			{	if (a->NodeDetails == NULL)
				{	if (soap_blist_NodeDetails == NULL)
						soap_blist_NodeDetails = soap_new_block(soap);
					a->NodeDetails = (struct ns1__NodeDetails *)soap_push_block(soap, soap_blist_NodeDetails, sizeof(struct ns1__NodeDetails));
					if (a->NodeDetails == NULL)
						return NULL;
					soap_default_ns1__NodeDetails(soap, a->NodeDetails);
				}
				soap_revert(soap);
				if (soap_in_ns1__NodeDetails(soap, "ns1:NodeDetails", a->NodeDetails, "ns1:NodeDetails"))
				{	a->__sizeNodeDetails++;
					a->NodeDetails = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NodeDetails)
			soap_pop_block(soap, soap_blist_NodeDetails);
		if (a->__sizeNodeDetails)
			a->NodeDetails = (struct ns1__NodeDetails *)soap_save_block(soap, soap_blist_NodeDetails, NULL, 1);
		else
		{	a->NodeDetails = NULL;
			if (soap_blist_NodeDetails)
				soap_end_block(soap, soap_blist_NodeDetails);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfNodeDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfNodeDetails, 0, sizeof(struct ns1__ArrayOfNodeDetails), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfNodeDetails(struct soap *soap, const struct ns1__ArrayOfNodeDetails *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfNodeDetails);
	if (soap_out_ns1__ArrayOfNodeDetails(soap, tag?tag:"ns1:ArrayOfNodeDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfNodeDetails * SOAP_FMAC4 soap_get_ns1__ArrayOfNodeDetails(struct soap *soap, struct ns1__ArrayOfNodeDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfNodeDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfString(struct soap *soap, struct ns1__ArrayOfString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestring = 0;
	a->string = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfString(struct soap *soap, const struct ns1__ArrayOfString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->string)
	{	int i;
		for (i = 0; i < a->__sizestring; i++)
		{
			soap_serialize_string(soap, a->string + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfString(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfString *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfString), type))
		return soap->error;
	if (a->string)
	{	int i;
		for (i = 0; i < a->__sizestring; i++)
			if (soap_out_string(soap, "ns1:string", -1, a->string + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfString * SOAP_FMAC4 soap_in_ns1__ArrayOfString(struct soap *soap, const char *tag, struct ns1__ArrayOfString *a, const char *type)
{
	struct soap_blist *soap_blist_string = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfString *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfString, sizeof(struct ns1__ArrayOfString), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfString(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:string", 1, NULL))
			{	if (a->string == NULL)
				{	if (soap_blist_string == NULL)
						soap_blist_string = soap_new_block(soap);
					a->string = (char **)soap_push_block(soap, soap_blist_string, sizeof(char *));
					if (a->string == NULL)
						return NULL;
					*a->string = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns1:string", a->string, "xsd:string"))
				{	a->__sizestring++;
					a->string = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->string)
			soap_pop_block(soap, soap_blist_string);
		if (a->__sizestring)
			a->string = (char **)soap_save_block(soap, soap_blist_string, NULL, 1);
		else
		{	a->string = NULL;
			if (soap_blist_string)
				soap_end_block(soap, soap_blist_string);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfString, 0, sizeof(struct ns1__ArrayOfString), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfString(struct soap *soap, const struct ns1__ArrayOfString *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfString);
	if (soap_out_ns1__ArrayOfString(soap, tag?tag:"ns1:ArrayOfString", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfString * SOAP_FMAC4 soap_get_ns1__ArrayOfString(struct soap *soap, struct ns1__ArrayOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Notice(struct soap *soap, struct ns1__Notice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ID);
	soap_default_string(soap, &a->Message);
	soap_default_ns1__NoticeClassification(soap, &a->Classification);
	soap_default_time(soap, &a->Time);
	soap_default_ns1__NoticeStatus(soap, &a->Status);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_string(soap, &a->Name);
	a->PictureID = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Notice(struct soap *soap, const struct ns1__Notice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ID);
	soap_serialize_string(soap, &a->Message);
	soap_embedded(soap, &a->Time, SOAP_TYPE_time);
	soap_embedded(soap, &a->Status, SOAP_TYPE_ns1__NoticeStatus);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->Name);
	soap_serialize_PointerTons1__ArrayOfString(soap, &a->PictureID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Notice(struct soap *soap, const char *tag, int id, const struct ns1__Notice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Notice), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:ID", -1, &a->ID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Message", -1, &a->Message, ""))
		return soap->error;
	if (soap_out_ns1__NoticeClassification(soap, "ns1:Classification", -1, &a->Classification, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:Time", -1, &a->Time, ""))
		return soap->error;
	if (soap_out_ns1__NoticeStatus(soap, "ns1:Status", -1, &a->Status, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:PictureID", -1, &a->PictureID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Notice * SOAP_FMAC4 soap_in_ns1__Notice(struct soap *soap, const char *tag, struct ns1__Notice *a, const char *type)
{
	size_t soap_flag_ID = 1;
	size_t soap_flag_Message = 1;
	size_t soap_flag_Classification = 1;
	size_t soap_flag_Time = 1;
	size_t soap_flag_Status = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_PictureID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Notice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Notice, sizeof(struct ns1__Notice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Notice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ID", &a->ID, "xsd:string"))
				{	soap_flag_ID--;
					continue;
				}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			if (soap_flag_Classification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__NoticeClassification(soap, "ns1:Classification", &a->Classification, "ns1:NoticeClassification"))
				{	soap_flag_Classification--;
					continue;
				}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__NoticeStatus(soap, "ns1:Status", &a->Status, "ns1:NoticeStatus"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Name", &a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_PictureID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:PictureID", &a->PictureID, "ns1:ArrayOfString"))
				{	soap_flag_PictureID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Notice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Notice, 0, sizeof(struct ns1__Notice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Classification > 0 || soap_flag_Time > 0 || soap_flag_Status > 0 || soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Notice(struct soap *soap, const struct ns1__Notice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Notice);
	if (soap_out_ns1__Notice(soap, tag?tag:"ns1:Notice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Notice * SOAP_FMAC4 soap_get_ns1__Notice(struct soap *soap, struct ns1__Notice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Notice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfNotice(struct soap *soap, struct ns1__ArrayOfNotice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNotice = 0;
	a->Notice = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfNotice(struct soap *soap, const struct ns1__ArrayOfNotice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Notice)
	{	int i;
		for (i = 0; i < a->__sizeNotice; i++)
		{
			soap_embedded(soap, a->Notice + i, SOAP_TYPE_ns1__Notice);
			soap_serialize_ns1__Notice(soap, a->Notice + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfNotice(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfNotice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfNotice), type))
		return soap->error;
	if (a->Notice)
	{	int i;
		for (i = 0; i < a->__sizeNotice; i++)
			if (soap_out_ns1__Notice(soap, "ns1:Notice", -1, a->Notice + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfNotice * SOAP_FMAC4 soap_in_ns1__ArrayOfNotice(struct soap *soap, const char *tag, struct ns1__ArrayOfNotice *a, const char *type)
{
	struct soap_blist *soap_blist_Notice = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfNotice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfNotice, sizeof(struct ns1__ArrayOfNotice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfNotice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Notice", 1, NULL))
			{	if (a->Notice == NULL)
				{	if (soap_blist_Notice == NULL)
						soap_blist_Notice = soap_new_block(soap);
					a->Notice = (struct ns1__Notice *)soap_push_block(soap, soap_blist_Notice, sizeof(struct ns1__Notice));
					if (a->Notice == NULL)
						return NULL;
					soap_default_ns1__Notice(soap, a->Notice);
				}
				soap_revert(soap);
				if (soap_in_ns1__Notice(soap, "ns1:Notice", a->Notice, "ns1:Notice"))
				{	a->__sizeNotice++;
					a->Notice = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Notice)
			soap_pop_block(soap, soap_blist_Notice);
		if (a->__sizeNotice)
			a->Notice = (struct ns1__Notice *)soap_save_block(soap, soap_blist_Notice, NULL, 1);
		else
		{	a->Notice = NULL;
			if (soap_blist_Notice)
				soap_end_block(soap, soap_blist_Notice);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfNotice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfNotice, 0, sizeof(struct ns1__ArrayOfNotice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfNotice(struct soap *soap, const struct ns1__ArrayOfNotice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfNotice);
	if (soap_out_ns1__ArrayOfNotice(soap, tag?tag:"ns1:ArrayOfNotice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfNotice * SOAP_FMAC4 soap_get_ns1__ArrayOfNotice(struct soap *soap, struct ns1__ArrayOfNotice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfNotice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Dev(struct soap *soap, struct ns1__Dev *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_string(soap, &a->Name);
	soap_default_xsd__boolean(soap, &a->OnLine);
	soap_default_xsd__boolean(soap, &a->PtzFlag);
	soap_default_int(soap, &a->SharingFlag);
	soap_default_int(soap, &a->WirelessFlag);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Dev(struct soap *soap, const struct ns1__Dev *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->Name);
	soap_embedded(soap, &a->OnLine, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->PtzFlag, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->SharingFlag, SOAP_TYPE_int);
	soap_embedded(soap, &a->WirelessFlag, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Dev(struct soap *soap, const char *tag, int id, const struct ns1__Dev *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Dev), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:OnLine", -1, &a->OnLine, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:PtzFlag", -1, &a->PtzFlag, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:SharingFlag", -1, &a->SharingFlag, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:WirelessFlag", -1, &a->WirelessFlag, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Dev * SOAP_FMAC4 soap_in_ns1__Dev(struct soap *soap, const char *tag, struct ns1__Dev *a, const char *type)
{
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_OnLine = 1;
	size_t soap_flag_PtzFlag = 1;
	size_t soap_flag_SharingFlag = 1;
	size_t soap_flag_WirelessFlag = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Dev *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Dev, sizeof(struct ns1__Dev), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Dev(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Name", &a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_OnLine && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:OnLine", &a->OnLine, "xsd:boolean"))
				{	soap_flag_OnLine--;
					continue;
				}
			if (soap_flag_PtzFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:PtzFlag", &a->PtzFlag, "xsd:boolean"))
				{	soap_flag_PtzFlag--;
					continue;
				}
			if (soap_flag_SharingFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:SharingFlag", &a->SharingFlag, "xsd:int"))
				{	soap_flag_SharingFlag--;
					continue;
				}
			if (soap_flag_WirelessFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:WirelessFlag", &a->WirelessFlag, "xsd:int"))
				{	soap_flag_WirelessFlag--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Dev *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Dev, 0, sizeof(struct ns1__Dev), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_OnLine > 0 || soap_flag_PtzFlag > 0 || soap_flag_SharingFlag > 0 || soap_flag_WirelessFlag > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Dev(struct soap *soap, const struct ns1__Dev *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Dev);
	if (soap_out_ns1__Dev(soap, tag?tag:"ns1:Dev", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Dev * SOAP_FMAC4 soap_get_ns1__Dev(struct soap *soap, struct ns1__Dev *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Dev(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfDev(struct soap *soap, struct ns1__ArrayOfDev *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDev = 0;
	a->Dev = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfDev(struct soap *soap, const struct ns1__ArrayOfDev *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Dev)
	{	int i;
		for (i = 0; i < a->__sizeDev; i++)
		{
			soap_embedded(soap, a->Dev + i, SOAP_TYPE_ns1__Dev);
			soap_serialize_ns1__Dev(soap, a->Dev + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDev(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfDev *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDev), type))
		return soap->error;
	if (a->Dev)
	{	int i;
		for (i = 0; i < a->__sizeDev; i++)
			if (soap_out_ns1__Dev(soap, "ns1:Dev", -1, a->Dev + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfDev * SOAP_FMAC4 soap_in_ns1__ArrayOfDev(struct soap *soap, const char *tag, struct ns1__ArrayOfDev *a, const char *type)
{
	struct soap_blist *soap_blist_Dev = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfDev *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDev, sizeof(struct ns1__ArrayOfDev), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfDev(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Dev", 1, NULL))
			{	if (a->Dev == NULL)
				{	if (soap_blist_Dev == NULL)
						soap_blist_Dev = soap_new_block(soap);
					a->Dev = (struct ns1__Dev *)soap_push_block(soap, soap_blist_Dev, sizeof(struct ns1__Dev));
					if (a->Dev == NULL)
						return NULL;
					soap_default_ns1__Dev(soap, a->Dev);
				}
				soap_revert(soap);
				if (soap_in_ns1__Dev(soap, "ns1:Dev", a->Dev, "ns1:Dev"))
				{	a->__sizeDev++;
					a->Dev = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Dev)
			soap_pop_block(soap, soap_blist_Dev);
		if (a->__sizeDev)
			a->Dev = (struct ns1__Dev *)soap_save_block(soap, soap_blist_Dev, NULL, 1);
		else
		{	a->Dev = NULL;
			if (soap_blist_Dev)
				soap_end_block(soap, soap_blist_Dev);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfDev *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDev, 0, sizeof(struct ns1__ArrayOfDev), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfDev(struct soap *soap, const struct ns1__ArrayOfDev *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfDev);
	if (soap_out_ns1__ArrayOfDev(soap, tag?tag:"ns1:ArrayOfDev", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfDev * SOAP_FMAC4 soap_get_ns1__ArrayOfDev(struct soap *soap, struct ns1__ArrayOfDev *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDev(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__trustedAuthorityLoginRes(struct soap *soap, struct ns1__trustedAuthorityLoginRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->LoginSession);
	a->NodeList = NULL;
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Account);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__trustedAuthorityLoginRes(struct soap *soap, const struct ns1__trustedAuthorityLoginRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_PointerTons1__ArrayOfDev(soap, &a->NodeList);
	soap_serialize_string(soap, &a->Username);
	soap_serialize_string(soap, &a->Account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__trustedAuthorityLoginRes(struct soap *soap, const char *tag, int id, const struct ns1__trustedAuthorityLoginRes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__trustedAuthorityLoginRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfDev(soap, "ns1:NodeList", -1, &a->NodeList, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__trustedAuthorityLoginRes * SOAP_FMAC4 soap_in_ns1__trustedAuthorityLoginRes(struct soap *soap, const char *tag, struct ns1__trustedAuthorityLoginRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_NodeList = 1;
	size_t soap_flag_Username = 1;
	size_t soap_flag_Account = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__trustedAuthorityLoginRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__trustedAuthorityLoginRes, sizeof(struct ns1__trustedAuthorityLoginRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__trustedAuthorityLoginRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_NodeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDev(soap, "ns1:NodeList", &a->NodeList, "ns1:ArrayOfDev"))
				{	soap_flag_NodeList--;
					continue;
				}
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__trustedAuthorityLoginRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__trustedAuthorityLoginRes, 0, sizeof(struct ns1__trustedAuthorityLoginRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__trustedAuthorityLoginRes(struct soap *soap, const struct ns1__trustedAuthorityLoginRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__trustedAuthorityLoginRes);
	if (soap_out_ns1__trustedAuthorityLoginRes(soap, tag?tag:"ns1:trustedAuthorityLoginRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__trustedAuthorityLoginRes * SOAP_FMAC4 soap_get_ns1__trustedAuthorityLoginRes(struct soap *soap, struct ns1__trustedAuthorityLoginRes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__trustedAuthorityLoginRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__MCUDev(struct soap *soap, struct ns1__MCUDev *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->UUID);
	soap_default_string(soap, &a->Model);
	soap_default_ns1__MCUDevType(soap, &a->Type);
	soap_default_ns1__MCUOSType(soap, &a->OSType);
	soap_default_string(soap, &a->OSVersion);
	soap_default_string(soap, &a->Manufactory);
	soap_default_string(soap, &a->IEMI);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__MCUDev(struct soap *soap, const struct ns1__MCUDev *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->UUID);
	soap_serialize_string(soap, &a->Model);
	soap_serialize_string(soap, &a->OSVersion);
	soap_serialize_string(soap, &a->Manufactory);
	soap_serialize_string(soap, &a->IEMI);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MCUDev(struct soap *soap, const char *tag, int id, const struct ns1__MCUDev *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MCUDev), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:UUID", -1, &a->UUID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Model", -1, &a->Model, ""))
		return soap->error;
	if (soap_out_ns1__MCUDevType(soap, "ns1:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_ns1__MCUOSType(soap, "ns1:OSType", -1, &a->OSType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:OSVersion", -1, &a->OSVersion, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Manufactory", -1, &a->Manufactory, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:IEMI", -1, &a->IEMI, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__MCUDev * SOAP_FMAC4 soap_in_ns1__MCUDev(struct soap *soap, const char *tag, struct ns1__MCUDev *a, const char *type)
{
	size_t soap_flag_UUID = 1;
	size_t soap_flag_Model = 1;
	size_t soap_flag_Type = 1;
	size_t soap_flag_OSType = 1;
	size_t soap_flag_OSVersion = 1;
	size_t soap_flag_Manufactory = 1;
	size_t soap_flag_IEMI = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__MCUDev *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MCUDev, sizeof(struct ns1__MCUDev), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__MCUDev(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UUID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UUID", &a->UUID, "xsd:string"))
				{	soap_flag_UUID--;
					continue;
				}
			if (soap_flag_Model && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Model", &a->Model, "xsd:string"))
				{	soap_flag_Model--;
					continue;
				}
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUDevType(soap, "ns1:Type", &a->Type, "ns1:MCUDevType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_OSType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUOSType(soap, "ns1:OSType", &a->OSType, "ns1:MCUOSType"))
				{	soap_flag_OSType--;
					continue;
				}
			if (soap_flag_OSVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:OSVersion", &a->OSVersion, "xsd:string"))
				{	soap_flag_OSVersion--;
					continue;
				}
			if (soap_flag_Manufactory && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Manufactory", &a->Manufactory, "xsd:string"))
				{	soap_flag_Manufactory--;
					continue;
				}
			if (soap_flag_IEMI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:IEMI", &a->IEMI, "xsd:string"))
				{	soap_flag_IEMI--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__MCUDev *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MCUDev, 0, sizeof(struct ns1__MCUDev), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0 || soap_flag_OSType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MCUDev(struct soap *soap, const struct ns1__MCUDev *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__MCUDev);
	if (soap_out_ns1__MCUDev(soap, tag?tag:"ns1:MCUDev", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__MCUDev * SOAP_FMAC4 soap_get_ns1__MCUDev(struct soap *soap, struct ns1__MCUDev *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MCUDev(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__trustedAuthorityLoginReq(struct soap *soap, struct ns1__trustedAuthorityLoginReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->TrustedAuthority);
	soap_default_string(soap, &a->TrustedCode);
	soap_default_string(soap, &a->AuthorizationCode);
	soap_default_string(soap, &a->Version);
	soap_default_ns1__NetworkOperator(soap, &a->NetworkOperator);
	soap_default_ns1__NetType(soap, &a->NetType);
	a->MCUDev = NULL;
	soap_default_string(soap, &a->ApplicationID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__trustedAuthorityLoginReq(struct soap *soap, const struct ns1__trustedAuthorityLoginReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->TrustedAuthority);
	soap_serialize_string(soap, &a->TrustedCode);
	soap_serialize_string(soap, &a->AuthorizationCode);
	soap_serialize_string(soap, &a->Version);
	soap_serialize_PointerTons1__MCUDev(soap, &a->MCUDev);
	soap_serialize_string(soap, &a->ApplicationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__trustedAuthorityLoginReq(struct soap *soap, const char *tag, int id, const struct ns1__trustedAuthorityLoginReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__trustedAuthorityLoginReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:TrustedAuthority", -1, &a->TrustedAuthority, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:TrustedCode", -1, &a->TrustedCode, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:AuthorizationCode", -1, &a->AuthorizationCode, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Version", -1, &a->Version, ""))
		return soap->error;
	if (soap_out_ns1__NetworkOperator(soap, "ns1:NetworkOperator", -1, &a->NetworkOperator, ""))
		return soap->error;
	if (soap_out_ns1__NetType(soap, "ns1:NetType", -1, &a->NetType, ""))
		return soap->error;
	if (soap_out_PointerTons1__MCUDev(soap, "ns1:MCUDev", -1, &a->MCUDev, ""))
		return soap->error;
	if (a->ApplicationID)
	{	if (soap_out_string(soap, "ns1:ApplicationID", -1, &a->ApplicationID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:ApplicationID"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__trustedAuthorityLoginReq * SOAP_FMAC4 soap_in_ns1__trustedAuthorityLoginReq(struct soap *soap, const char *tag, struct ns1__trustedAuthorityLoginReq *a, const char *type)
{
	size_t soap_flag_TrustedAuthority = 1;
	size_t soap_flag_TrustedCode = 1;
	size_t soap_flag_AuthorizationCode = 1;
	size_t soap_flag_Version = 1;
	size_t soap_flag_NetworkOperator = 1;
	size_t soap_flag_NetType = 1;
	size_t soap_flag_MCUDev = 1;
	size_t soap_flag_ApplicationID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__trustedAuthorityLoginReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__trustedAuthorityLoginReq, sizeof(struct ns1__trustedAuthorityLoginReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__trustedAuthorityLoginReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrustedAuthority && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:TrustedAuthority", &a->TrustedAuthority, "xsd:string"))
				{	soap_flag_TrustedAuthority--;
					continue;
				}
			if (soap_flag_TrustedCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:TrustedCode", &a->TrustedCode, "xsd:string"))
				{	soap_flag_TrustedCode--;
					continue;
				}
			if (soap_flag_AuthorizationCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AuthorizationCode", &a->AuthorizationCode, "xsd:string"))
				{	soap_flag_AuthorizationCode--;
					continue;
				}
			if (soap_flag_Version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Version", &a->Version, "xsd:string"))
				{	soap_flag_Version--;
					continue;
				}
			if (soap_flag_NetworkOperator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__NetworkOperator(soap, "ns1:NetworkOperator", &a->NetworkOperator, "ns1:NetworkOperator"))
				{	soap_flag_NetworkOperator--;
					continue;
				}
			if (soap_flag_NetType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__NetType(soap, "ns1:NetType", &a->NetType, "ns1:NetType"))
				{	soap_flag_NetType--;
					continue;
				}
			if (soap_flag_MCUDev && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MCUDev(soap, "ns1:MCUDev", &a->MCUDev, "ns1:MCUDev"))
				{	soap_flag_MCUDev--;
					continue;
				}
			if (soap_flag_ApplicationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ApplicationID", &a->ApplicationID, "xsd:string"))
				{	soap_flag_ApplicationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__trustedAuthorityLoginReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__trustedAuthorityLoginReq, 0, sizeof(struct ns1__trustedAuthorityLoginReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NetworkOperator > 0 || soap_flag_NetType > 0 || soap_flag_ApplicationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__trustedAuthorityLoginReq(struct soap *soap, const struct ns1__trustedAuthorityLoginReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__trustedAuthorityLoginReq);
	if (soap_out_ns1__trustedAuthorityLoginReq(soap, tag?tag:"ns1:trustedAuthorityLoginReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__trustedAuthorityLoginReq * SOAP_FMAC4 soap_get_ns1__trustedAuthorityLoginReq(struct soap *soap, struct ns1__trustedAuthorityLoginReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__trustedAuthorityLoginReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Relay(struct soap *soap, struct ns1__Relay *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->No);
	soap_default_string(soap, &a->Name);
	a->State = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Relay(struct soap *soap, const struct ns1__Relay *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->No, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->Name);
	soap_serialize_PointerTons1__RelayState(soap, &a->State);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Relay(struct soap *soap, const char *tag, int id, const struct ns1__Relay *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Relay), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:No", -1, &a->No, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_PointerTons1__RelayState(soap, "ns1:State", -1, &a->State, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Relay * SOAP_FMAC4 soap_in_ns1__Relay(struct soap *soap, const char *tag, struct ns1__Relay *a, const char *type)
{
	size_t soap_flag_No = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_State = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Relay *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Relay, sizeof(struct ns1__Relay), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Relay(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_No && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:No", &a->No, "xsd:int"))
				{	soap_flag_No--;
					continue;
				}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Name", &a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RelayState(soap, "ns1:State", &a->State, "ns1:RelayState"))
				{	soap_flag_State--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Relay *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Relay, 0, sizeof(struct ns1__Relay), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_No > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Relay(struct soap *soap, const struct ns1__Relay *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Relay);
	if (soap_out_ns1__Relay(soap, tag?tag:"ns1:Relay", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Relay * SOAP_FMAC4 soap_get_ns1__Relay(struct soap *soap, struct ns1__Relay *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Relay(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__WorkSheet(struct soap *soap, struct ns1__WorkSheet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Enabled = NULL;
	soap_default_string(soap, &a->BitString);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__WorkSheet(struct soap *soap, const struct ns1__WorkSheet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_string(soap, &a->BitString);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WorkSheet(struct soap *soap, const char *tag, int id, const struct ns1__WorkSheet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WorkSheet), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:BitString", -1, &a->BitString, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__WorkSheet * SOAP_FMAC4 soap_in_ns1__WorkSheet(struct soap *soap, const char *tag, struct ns1__WorkSheet *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_BitString = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__WorkSheet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WorkSheet, sizeof(struct ns1__WorkSheet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__WorkSheet(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_BitString && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:BitString", &a->BitString, "xsd:string"))
				{	soap_flag_BitString--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__WorkSheet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__WorkSheet, 0, sizeof(struct ns1__WorkSheet), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__WorkSheet(struct soap *soap, const struct ns1__WorkSheet *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__WorkSheet);
	if (soap_out_ns1__WorkSheet(soap, tag?tag:"ns1:WorkSheet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__WorkSheet * SOAP_FMAC4 soap_get_ns1__WorkSheet(struct soap *soap, struct ns1__WorkSheet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WorkSheet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct SOAP_ENV__Reason *)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, *a);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct SOAP_ENV__Detail *)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, *a);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct SOAP_ENV__Code *)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, *a);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__vodSearchRes(struct soap *soap, struct _ns1__vodSearchRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__vodSearchRes))
		soap_serialize__ns1__vodSearchRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__vodSearchRes(struct soap *soap, const char *tag, int id, struct _ns1__vodSearchRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__vodSearchRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__vodSearchRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__vodSearchRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__vodSearchRes(struct soap *soap, const char *tag, struct _ns1__vodSearchRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__vodSearchRes **)soap_malloc(soap, sizeof(struct _ns1__vodSearchRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__vodSearchRes *)soap_malloc(soap, sizeof(struct _ns1__vodSearchRes));
		soap_default__ns1__vodSearchRes(soap, *a);
		if (!(*a = soap_in__ns1__vodSearchRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__vodSearchRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__vodSearchRes, sizeof(struct _ns1__vodSearchRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__vodSearchRes(struct soap *soap, struct _ns1__vodSearchRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__vodSearchRes);
	if (soap_out_PointerTo_ns1__vodSearchRes(soap, tag?tag:"ns1:vodSearchRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__vodSearchRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__vodSearchRes(struct soap *soap, struct _ns1__vodSearchRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__vodSearchRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__vodSearchReq(struct soap *soap, struct _ns1__vodSearchReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__vodSearchReq))
		soap_serialize__ns1__vodSearchReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__vodSearchReq(struct soap *soap, const char *tag, int id, struct _ns1__vodSearchReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__vodSearchReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__vodSearchReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__vodSearchReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__vodSearchReq(struct soap *soap, const char *tag, struct _ns1__vodSearchReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__vodSearchReq **)soap_malloc(soap, sizeof(struct _ns1__vodSearchReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__vodSearchReq *)soap_malloc(soap, sizeof(struct _ns1__vodSearchReq));
		soap_default__ns1__vodSearchReq(soap, *a);
		if (!(*a = soap_in__ns1__vodSearchReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__vodSearchReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__vodSearchReq, sizeof(struct _ns1__vodSearchReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__vodSearchReq(struct soap *soap, struct _ns1__vodSearchReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__vodSearchReq);
	if (soap_out_PointerTo_ns1__vodSearchReq(soap, tag?tag:"ns1:vodSearchReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__vodSearchReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__vodSearchReq(struct soap *soap, struct _ns1__vodSearchReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__vodSearchReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVODUrlRes(struct soap *soap, struct _ns1__getVODUrlRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVODUrlRes))
		soap_serialize__ns1__getVODUrlRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVODUrlRes(struct soap *soap, const char *tag, int id, struct _ns1__getVODUrlRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVODUrlRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVODUrlRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVODUrlRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVODUrlRes(struct soap *soap, const char *tag, struct _ns1__getVODUrlRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVODUrlRes **)soap_malloc(soap, sizeof(struct _ns1__getVODUrlRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getVODUrlRes *)soap_malloc(soap, sizeof(struct _ns1__getVODUrlRes));
		soap_default__ns1__getVODUrlRes(soap, *a);
		if (!(*a = soap_in__ns1__getVODUrlRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVODUrlRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVODUrlRes, sizeof(struct _ns1__getVODUrlRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVODUrlRes(struct soap *soap, struct _ns1__getVODUrlRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVODUrlRes);
	if (soap_out_PointerTo_ns1__getVODUrlRes(soap, tag?tag:"ns1:getVODUrlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVODUrlRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVODUrlRes(struct soap *soap, struct _ns1__getVODUrlRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVODUrlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVODUrlReq(struct soap *soap, struct _ns1__getVODUrlReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVODUrlReq))
		soap_serialize__ns1__getVODUrlReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVODUrlReq(struct soap *soap, const char *tag, int id, struct _ns1__getVODUrlReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVODUrlReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVODUrlReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVODUrlReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVODUrlReq(struct soap *soap, const char *tag, struct _ns1__getVODUrlReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVODUrlReq **)soap_malloc(soap, sizeof(struct _ns1__getVODUrlReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getVODUrlReq *)soap_malloc(soap, sizeof(struct _ns1__getVODUrlReq));
		soap_default__ns1__getVODUrlReq(soap, *a);
		if (!(*a = soap_in__ns1__getVODUrlReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVODUrlReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVODUrlReq, sizeof(struct _ns1__getVODUrlReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVODUrlReq(struct soap *soap, struct _ns1__getVODUrlReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVODUrlReq);
	if (soap_out_PointerTo_ns1__getVODUrlReq(soap, tag?tag:"ns1:getVODUrlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVODUrlReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVODUrlReq(struct soap *soap, struct _ns1__getVODUrlReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVODUrlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPlayUrlRes(struct soap *soap, struct _ns1__getPlayUrlRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPlayUrlRes))
		soap_serialize__ns1__getPlayUrlRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPlayUrlRes(struct soap *soap, const char *tag, int id, struct _ns1__getPlayUrlRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPlayUrlRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPlayUrlRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPlayUrlRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPlayUrlRes(struct soap *soap, const char *tag, struct _ns1__getPlayUrlRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPlayUrlRes **)soap_malloc(soap, sizeof(struct _ns1__getPlayUrlRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getPlayUrlRes *)soap_malloc(soap, sizeof(struct _ns1__getPlayUrlRes));
		soap_default__ns1__getPlayUrlRes(soap, *a);
		if (!(*a = soap_in__ns1__getPlayUrlRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPlayUrlRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPlayUrlRes, sizeof(struct _ns1__getPlayUrlRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPlayUrlRes(struct soap *soap, struct _ns1__getPlayUrlRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPlayUrlRes);
	if (soap_out_PointerTo_ns1__getPlayUrlRes(soap, tag?tag:"ns1:getPlayUrlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPlayUrlRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPlayUrlRes(struct soap *soap, struct _ns1__getPlayUrlRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPlayUrlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPlayUrlReq(struct soap *soap, struct _ns1__getPlayUrlReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPlayUrlReq))
		soap_serialize__ns1__getPlayUrlReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPlayUrlReq(struct soap *soap, const char *tag, int id, struct _ns1__getPlayUrlReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPlayUrlReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPlayUrlReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPlayUrlReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPlayUrlReq(struct soap *soap, const char *tag, struct _ns1__getPlayUrlReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPlayUrlReq **)soap_malloc(soap, sizeof(struct _ns1__getPlayUrlReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getPlayUrlReq *)soap_malloc(soap, sizeof(struct _ns1__getPlayUrlReq));
		soap_default__ns1__getPlayUrlReq(soap, *a);
		if (!(*a = soap_in__ns1__getPlayUrlReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPlayUrlReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPlayUrlReq, sizeof(struct _ns1__getPlayUrlReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPlayUrlReq(struct soap *soap, struct _ns1__getPlayUrlReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPlayUrlReq);
	if (soap_out_PointerTo_ns1__getPlayUrlReq(soap, tag?tag:"ns1:getPlayUrlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPlayUrlReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPlayUrlReq(struct soap *soap, struct _ns1__getPlayUrlReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPlayUrlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setPrivacyMaskParamRes(struct soap *soap, struct _ns1__setPrivacyMaskParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setPrivacyMaskParamRes))
		soap_serialize__ns1__setPrivacyMaskParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setPrivacyMaskParamRes(struct soap *soap, const char *tag, int id, struct _ns1__setPrivacyMaskParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setPrivacyMaskParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setPrivacyMaskParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setPrivacyMaskParamRes(struct soap *soap, const char *tag, struct _ns1__setPrivacyMaskParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setPrivacyMaskParamRes **)soap_malloc(soap, sizeof(struct _ns1__setPrivacyMaskParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setPrivacyMaskParamRes *)soap_malloc(soap, sizeof(struct _ns1__setPrivacyMaskParamRes));
		soap_default__ns1__setPrivacyMaskParamRes(soap, *a);
		if (!(*a = soap_in__ns1__setPrivacyMaskParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPrivacyMaskParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setPrivacyMaskParamRes, sizeof(struct _ns1__setPrivacyMaskParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setPrivacyMaskParamRes(struct soap *soap, struct _ns1__setPrivacyMaskParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamRes);
	if (soap_out_PointerTo_ns1__setPrivacyMaskParamRes(soap, tag?tag:"ns1:setPrivacyMaskParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setPrivacyMaskParamRes(struct soap *soap, struct _ns1__setPrivacyMaskParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setPrivacyMaskParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setPrivacyMaskParamReq(struct soap *soap, struct _ns1__setPrivacyMaskParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setPrivacyMaskParamReq))
		soap_serialize__ns1__setPrivacyMaskParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setPrivacyMaskParamReq(struct soap *soap, const char *tag, int id, struct _ns1__setPrivacyMaskParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setPrivacyMaskParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setPrivacyMaskParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setPrivacyMaskParamReq(struct soap *soap, const char *tag, struct _ns1__setPrivacyMaskParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setPrivacyMaskParamReq **)soap_malloc(soap, sizeof(struct _ns1__setPrivacyMaskParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setPrivacyMaskParamReq *)soap_malloc(soap, sizeof(struct _ns1__setPrivacyMaskParamReq));
		soap_default__ns1__setPrivacyMaskParamReq(soap, *a);
		if (!(*a = soap_in__ns1__setPrivacyMaskParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPrivacyMaskParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setPrivacyMaskParamReq, sizeof(struct _ns1__setPrivacyMaskParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setPrivacyMaskParamReq(struct soap *soap, struct _ns1__setPrivacyMaskParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamReq);
	if (soap_out_PointerTo_ns1__setPrivacyMaskParamReq(soap, tag?tag:"ns1:setPrivacyMaskParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setPrivacyMaskParamReq(struct soap *soap, struct _ns1__setPrivacyMaskParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setPrivacyMaskParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPrivacyMaskParamRes(struct soap *soap, struct _ns1__getPrivacyMaskParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPrivacyMaskParamRes))
		soap_serialize__ns1__getPrivacyMaskParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPrivacyMaskParamRes(struct soap *soap, const char *tag, int id, struct _ns1__getPrivacyMaskParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPrivacyMaskParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPrivacyMaskParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPrivacyMaskParamRes(struct soap *soap, const char *tag, struct _ns1__getPrivacyMaskParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPrivacyMaskParamRes **)soap_malloc(soap, sizeof(struct _ns1__getPrivacyMaskParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getPrivacyMaskParamRes *)soap_malloc(soap, sizeof(struct _ns1__getPrivacyMaskParamRes));
		soap_default__ns1__getPrivacyMaskParamRes(soap, *a);
		if (!(*a = soap_in__ns1__getPrivacyMaskParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPrivacyMaskParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPrivacyMaskParamRes, sizeof(struct _ns1__getPrivacyMaskParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPrivacyMaskParamRes(struct soap *soap, struct _ns1__getPrivacyMaskParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamRes);
	if (soap_out_PointerTo_ns1__getPrivacyMaskParamRes(soap, tag?tag:"ns1:getPrivacyMaskParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPrivacyMaskParamRes(struct soap *soap, struct _ns1__getPrivacyMaskParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPrivacyMaskParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPrivacyMaskParamReq(struct soap *soap, struct _ns1__getPrivacyMaskParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPrivacyMaskParamReq))
		soap_serialize__ns1__getPrivacyMaskParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPrivacyMaskParamReq(struct soap *soap, const char *tag, int id, struct _ns1__getPrivacyMaskParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPrivacyMaskParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPrivacyMaskParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPrivacyMaskParamReq(struct soap *soap, const char *tag, struct _ns1__getPrivacyMaskParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPrivacyMaskParamReq **)soap_malloc(soap, sizeof(struct _ns1__getPrivacyMaskParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getPrivacyMaskParamReq *)soap_malloc(soap, sizeof(struct _ns1__getPrivacyMaskParamReq));
		soap_default__ns1__getPrivacyMaskParamReq(soap, *a);
		if (!(*a = soap_in__ns1__getPrivacyMaskParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPrivacyMaskParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPrivacyMaskParamReq, sizeof(struct _ns1__getPrivacyMaskParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPrivacyMaskParamReq(struct soap *soap, struct _ns1__getPrivacyMaskParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamReq);
	if (soap_out_PointerTo_ns1__getPrivacyMaskParamReq(soap, tag?tag:"ns1:getPrivacyMaskParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPrivacyMaskParamReq(struct soap *soap, struct _ns1__getPrivacyMaskParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPrivacyMaskParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setVMDParamRes(struct soap *soap, struct _ns1__setVMDParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setVMDParamRes))
		soap_serialize__ns1__setVMDParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setVMDParamRes(struct soap *soap, const char *tag, int id, struct _ns1__setVMDParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setVMDParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setVMDParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setVMDParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setVMDParamRes(struct soap *soap, const char *tag, struct _ns1__setVMDParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setVMDParamRes **)soap_malloc(soap, sizeof(struct _ns1__setVMDParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setVMDParamRes *)soap_malloc(soap, sizeof(struct _ns1__setVMDParamRes));
		soap_default__ns1__setVMDParamRes(soap, *a);
		if (!(*a = soap_in__ns1__setVMDParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVMDParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setVMDParamRes, sizeof(struct _ns1__setVMDParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setVMDParamRes(struct soap *soap, struct _ns1__setVMDParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setVMDParamRes);
	if (soap_out_PointerTo_ns1__setVMDParamRes(soap, tag?tag:"ns1:setVMDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVMDParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setVMDParamRes(struct soap *soap, struct _ns1__setVMDParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setVMDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setVMDParamReq(struct soap *soap, struct _ns1__setVMDParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setVMDParamReq))
		soap_serialize__ns1__setVMDParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setVMDParamReq(struct soap *soap, const char *tag, int id, struct _ns1__setVMDParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setVMDParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setVMDParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setVMDParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setVMDParamReq(struct soap *soap, const char *tag, struct _ns1__setVMDParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setVMDParamReq **)soap_malloc(soap, sizeof(struct _ns1__setVMDParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setVMDParamReq *)soap_malloc(soap, sizeof(struct _ns1__setVMDParamReq));
		soap_default__ns1__setVMDParamReq(soap, *a);
		if (!(*a = soap_in__ns1__setVMDParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVMDParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setVMDParamReq, sizeof(struct _ns1__setVMDParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setVMDParamReq(struct soap *soap, struct _ns1__setVMDParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setVMDParamReq);
	if (soap_out_PointerTo_ns1__setVMDParamReq(soap, tag?tag:"ns1:setVMDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVMDParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setVMDParamReq(struct soap *soap, struct _ns1__setVMDParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setVMDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVMDParamRes(struct soap *soap, struct _ns1__getVMDParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVMDParamRes))
		soap_serialize__ns1__getVMDParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVMDParamRes(struct soap *soap, const char *tag, int id, struct _ns1__getVMDParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVMDParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVMDParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVMDParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVMDParamRes(struct soap *soap, const char *tag, struct _ns1__getVMDParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVMDParamRes **)soap_malloc(soap, sizeof(struct _ns1__getVMDParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getVMDParamRes *)soap_malloc(soap, sizeof(struct _ns1__getVMDParamRes));
		soap_default__ns1__getVMDParamRes(soap, *a);
		if (!(*a = soap_in__ns1__getVMDParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVMDParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVMDParamRes, sizeof(struct _ns1__getVMDParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVMDParamRes(struct soap *soap, struct _ns1__getVMDParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVMDParamRes);
	if (soap_out_PointerTo_ns1__getVMDParamRes(soap, tag?tag:"ns1:getVMDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVMDParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVMDParamRes(struct soap *soap, struct _ns1__getVMDParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVMDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVMDParamReq(struct soap *soap, struct _ns1__getVMDParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVMDParamReq))
		soap_serialize__ns1__getVMDParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVMDParamReq(struct soap *soap, const char *tag, int id, struct _ns1__getVMDParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVMDParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVMDParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVMDParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVMDParamReq(struct soap *soap, const char *tag, struct _ns1__getVMDParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVMDParamReq **)soap_malloc(soap, sizeof(struct _ns1__getVMDParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getVMDParamReq *)soap_malloc(soap, sizeof(struct _ns1__getVMDParamReq));
		soap_default__ns1__getVMDParamReq(soap, *a);
		if (!(*a = soap_in__ns1__getVMDParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVMDParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVMDParamReq, sizeof(struct _ns1__getVMDParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVMDParamReq(struct soap *soap, struct _ns1__getVMDParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVMDParamReq);
	if (soap_out_PointerTo_ns1__getVMDParamReq(soap, tag?tag:"ns1:getVMDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVMDParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVMDParamReq(struct soap *soap, struct _ns1__getVMDParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVMDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setTimeRes(struct soap *soap, struct _ns1__setTimeRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setTimeRes))
		soap_serialize__ns1__setTimeRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setTimeRes(struct soap *soap, const char *tag, int id, struct _ns1__setTimeRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setTimeRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setTimeRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setTimeRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setTimeRes(struct soap *soap, const char *tag, struct _ns1__setTimeRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setTimeRes **)soap_malloc(soap, sizeof(struct _ns1__setTimeRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setTimeRes *)soap_malloc(soap, sizeof(struct _ns1__setTimeRes));
		soap_default__ns1__setTimeRes(soap, *a);
		if (!(*a = soap_in__ns1__setTimeRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setTimeRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setTimeRes, sizeof(struct _ns1__setTimeRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setTimeRes(struct soap *soap, struct _ns1__setTimeRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setTimeRes);
	if (soap_out_PointerTo_ns1__setTimeRes(soap, tag?tag:"ns1:setTimeRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setTimeRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setTimeRes(struct soap *soap, struct _ns1__setTimeRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setTimeRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setTimeReq(struct soap *soap, struct _ns1__setTimeReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setTimeReq))
		soap_serialize__ns1__setTimeReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setTimeReq(struct soap *soap, const char *tag, int id, struct _ns1__setTimeReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setTimeReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setTimeReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setTimeReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setTimeReq(struct soap *soap, const char *tag, struct _ns1__setTimeReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setTimeReq **)soap_malloc(soap, sizeof(struct _ns1__setTimeReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setTimeReq *)soap_malloc(soap, sizeof(struct _ns1__setTimeReq));
		soap_default__ns1__setTimeReq(soap, *a);
		if (!(*a = soap_in__ns1__setTimeReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setTimeReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setTimeReq, sizeof(struct _ns1__setTimeReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setTimeReq(struct soap *soap, struct _ns1__setTimeReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setTimeReq);
	if (soap_out_PointerTo_ns1__setTimeReq(soap, tag?tag:"ns1:setTimeReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setTimeReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setTimeReq(struct soap *soap, struct _ns1__setTimeReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setTimeReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTimeRes(struct soap *soap, struct _ns1__getTimeRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTimeRes))
		soap_serialize__ns1__getTimeRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTimeRes(struct soap *soap, const char *tag, int id, struct _ns1__getTimeRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTimeRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getTimeRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getTimeRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTimeRes(struct soap *soap, const char *tag, struct _ns1__getTimeRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getTimeRes **)soap_malloc(soap, sizeof(struct _ns1__getTimeRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getTimeRes *)soap_malloc(soap, sizeof(struct _ns1__getTimeRes));
		soap_default__ns1__getTimeRes(soap, *a);
		if (!(*a = soap_in__ns1__getTimeRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getTimeRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTimeRes, sizeof(struct _ns1__getTimeRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTimeRes(struct soap *soap, struct _ns1__getTimeRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTimeRes);
	if (soap_out_PointerTo_ns1__getTimeRes(soap, tag?tag:"ns1:getTimeRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getTimeRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTimeRes(struct soap *soap, struct _ns1__getTimeRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTimeRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTimeReq(struct soap *soap, struct _ns1__getTimeReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTimeReq))
		soap_serialize__ns1__getTimeReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTimeReq(struct soap *soap, const char *tag, int id, struct _ns1__getTimeReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTimeReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getTimeReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getTimeReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTimeReq(struct soap *soap, const char *tag, struct _ns1__getTimeReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getTimeReq **)soap_malloc(soap, sizeof(struct _ns1__getTimeReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getTimeReq *)soap_malloc(soap, sizeof(struct _ns1__getTimeReq));
		soap_default__ns1__getTimeReq(soap, *a);
		if (!(*a = soap_in__ns1__getTimeReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getTimeReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTimeReq, sizeof(struct _ns1__getTimeReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTimeReq(struct soap *soap, struct _ns1__getTimeReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTimeReq);
	if (soap_out_PointerTo_ns1__getTimeReq(soap, tag?tag:"ns1:getTimeReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getTimeReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTimeReq(struct soap *soap, struct _ns1__getTimeReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTimeReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setOSDParamRes(struct soap *soap, struct _ns1__setOSDParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setOSDParamRes))
		soap_serialize__ns1__setOSDParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setOSDParamRes(struct soap *soap, const char *tag, int id, struct _ns1__setOSDParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setOSDParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setOSDParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setOSDParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setOSDParamRes(struct soap *soap, const char *tag, struct _ns1__setOSDParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setOSDParamRes **)soap_malloc(soap, sizeof(struct _ns1__setOSDParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setOSDParamRes *)soap_malloc(soap, sizeof(struct _ns1__setOSDParamRes));
		soap_default__ns1__setOSDParamRes(soap, *a);
		if (!(*a = soap_in__ns1__setOSDParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setOSDParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setOSDParamRes, sizeof(struct _ns1__setOSDParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setOSDParamRes(struct soap *soap, struct _ns1__setOSDParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setOSDParamRes);
	if (soap_out_PointerTo_ns1__setOSDParamRes(soap, tag?tag:"ns1:setOSDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setOSDParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setOSDParamRes(struct soap *soap, struct _ns1__setOSDParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setOSDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setOSDParamReq(struct soap *soap, struct _ns1__setOSDParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setOSDParamReq))
		soap_serialize__ns1__setOSDParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setOSDParamReq(struct soap *soap, const char *tag, int id, struct _ns1__setOSDParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setOSDParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setOSDParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setOSDParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setOSDParamReq(struct soap *soap, const char *tag, struct _ns1__setOSDParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setOSDParamReq **)soap_malloc(soap, sizeof(struct _ns1__setOSDParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setOSDParamReq *)soap_malloc(soap, sizeof(struct _ns1__setOSDParamReq));
		soap_default__ns1__setOSDParamReq(soap, *a);
		if (!(*a = soap_in__ns1__setOSDParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setOSDParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setOSDParamReq, sizeof(struct _ns1__setOSDParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setOSDParamReq(struct soap *soap, struct _ns1__setOSDParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setOSDParamReq);
	if (soap_out_PointerTo_ns1__setOSDParamReq(soap, tag?tag:"ns1:setOSDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setOSDParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setOSDParamReq(struct soap *soap, struct _ns1__setOSDParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setOSDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getOSDParamRes(struct soap *soap, struct _ns1__getOSDParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getOSDParamRes))
		soap_serialize__ns1__getOSDParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getOSDParamRes(struct soap *soap, const char *tag, int id, struct _ns1__getOSDParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getOSDParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getOSDParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getOSDParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getOSDParamRes(struct soap *soap, const char *tag, struct _ns1__getOSDParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getOSDParamRes **)soap_malloc(soap, sizeof(struct _ns1__getOSDParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getOSDParamRes *)soap_malloc(soap, sizeof(struct _ns1__getOSDParamRes));
		soap_default__ns1__getOSDParamRes(soap, *a);
		if (!(*a = soap_in__ns1__getOSDParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getOSDParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getOSDParamRes, sizeof(struct _ns1__getOSDParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getOSDParamRes(struct soap *soap, struct _ns1__getOSDParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getOSDParamRes);
	if (soap_out_PointerTo_ns1__getOSDParamRes(soap, tag?tag:"ns1:getOSDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getOSDParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getOSDParamRes(struct soap *soap, struct _ns1__getOSDParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getOSDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getOSDParamReq(struct soap *soap, struct _ns1__getOSDParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getOSDParamReq))
		soap_serialize__ns1__getOSDParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getOSDParamReq(struct soap *soap, const char *tag, int id, struct _ns1__getOSDParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getOSDParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getOSDParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getOSDParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getOSDParamReq(struct soap *soap, const char *tag, struct _ns1__getOSDParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getOSDParamReq **)soap_malloc(soap, sizeof(struct _ns1__getOSDParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getOSDParamReq *)soap_malloc(soap, sizeof(struct _ns1__getOSDParamReq));
		soap_default__ns1__getOSDParamReq(soap, *a);
		if (!(*a = soap_in__ns1__getOSDParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getOSDParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getOSDParamReq, sizeof(struct _ns1__getOSDParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getOSDParamReq(struct soap *soap, struct _ns1__getOSDParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getOSDParamReq);
	if (soap_out_PointerTo_ns1__getOSDParamReq(soap, tag?tag:"ns1:getOSDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getOSDParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getOSDParamReq(struct soap *soap, struct _ns1__getOSDParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getOSDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setVideoParamRes(struct soap *soap, struct _ns1__setVideoParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setVideoParamRes))
		soap_serialize__ns1__setVideoParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setVideoParamRes(struct soap *soap, const char *tag, int id, struct _ns1__setVideoParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setVideoParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setVideoParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setVideoParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setVideoParamRes(struct soap *soap, const char *tag, struct _ns1__setVideoParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setVideoParamRes **)soap_malloc(soap, sizeof(struct _ns1__setVideoParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setVideoParamRes *)soap_malloc(soap, sizeof(struct _ns1__setVideoParamRes));
		soap_default__ns1__setVideoParamRes(soap, *a);
		if (!(*a = soap_in__ns1__setVideoParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVideoParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setVideoParamRes, sizeof(struct _ns1__setVideoParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setVideoParamRes(struct soap *soap, struct _ns1__setVideoParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setVideoParamRes);
	if (soap_out_PointerTo_ns1__setVideoParamRes(soap, tag?tag:"ns1:setVideoParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVideoParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setVideoParamRes(struct soap *soap, struct _ns1__setVideoParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setVideoParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setVideoParamReq(struct soap *soap, struct _ns1__setVideoParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setVideoParamReq))
		soap_serialize__ns1__setVideoParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setVideoParamReq(struct soap *soap, const char *tag, int id, struct _ns1__setVideoParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setVideoParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setVideoParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setVideoParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setVideoParamReq(struct soap *soap, const char *tag, struct _ns1__setVideoParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setVideoParamReq **)soap_malloc(soap, sizeof(struct _ns1__setVideoParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setVideoParamReq *)soap_malloc(soap, sizeof(struct _ns1__setVideoParamReq));
		soap_default__ns1__setVideoParamReq(soap, *a);
		if (!(*a = soap_in__ns1__setVideoParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVideoParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setVideoParamReq, sizeof(struct _ns1__setVideoParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setVideoParamReq(struct soap *soap, struct _ns1__setVideoParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setVideoParamReq);
	if (soap_out_PointerTo_ns1__setVideoParamReq(soap, tag?tag:"ns1:setVideoParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVideoParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setVideoParamReq(struct soap *soap, struct _ns1__setVideoParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setVideoParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVideoParamRes(struct soap *soap, struct _ns1__getVideoParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVideoParamRes))
		soap_serialize__ns1__getVideoParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVideoParamRes(struct soap *soap, const char *tag, int id, struct _ns1__getVideoParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVideoParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVideoParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVideoParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVideoParamRes(struct soap *soap, const char *tag, struct _ns1__getVideoParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVideoParamRes **)soap_malloc(soap, sizeof(struct _ns1__getVideoParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getVideoParamRes *)soap_malloc(soap, sizeof(struct _ns1__getVideoParamRes));
		soap_default__ns1__getVideoParamRes(soap, *a);
		if (!(*a = soap_in__ns1__getVideoParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVideoParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVideoParamRes, sizeof(struct _ns1__getVideoParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVideoParamRes(struct soap *soap, struct _ns1__getVideoParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVideoParamRes);
	if (soap_out_PointerTo_ns1__getVideoParamRes(soap, tag?tag:"ns1:getVideoParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVideoParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVideoParamRes(struct soap *soap, struct _ns1__getVideoParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVideoParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVideoParamReq(struct soap *soap, struct _ns1__getVideoParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVideoParamReq))
		soap_serialize__ns1__getVideoParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVideoParamReq(struct soap *soap, const char *tag, int id, struct _ns1__getVideoParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVideoParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVideoParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVideoParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVideoParamReq(struct soap *soap, const char *tag, struct _ns1__getVideoParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVideoParamReq **)soap_malloc(soap, sizeof(struct _ns1__getVideoParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getVideoParamReq *)soap_malloc(soap, sizeof(struct _ns1__getVideoParamReq));
		soap_default__ns1__getVideoParamReq(soap, *a);
		if (!(*a = soap_in__ns1__getVideoParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVideoParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVideoParamReq, sizeof(struct _ns1__getVideoParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVideoParamReq(struct soap *soap, struct _ns1__getVideoParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVideoParamReq);
	if (soap_out_PointerTo_ns1__getVideoParamReq(soap, tag?tag:"ns1:getVideoParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVideoParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVideoParamReq(struct soap *soap, struct _ns1__getVideoParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVideoParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDevLogRes(struct soap *soap, struct _ns1__queryDevLogRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDevLogRes))
		soap_serialize__ns1__queryDevLogRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDevLogRes(struct soap *soap, const char *tag, int id, struct _ns1__queryDevLogRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDevLogRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDevLogRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDevLogRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDevLogRes(struct soap *soap, const char *tag, struct _ns1__queryDevLogRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDevLogRes **)soap_malloc(soap, sizeof(struct _ns1__queryDevLogRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryDevLogRes *)soap_malloc(soap, sizeof(struct _ns1__queryDevLogRes));
		soap_default__ns1__queryDevLogRes(soap, *a);
		if (!(*a = soap_in__ns1__queryDevLogRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDevLogRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDevLogRes, sizeof(struct _ns1__queryDevLogRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDevLogRes(struct soap *soap, struct _ns1__queryDevLogRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDevLogRes);
	if (soap_out_PointerTo_ns1__queryDevLogRes(soap, tag?tag:"ns1:queryDevLogRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDevLogRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDevLogRes(struct soap *soap, struct _ns1__queryDevLogRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDevLogRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDevLogReq(struct soap *soap, struct _ns1__queryDevLogReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDevLogReq))
		soap_serialize__ns1__queryDevLogReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDevLogReq(struct soap *soap, const char *tag, int id, struct _ns1__queryDevLogReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDevLogReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDevLogReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDevLogReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDevLogReq(struct soap *soap, const char *tag, struct _ns1__queryDevLogReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDevLogReq **)soap_malloc(soap, sizeof(struct _ns1__queryDevLogReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryDevLogReq *)soap_malloc(soap, sizeof(struct _ns1__queryDevLogReq));
		soap_default__ns1__queryDevLogReq(soap, *a);
		if (!(*a = soap_in__ns1__queryDevLogReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDevLogReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDevLogReq, sizeof(struct _ns1__queryDevLogReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDevLogReq(struct soap *soap, struct _ns1__queryDevLogReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDevLogReq);
	if (soap_out_PointerTo_ns1__queryDevLogReq(soap, tag?tag:"ns1:queryDevLogReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDevLogReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDevLogReq(struct soap *soap, struct _ns1__queryDevLogReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDevLogReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryLogRes(struct soap *soap, struct _ns1__queryLogRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryLogRes))
		soap_serialize__ns1__queryLogRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryLogRes(struct soap *soap, const char *tag, int id, struct _ns1__queryLogRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryLogRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryLogRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryLogRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryLogRes(struct soap *soap, const char *tag, struct _ns1__queryLogRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryLogRes **)soap_malloc(soap, sizeof(struct _ns1__queryLogRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryLogRes *)soap_malloc(soap, sizeof(struct _ns1__queryLogRes));
		soap_default__ns1__queryLogRes(soap, *a);
		if (!(*a = soap_in__ns1__queryLogRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryLogRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryLogRes, sizeof(struct _ns1__queryLogRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryLogRes(struct soap *soap, struct _ns1__queryLogRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryLogRes);
	if (soap_out_PointerTo_ns1__queryLogRes(soap, tag?tag:"ns1:queryLogRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryLogRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryLogRes(struct soap *soap, struct _ns1__queryLogRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryLogRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryLogReq(struct soap *soap, struct _ns1__queryLogReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryLogReq))
		soap_serialize__ns1__queryLogReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryLogReq(struct soap *soap, const char *tag, int id, struct _ns1__queryLogReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryLogReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryLogReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryLogReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryLogReq(struct soap *soap, const char *tag, struct _ns1__queryLogReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryLogReq **)soap_malloc(soap, sizeof(struct _ns1__queryLogReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryLogReq *)soap_malloc(soap, sizeof(struct _ns1__queryLogReq));
		soap_default__ns1__queryLogReq(soap, *a);
		if (!(*a = soap_in__ns1__queryLogReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryLogReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryLogReq, sizeof(struct _ns1__queryLogReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryLogReq(struct soap *soap, struct _ns1__queryLogReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryLogReq);
	if (soap_out_PointerTo_ns1__queryLogReq(soap, tag?tag:"ns1:queryLogReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryLogReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryLogReq(struct soap *soap, struct _ns1__queryLogReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryLogReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__upgradeDevVerRes(struct soap *soap, struct _ns1__upgradeDevVerRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__upgradeDevVerRes))
		soap_serialize__ns1__upgradeDevVerRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__upgradeDevVerRes(struct soap *soap, const char *tag, int id, struct _ns1__upgradeDevVerRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__upgradeDevVerRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__upgradeDevVerRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__upgradeDevVerRes(struct soap *soap, const char *tag, struct _ns1__upgradeDevVerRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__upgradeDevVerRes **)soap_malloc(soap, sizeof(struct _ns1__upgradeDevVerRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__upgradeDevVerRes *)soap_malloc(soap, sizeof(struct _ns1__upgradeDevVerRes));
		soap_default__ns1__upgradeDevVerRes(soap, *a);
		if (!(*a = soap_in__ns1__upgradeDevVerRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__upgradeDevVerRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__upgradeDevVerRes, sizeof(struct _ns1__upgradeDevVerRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__upgradeDevVerRes(struct soap *soap, struct _ns1__upgradeDevVerRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__upgradeDevVerRes);
	if (soap_out_PointerTo_ns1__upgradeDevVerRes(soap, tag?tag:"ns1:upgradeDevVerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__upgradeDevVerRes(struct soap *soap, struct _ns1__upgradeDevVerRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__upgradeDevVerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__upgradeDevVerReq(struct soap *soap, struct _ns1__upgradeDevVerReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__upgradeDevVerReq))
		soap_serialize__ns1__upgradeDevVerReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__upgradeDevVerReq(struct soap *soap, const char *tag, int id, struct _ns1__upgradeDevVerReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__upgradeDevVerReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__upgradeDevVerReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__upgradeDevVerReq(struct soap *soap, const char *tag, struct _ns1__upgradeDevVerReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__upgradeDevVerReq **)soap_malloc(soap, sizeof(struct _ns1__upgradeDevVerReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__upgradeDevVerReq *)soap_malloc(soap, sizeof(struct _ns1__upgradeDevVerReq));
		soap_default__ns1__upgradeDevVerReq(soap, *a);
		if (!(*a = soap_in__ns1__upgradeDevVerReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__upgradeDevVerReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__upgradeDevVerReq, sizeof(struct _ns1__upgradeDevVerReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__upgradeDevVerReq(struct soap *soap, struct _ns1__upgradeDevVerReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__upgradeDevVerReq);
	if (soap_out_PointerTo_ns1__upgradeDevVerReq(soap, tag?tag:"ns1:upgradeDevVerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__upgradeDevVerReq(struct soap *soap, struct _ns1__upgradeDevVerReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__upgradeDevVerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDevVerRes(struct soap *soap, struct _ns1__getDevVerRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDevVerRes))
		soap_serialize__ns1__getDevVerRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDevVerRes(struct soap *soap, const char *tag, int id, struct _ns1__getDevVerRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDevVerRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getDevVerRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getDevVerRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDevVerRes(struct soap *soap, const char *tag, struct _ns1__getDevVerRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getDevVerRes **)soap_malloc(soap, sizeof(struct _ns1__getDevVerRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getDevVerRes *)soap_malloc(soap, sizeof(struct _ns1__getDevVerRes));
		soap_default__ns1__getDevVerRes(soap, *a);
		if (!(*a = soap_in__ns1__getDevVerRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDevVerRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDevVerRes, sizeof(struct _ns1__getDevVerRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDevVerRes(struct soap *soap, struct _ns1__getDevVerRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDevVerRes);
	if (soap_out_PointerTo_ns1__getDevVerRes(soap, tag?tag:"ns1:getDevVerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDevVerRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDevVerRes(struct soap *soap, struct _ns1__getDevVerRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDevVerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDevVerReq(struct soap *soap, struct _ns1__getDevVerReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDevVerReq))
		soap_serialize__ns1__getDevVerReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDevVerReq(struct soap *soap, const char *tag, int id, struct _ns1__getDevVerReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDevVerReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getDevVerReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getDevVerReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDevVerReq(struct soap *soap, const char *tag, struct _ns1__getDevVerReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getDevVerReq **)soap_malloc(soap, sizeof(struct _ns1__getDevVerReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getDevVerReq *)soap_malloc(soap, sizeof(struct _ns1__getDevVerReq));
		soap_default__ns1__getDevVerReq(soap, *a);
		if (!(*a = soap_in__ns1__getDevVerReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDevVerReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDevVerReq, sizeof(struct _ns1__getDevVerReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDevVerReq(struct soap *soap, struct _ns1__getDevVerReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDevVerReq);
	if (soap_out_PointerTo_ns1__getDevVerReq(soap, tag?tag:"ns1:getDevVerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDevVerReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDevVerReq(struct soap *soap, struct _ns1__getDevVerReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDevVerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__rebootRes(struct soap *soap, struct _ns1__rebootRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__rebootRes))
		soap_serialize__ns1__rebootRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__rebootRes(struct soap *soap, const char *tag, int id, struct _ns1__rebootRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__rebootRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__rebootRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__rebootRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__rebootRes(struct soap *soap, const char *tag, struct _ns1__rebootRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__rebootRes **)soap_malloc(soap, sizeof(struct _ns1__rebootRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__rebootRes *)soap_malloc(soap, sizeof(struct _ns1__rebootRes));
		soap_default__ns1__rebootRes(soap, *a);
		if (!(*a = soap_in__ns1__rebootRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__rebootRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__rebootRes, sizeof(struct _ns1__rebootRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__rebootRes(struct soap *soap, struct _ns1__rebootRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__rebootRes);
	if (soap_out_PointerTo_ns1__rebootRes(soap, tag?tag:"ns1:rebootRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__rebootRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__rebootRes(struct soap *soap, struct _ns1__rebootRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__rebootRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__rebootReq(struct soap *soap, struct _ns1__rebootReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__rebootReq))
		soap_serialize__ns1__rebootReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__rebootReq(struct soap *soap, const char *tag, int id, struct _ns1__rebootReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__rebootReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__rebootReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__rebootReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__rebootReq(struct soap *soap, const char *tag, struct _ns1__rebootReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__rebootReq **)soap_malloc(soap, sizeof(struct _ns1__rebootReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__rebootReq *)soap_malloc(soap, sizeof(struct _ns1__rebootReq));
		soap_default__ns1__rebootReq(soap, *a);
		if (!(*a = soap_in__ns1__rebootReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__rebootReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__rebootReq, sizeof(struct _ns1__rebootReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__rebootReq(struct soap *soap, struct _ns1__rebootReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__rebootReq);
	if (soap_out_PointerTo_ns1__rebootReq(soap, tag?tag:"ns1:rebootReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__rebootReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__rebootReq(struct soap *soap, struct _ns1__rebootReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__rebootReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setCodingParamRes(struct soap *soap, struct _ns1__setCodingParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setCodingParamRes))
		soap_serialize__ns1__setCodingParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setCodingParamRes(struct soap *soap, const char *tag, int id, struct _ns1__setCodingParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setCodingParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setCodingParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setCodingParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setCodingParamRes(struct soap *soap, const char *tag, struct _ns1__setCodingParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setCodingParamRes **)soap_malloc(soap, sizeof(struct _ns1__setCodingParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setCodingParamRes *)soap_malloc(soap, sizeof(struct _ns1__setCodingParamRes));
		soap_default__ns1__setCodingParamRes(soap, *a);
		if (!(*a = soap_in__ns1__setCodingParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setCodingParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setCodingParamRes, sizeof(struct _ns1__setCodingParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setCodingParamRes(struct soap *soap, struct _ns1__setCodingParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setCodingParamRes);
	if (soap_out_PointerTo_ns1__setCodingParamRes(soap, tag?tag:"ns1:setCodingParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setCodingParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setCodingParamRes(struct soap *soap, struct _ns1__setCodingParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setCodingParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setCodingParamReq(struct soap *soap, struct _ns1__setCodingParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setCodingParamReq))
		soap_serialize__ns1__setCodingParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setCodingParamReq(struct soap *soap, const char *tag, int id, struct _ns1__setCodingParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setCodingParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setCodingParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setCodingParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setCodingParamReq(struct soap *soap, const char *tag, struct _ns1__setCodingParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setCodingParamReq **)soap_malloc(soap, sizeof(struct _ns1__setCodingParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setCodingParamReq *)soap_malloc(soap, sizeof(struct _ns1__setCodingParamReq));
		soap_default__ns1__setCodingParamReq(soap, *a);
		if (!(*a = soap_in__ns1__setCodingParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setCodingParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setCodingParamReq, sizeof(struct _ns1__setCodingParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setCodingParamReq(struct soap *soap, struct _ns1__setCodingParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setCodingParamReq);
	if (soap_out_PointerTo_ns1__setCodingParamReq(soap, tag?tag:"ns1:setCodingParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setCodingParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setCodingParamReq(struct soap *soap, struct _ns1__setCodingParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setCodingParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getCodingParamRes(struct soap *soap, struct _ns1__getCodingParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getCodingParamRes))
		soap_serialize__ns1__getCodingParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getCodingParamRes(struct soap *soap, const char *tag, int id, struct _ns1__getCodingParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getCodingParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getCodingParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getCodingParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getCodingParamRes(struct soap *soap, const char *tag, struct _ns1__getCodingParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getCodingParamRes **)soap_malloc(soap, sizeof(struct _ns1__getCodingParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getCodingParamRes *)soap_malloc(soap, sizeof(struct _ns1__getCodingParamRes));
		soap_default__ns1__getCodingParamRes(soap, *a);
		if (!(*a = soap_in__ns1__getCodingParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getCodingParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getCodingParamRes, sizeof(struct _ns1__getCodingParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getCodingParamRes(struct soap *soap, struct _ns1__getCodingParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getCodingParamRes);
	if (soap_out_PointerTo_ns1__getCodingParamRes(soap, tag?tag:"ns1:getCodingParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getCodingParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getCodingParamRes(struct soap *soap, struct _ns1__getCodingParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getCodingParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getCodingParamReq(struct soap *soap, struct _ns1__getCodingParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getCodingParamReq))
		soap_serialize__ns1__getCodingParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getCodingParamReq(struct soap *soap, const char *tag, int id, struct _ns1__getCodingParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getCodingParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getCodingParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getCodingParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getCodingParamReq(struct soap *soap, const char *tag, struct _ns1__getCodingParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getCodingParamReq **)soap_malloc(soap, sizeof(struct _ns1__getCodingParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getCodingParamReq *)soap_malloc(soap, sizeof(struct _ns1__getCodingParamReq));
		soap_default__ns1__getCodingParamReq(soap, *a);
		if (!(*a = soap_in__ns1__getCodingParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getCodingParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getCodingParamReq, sizeof(struct _ns1__getCodingParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getCodingParamReq(struct soap *soap, struct _ns1__getCodingParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getCodingParamReq);
	if (soap_out_PointerTo_ns1__getCodingParamReq(soap, tag?tag:"ns1:getCodingParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getCodingParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getCodingParamReq(struct soap *soap, struct _ns1__getCodingParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getCodingParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__presetControlRes(struct soap *soap, struct _ns1__presetControlRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__presetControlRes))
		soap_serialize__ns1__presetControlRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__presetControlRes(struct soap *soap, const char *tag, int id, struct _ns1__presetControlRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__presetControlRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__presetControlRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__presetControlRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__presetControlRes(struct soap *soap, const char *tag, struct _ns1__presetControlRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__presetControlRes **)soap_malloc(soap, sizeof(struct _ns1__presetControlRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__presetControlRes *)soap_malloc(soap, sizeof(struct _ns1__presetControlRes));
		soap_default__ns1__presetControlRes(soap, *a);
		if (!(*a = soap_in__ns1__presetControlRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__presetControlRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__presetControlRes, sizeof(struct _ns1__presetControlRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__presetControlRes(struct soap *soap, struct _ns1__presetControlRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__presetControlRes);
	if (soap_out_PointerTo_ns1__presetControlRes(soap, tag?tag:"ns1:presetControlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__presetControlRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__presetControlRes(struct soap *soap, struct _ns1__presetControlRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__presetControlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__presetControlReq(struct soap *soap, struct _ns1__presetControlReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__presetControlReq))
		soap_serialize__ns1__presetControlReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__presetControlReq(struct soap *soap, const char *tag, int id, struct _ns1__presetControlReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__presetControlReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__presetControlReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__presetControlReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__presetControlReq(struct soap *soap, const char *tag, struct _ns1__presetControlReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__presetControlReq **)soap_malloc(soap, sizeof(struct _ns1__presetControlReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__presetControlReq *)soap_malloc(soap, sizeof(struct _ns1__presetControlReq));
		soap_default__ns1__presetControlReq(soap, *a);
		if (!(*a = soap_in__ns1__presetControlReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__presetControlReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__presetControlReq, sizeof(struct _ns1__presetControlReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__presetControlReq(struct soap *soap, struct _ns1__presetControlReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__presetControlReq);
	if (soap_out_PointerTo_ns1__presetControlReq(soap, tag?tag:"ns1:presetControlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__presetControlReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__presetControlReq(struct soap *soap, struct _ns1__presetControlReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__presetControlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__lensControlRes(struct soap *soap, struct _ns1__lensControlRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__lensControlRes))
		soap_serialize__ns1__lensControlRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__lensControlRes(struct soap *soap, const char *tag, int id, struct _ns1__lensControlRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__lensControlRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__lensControlRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__lensControlRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__lensControlRes(struct soap *soap, const char *tag, struct _ns1__lensControlRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__lensControlRes **)soap_malloc(soap, sizeof(struct _ns1__lensControlRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__lensControlRes *)soap_malloc(soap, sizeof(struct _ns1__lensControlRes));
		soap_default__ns1__lensControlRes(soap, *a);
		if (!(*a = soap_in__ns1__lensControlRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__lensControlRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__lensControlRes, sizeof(struct _ns1__lensControlRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__lensControlRes(struct soap *soap, struct _ns1__lensControlRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__lensControlRes);
	if (soap_out_PointerTo_ns1__lensControlRes(soap, tag?tag:"ns1:lensControlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__lensControlRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__lensControlRes(struct soap *soap, struct _ns1__lensControlRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__lensControlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__lensControlReq(struct soap *soap, struct _ns1__lensControlReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__lensControlReq))
		soap_serialize__ns1__lensControlReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__lensControlReq(struct soap *soap, const char *tag, int id, struct _ns1__lensControlReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__lensControlReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__lensControlReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__lensControlReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__lensControlReq(struct soap *soap, const char *tag, struct _ns1__lensControlReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__lensControlReq **)soap_malloc(soap, sizeof(struct _ns1__lensControlReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__lensControlReq *)soap_malloc(soap, sizeof(struct _ns1__lensControlReq));
		soap_default__ns1__lensControlReq(soap, *a);
		if (!(*a = soap_in__ns1__lensControlReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__lensControlReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__lensControlReq, sizeof(struct _ns1__lensControlReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__lensControlReq(struct soap *soap, struct _ns1__lensControlReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__lensControlReq);
	if (soap_out_PointerTo_ns1__lensControlReq(soap, tag?tag:"ns1:lensControlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__lensControlReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__lensControlReq(struct soap *soap, struct _ns1__lensControlReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__lensControlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ptzControlRes(struct soap *soap, struct _ns1__ptzControlRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ptzControlRes))
		soap_serialize__ns1__ptzControlRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ptzControlRes(struct soap *soap, const char *tag, int id, struct _ns1__ptzControlRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ptzControlRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ptzControlRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ptzControlRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__ptzControlRes(struct soap *soap, const char *tag, struct _ns1__ptzControlRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ptzControlRes **)soap_malloc(soap, sizeof(struct _ns1__ptzControlRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__ptzControlRes *)soap_malloc(soap, sizeof(struct _ns1__ptzControlRes));
		soap_default__ns1__ptzControlRes(soap, *a);
		if (!(*a = soap_in__ns1__ptzControlRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ptzControlRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ptzControlRes, sizeof(struct _ns1__ptzControlRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ptzControlRes(struct soap *soap, struct _ns1__ptzControlRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ptzControlRes);
	if (soap_out_PointerTo_ns1__ptzControlRes(soap, tag?tag:"ns1:ptzControlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ptzControlRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__ptzControlRes(struct soap *soap, struct _ns1__ptzControlRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ptzControlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ptzControlReq(struct soap *soap, struct _ns1__ptzControlReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ptzControlReq))
		soap_serialize__ns1__ptzControlReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ptzControlReq(struct soap *soap, const char *tag, int id, struct _ns1__ptzControlReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ptzControlReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ptzControlReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ptzControlReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__ptzControlReq(struct soap *soap, const char *tag, struct _ns1__ptzControlReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ptzControlReq **)soap_malloc(soap, sizeof(struct _ns1__ptzControlReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__ptzControlReq *)soap_malloc(soap, sizeof(struct _ns1__ptzControlReq));
		soap_default__ns1__ptzControlReq(soap, *a);
		if (!(*a = soap_in__ns1__ptzControlReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ptzControlReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ptzControlReq, sizeof(struct _ns1__ptzControlReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ptzControlReq(struct soap *soap, struct _ns1__ptzControlReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ptzControlReq);
	if (soap_out_PointerTo_ns1__ptzControlReq(soap, tag?tag:"ns1:ptzControlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ptzControlReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__ptzControlReq(struct soap *soap, struct _ns1__ptzControlReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ptzControlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__nullifyDeviceRes(struct soap *soap, struct _ns1__nullifyDeviceRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__nullifyDeviceRes))
		soap_serialize__ns1__nullifyDeviceRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__nullifyDeviceRes(struct soap *soap, const char *tag, int id, struct _ns1__nullifyDeviceRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__nullifyDeviceRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__nullifyDeviceRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__nullifyDeviceRes(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__nullifyDeviceRes **)soap_malloc(soap, sizeof(struct _ns1__nullifyDeviceRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__nullifyDeviceRes *)soap_malloc(soap, sizeof(struct _ns1__nullifyDeviceRes));
		soap_default__ns1__nullifyDeviceRes(soap, *a);
		if (!(*a = soap_in__ns1__nullifyDeviceRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__nullifyDeviceRes, sizeof(struct _ns1__nullifyDeviceRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__nullifyDeviceRes(struct soap *soap, struct _ns1__nullifyDeviceRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__nullifyDeviceRes);
	if (soap_out_PointerTo_ns1__nullifyDeviceRes(soap, tag?tag:"ns1:nullifyDeviceRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__nullifyDeviceRes(struct soap *soap, struct _ns1__nullifyDeviceRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__nullifyDeviceRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__nullifyDeviceReq(struct soap *soap, struct _ns1__nullifyDeviceReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__nullifyDeviceReq))
		soap_serialize__ns1__nullifyDeviceReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__nullifyDeviceReq(struct soap *soap, const char *tag, int id, struct _ns1__nullifyDeviceReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__nullifyDeviceReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__nullifyDeviceReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__nullifyDeviceReq(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__nullifyDeviceReq **)soap_malloc(soap, sizeof(struct _ns1__nullifyDeviceReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__nullifyDeviceReq *)soap_malloc(soap, sizeof(struct _ns1__nullifyDeviceReq));
		soap_default__ns1__nullifyDeviceReq(soap, *a);
		if (!(*a = soap_in__ns1__nullifyDeviceReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__nullifyDeviceReq, sizeof(struct _ns1__nullifyDeviceReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__nullifyDeviceReq(struct soap *soap, struct _ns1__nullifyDeviceReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__nullifyDeviceReq);
	if (soap_out_PointerTo_ns1__nullifyDeviceReq(soap, tag?tag:"ns1:nullifyDeviceReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__nullifyDeviceReq(struct soap *soap, struct _ns1__nullifyDeviceReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__nullifyDeviceReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addDeviceRes(struct soap *soap, struct _ns1__addDeviceRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addDeviceRes))
		soap_serialize__ns1__addDeviceRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addDeviceRes(struct soap *soap, const char *tag, int id, struct _ns1__addDeviceRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addDeviceRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__addDeviceRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__addDeviceRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__addDeviceRes(struct soap *soap, const char *tag, struct _ns1__addDeviceRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__addDeviceRes **)soap_malloc(soap, sizeof(struct _ns1__addDeviceRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__addDeviceRes *)soap_malloc(soap, sizeof(struct _ns1__addDeviceRes));
		soap_default__ns1__addDeviceRes(soap, *a);
		if (!(*a = soap_in__ns1__addDeviceRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addDeviceRes, sizeof(struct _ns1__addDeviceRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addDeviceRes(struct soap *soap, struct _ns1__addDeviceRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addDeviceRes);
	if (soap_out_PointerTo_ns1__addDeviceRes(soap, tag?tag:"ns1:addDeviceRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__addDeviceRes(struct soap *soap, struct _ns1__addDeviceRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addDeviceRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addDeviceReq(struct soap *soap, struct _ns1__addDeviceReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addDeviceReq))
		soap_serialize__ns1__addDeviceReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addDeviceReq(struct soap *soap, const char *tag, int id, struct _ns1__addDeviceReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addDeviceReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__addDeviceReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__addDeviceReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__addDeviceReq(struct soap *soap, const char *tag, struct _ns1__addDeviceReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__addDeviceReq **)soap_malloc(soap, sizeof(struct _ns1__addDeviceReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__addDeviceReq *)soap_malloc(soap, sizeof(struct _ns1__addDeviceReq));
		soap_default__ns1__addDeviceReq(soap, *a);
		if (!(*a = soap_in__ns1__addDeviceReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addDeviceReq, sizeof(struct _ns1__addDeviceReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addDeviceReq(struct soap *soap, struct _ns1__addDeviceReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addDeviceReq);
	if (soap_out_PointerTo_ns1__addDeviceReq(soap, tag?tag:"ns1:addDeviceReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__addDeviceReq(struct soap *soap, struct _ns1__addDeviceReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addDeviceReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateChannelNameRes(struct soap *soap, struct _ns1__updateChannelNameRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateChannelNameRes))
		soap_serialize__ns1__updateChannelNameRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateChannelNameRes(struct soap *soap, const char *tag, int id, struct _ns1__updateChannelNameRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateChannelNameRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateChannelNameRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateChannelNameRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateChannelNameRes(struct soap *soap, const char *tag, struct _ns1__updateChannelNameRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateChannelNameRes **)soap_malloc(soap, sizeof(struct _ns1__updateChannelNameRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__updateChannelNameRes *)soap_malloc(soap, sizeof(struct _ns1__updateChannelNameRes));
		soap_default__ns1__updateChannelNameRes(soap, *a);
		if (!(*a = soap_in__ns1__updateChannelNameRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateChannelNameRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateChannelNameRes, sizeof(struct _ns1__updateChannelNameRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateChannelNameRes(struct soap *soap, struct _ns1__updateChannelNameRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateChannelNameRes);
	if (soap_out_PointerTo_ns1__updateChannelNameRes(soap, tag?tag:"ns1:updateChannelNameRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateChannelNameRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateChannelNameRes(struct soap *soap, struct _ns1__updateChannelNameRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateChannelNameRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateChannelNameReq(struct soap *soap, struct _ns1__updateChannelNameReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateChannelNameReq))
		soap_serialize__ns1__updateChannelNameReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateChannelNameReq(struct soap *soap, const char *tag, int id, struct _ns1__updateChannelNameReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateChannelNameReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateChannelNameReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateChannelNameReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateChannelNameReq(struct soap *soap, const char *tag, struct _ns1__updateChannelNameReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateChannelNameReq **)soap_malloc(soap, sizeof(struct _ns1__updateChannelNameReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__updateChannelNameReq *)soap_malloc(soap, sizeof(struct _ns1__updateChannelNameReq));
		soap_default__ns1__updateChannelNameReq(soap, *a);
		if (!(*a = soap_in__ns1__updateChannelNameReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateChannelNameReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateChannelNameReq, sizeof(struct _ns1__updateChannelNameReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateChannelNameReq(struct soap *soap, struct _ns1__updateChannelNameReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateChannelNameReq);
	if (soap_out_PointerTo_ns1__updateChannelNameReq(soap, tag?tag:"ns1:updateChannelNameReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateChannelNameReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateChannelNameReq(struct soap *soap, struct _ns1__updateChannelNameReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateChannelNameReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__userLogoutRes(struct soap *soap, struct _ns1__userLogoutRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__userLogoutRes))
		soap_serialize__ns1__userLogoutRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__userLogoutRes(struct soap *soap, const char *tag, int id, struct _ns1__userLogoutRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__userLogoutRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__userLogoutRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__userLogoutRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__userLogoutRes(struct soap *soap, const char *tag, struct _ns1__userLogoutRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__userLogoutRes **)soap_malloc(soap, sizeof(struct _ns1__userLogoutRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__userLogoutRes *)soap_malloc(soap, sizeof(struct _ns1__userLogoutRes));
		soap_default__ns1__userLogoutRes(soap, *a);
		if (!(*a = soap_in__ns1__userLogoutRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLogoutRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__userLogoutRes, sizeof(struct _ns1__userLogoutRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__userLogoutRes(struct soap *soap, struct _ns1__userLogoutRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__userLogoutRes);
	if (soap_out_PointerTo_ns1__userLogoutRes(soap, tag?tag:"ns1:userLogoutRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLogoutRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__userLogoutRes(struct soap *soap, struct _ns1__userLogoutRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__userLogoutRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__userLogoutReq(struct soap *soap, struct _ns1__userLogoutReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__userLogoutReq))
		soap_serialize__ns1__userLogoutReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__userLogoutReq(struct soap *soap, const char *tag, int id, struct _ns1__userLogoutReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__userLogoutReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__userLogoutReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__userLogoutReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__userLogoutReq(struct soap *soap, const char *tag, struct _ns1__userLogoutReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__userLogoutReq **)soap_malloc(soap, sizeof(struct _ns1__userLogoutReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__userLogoutReq *)soap_malloc(soap, sizeof(struct _ns1__userLogoutReq));
		soap_default__ns1__userLogoutReq(soap, *a);
		if (!(*a = soap_in__ns1__userLogoutReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLogoutReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__userLogoutReq, sizeof(struct _ns1__userLogoutReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__userLogoutReq(struct soap *soap, struct _ns1__userLogoutReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__userLogoutReq);
	if (soap_out_PointerTo_ns1__userLogoutReq(soap, tag?tag:"ns1:userLogoutReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLogoutReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__userLogoutReq(struct soap *soap, struct _ns1__userLogoutReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__userLogoutReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__userLoginRes(struct soap *soap, struct ns1__userLoginRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__userLoginRes))
		soap_serialize_ns1__userLoginRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__userLoginRes(struct soap *soap, const char *tag, int id, struct ns1__userLoginRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__userLoginRes);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__userLoginRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__userLoginRes ** SOAP_FMAC4 soap_in_PointerTons1__userLoginRes(struct soap *soap, const char *tag, struct ns1__userLoginRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__userLoginRes **)soap_malloc(soap, sizeof(struct ns1__userLoginRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__userLoginRes *)soap_malloc(soap, sizeof(struct ns1__userLoginRes));
		soap_default_ns1__userLoginRes(soap, *a);
		if (!(*a = soap_in_ns1__userLoginRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__userLoginRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__userLoginRes, sizeof(struct ns1__userLoginRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__userLoginRes(struct soap *soap, struct ns1__userLoginRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__userLoginRes);
	if (soap_out_PointerTons1__userLoginRes(soap, tag?tag:"ns1:userLoginRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__userLoginRes ** SOAP_FMAC4 soap_get_PointerTons1__userLoginRes(struct soap *soap, struct ns1__userLoginRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__userLoginRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__userLoginReq(struct soap *soap, struct ns1__userLoginReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__userLoginReq))
		soap_serialize_ns1__userLoginReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__userLoginReq(struct soap *soap, const char *tag, int id, struct ns1__userLoginReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__userLoginReq);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__userLoginReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__userLoginReq ** SOAP_FMAC4 soap_in_PointerTons1__userLoginReq(struct soap *soap, const char *tag, struct ns1__userLoginReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__userLoginReq **)soap_malloc(soap, sizeof(struct ns1__userLoginReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__userLoginReq *)soap_malloc(soap, sizeof(struct ns1__userLoginReq));
		soap_default_ns1__userLoginReq(soap, *a);
		if (!(*a = soap_in_ns1__userLoginReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__userLoginReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__userLoginReq, sizeof(struct ns1__userLoginReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__userLoginReq(struct soap *soap, struct ns1__userLoginReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__userLoginReq);
	if (soap_out_PointerTons1__userLoginReq(soap, tag?tag:"ns1:userLoginReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__userLoginReq ** SOAP_FMAC4 soap_get_PointerTons1__userLoginReq(struct soap *soap, struct ns1__userLoginReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__userLoginReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDeviceBondedRes(struct soap *soap, struct _ns1__queryDeviceBondedRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDeviceBondedRes))
		soap_serialize__ns1__queryDeviceBondedRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDeviceBondedRes(struct soap *soap, const char *tag, int id, struct _ns1__queryDeviceBondedRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDeviceBondedRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDeviceBondedRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDeviceBondedRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDeviceBondedRes(struct soap *soap, const char *tag, struct _ns1__queryDeviceBondedRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDeviceBondedRes **)soap_malloc(soap, sizeof(struct _ns1__queryDeviceBondedRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryDeviceBondedRes *)soap_malloc(soap, sizeof(struct _ns1__queryDeviceBondedRes));
		soap_default__ns1__queryDeviceBondedRes(soap, *a);
		if (!(*a = soap_in__ns1__queryDeviceBondedRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceBondedRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDeviceBondedRes, sizeof(struct _ns1__queryDeviceBondedRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDeviceBondedRes(struct soap *soap, struct _ns1__queryDeviceBondedRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDeviceBondedRes);
	if (soap_out_PointerTo_ns1__queryDeviceBondedRes(soap, tag?tag:"ns1:queryDeviceBondedRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceBondedRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDeviceBondedRes(struct soap *soap, struct _ns1__queryDeviceBondedRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDeviceBondedRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDeviceBondedReq(struct soap *soap, struct _ns1__queryDeviceBondedReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDeviceBondedReq))
		soap_serialize__ns1__queryDeviceBondedReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDeviceBondedReq(struct soap *soap, const char *tag, int id, struct _ns1__queryDeviceBondedReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDeviceBondedReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDeviceBondedReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDeviceBondedReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDeviceBondedReq(struct soap *soap, const char *tag, struct _ns1__queryDeviceBondedReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDeviceBondedReq **)soap_malloc(soap, sizeof(struct _ns1__queryDeviceBondedReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryDeviceBondedReq *)soap_malloc(soap, sizeof(struct _ns1__queryDeviceBondedReq));
		soap_default__ns1__queryDeviceBondedReq(soap, *a);
		if (!(*a = soap_in__ns1__queryDeviceBondedReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceBondedReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDeviceBondedReq, sizeof(struct _ns1__queryDeviceBondedReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDeviceBondedReq(struct soap *soap, struct _ns1__queryDeviceBondedReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDeviceBondedReq);
	if (soap_out_PointerTo_ns1__queryDeviceBondedReq(soap, tag?tag:"ns1:queryDeviceBondedReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceBondedReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDeviceBondedReq(struct soap *soap, struct _ns1__queryDeviceBondedReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDeviceBondedReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryClientVersionRes(struct soap *soap, struct _ns1__queryClientVersionRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryClientVersionRes))
		soap_serialize__ns1__queryClientVersionRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryClientVersionRes(struct soap *soap, const char *tag, int id, struct _ns1__queryClientVersionRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryClientVersionRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryClientVersionRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryClientVersionRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryClientVersionRes(struct soap *soap, const char *tag, struct _ns1__queryClientVersionRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryClientVersionRes **)soap_malloc(soap, sizeof(struct _ns1__queryClientVersionRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryClientVersionRes *)soap_malloc(soap, sizeof(struct _ns1__queryClientVersionRes));
		soap_default__ns1__queryClientVersionRes(soap, *a);
		if (!(*a = soap_in__ns1__queryClientVersionRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryClientVersionRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryClientVersionRes, sizeof(struct _ns1__queryClientVersionRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryClientVersionRes(struct soap *soap, struct _ns1__queryClientVersionRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryClientVersionRes);
	if (soap_out_PointerTo_ns1__queryClientVersionRes(soap, tag?tag:"ns1:queryClientVersionRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryClientVersionRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryClientVersionRes(struct soap *soap, struct _ns1__queryClientVersionRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryClientVersionRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryClientVersionReq(struct soap *soap, struct _ns1__queryClientVersionReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryClientVersionReq))
		soap_serialize__ns1__queryClientVersionReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryClientVersionReq(struct soap *soap, const char *tag, int id, struct _ns1__queryClientVersionReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryClientVersionReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryClientVersionReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryClientVersionReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryClientVersionReq(struct soap *soap, const char *tag, struct _ns1__queryClientVersionReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryClientVersionReq **)soap_malloc(soap, sizeof(struct _ns1__queryClientVersionReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryClientVersionReq *)soap_malloc(soap, sizeof(struct _ns1__queryClientVersionReq));
		soap_default__ns1__queryClientVersionReq(soap, *a);
		if (!(*a = soap_in__ns1__queryClientVersionReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryClientVersionReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryClientVersionReq, sizeof(struct _ns1__queryClientVersionReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryClientVersionReq(struct soap *soap, struct _ns1__queryClientVersionReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryClientVersionReq);
	if (soap_out_PointerTo_ns1__queryClientVersionReq(soap, tag?tag:"ns1:queryClientVersionReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryClientVersionReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryClientVersionReq(struct soap *soap, struct _ns1__queryClientVersionReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryClientVersionReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryAndroidTokenRes(struct soap *soap, struct _ns1__queryAndroidTokenRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryAndroidTokenRes))
		soap_serialize__ns1__queryAndroidTokenRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryAndroidTokenRes(struct soap *soap, const char *tag, int id, struct _ns1__queryAndroidTokenRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryAndroidTokenRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryAndroidTokenRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryAndroidTokenRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryAndroidTokenRes(struct soap *soap, const char *tag, struct _ns1__queryAndroidTokenRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryAndroidTokenRes **)soap_malloc(soap, sizeof(struct _ns1__queryAndroidTokenRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryAndroidTokenRes *)soap_malloc(soap, sizeof(struct _ns1__queryAndroidTokenRes));
		soap_default__ns1__queryAndroidTokenRes(soap, *a);
		if (!(*a = soap_in__ns1__queryAndroidTokenRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryAndroidTokenRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryAndroidTokenRes, sizeof(struct _ns1__queryAndroidTokenRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryAndroidTokenRes(struct soap *soap, struct _ns1__queryAndroidTokenRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryAndroidTokenRes);
	if (soap_out_PointerTo_ns1__queryAndroidTokenRes(soap, tag?tag:"ns1:queryAndroidTokenRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryAndroidTokenRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryAndroidTokenRes(struct soap *soap, struct _ns1__queryAndroidTokenRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryAndroidTokenRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryAndroidTokenReq(struct soap *soap, struct _ns1__queryAndroidTokenReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryAndroidTokenReq))
		soap_serialize__ns1__queryAndroidTokenReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryAndroidTokenReq(struct soap *soap, const char *tag, int id, struct _ns1__queryAndroidTokenReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryAndroidTokenReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryAndroidTokenReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryAndroidTokenReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryAndroidTokenReq(struct soap *soap, const char *tag, struct _ns1__queryAndroidTokenReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryAndroidTokenReq **)soap_malloc(soap, sizeof(struct _ns1__queryAndroidTokenReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryAndroidTokenReq *)soap_malloc(soap, sizeof(struct _ns1__queryAndroidTokenReq));
		soap_default__ns1__queryAndroidTokenReq(soap, *a);
		if (!(*a = soap_in__ns1__queryAndroidTokenReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryAndroidTokenReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryAndroidTokenReq, sizeof(struct _ns1__queryAndroidTokenReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryAndroidTokenReq(struct soap *soap, struct _ns1__queryAndroidTokenReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryAndroidTokenReq);
	if (soap_out_PointerTo_ns1__queryAndroidTokenReq(soap, tag?tag:"ns1:queryAndroidTokenReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryAndroidTokenReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryAndroidTokenReq(struct soap *soap, struct _ns1__queryAndroidTokenReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryAndroidTokenReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryAppleTokenRes(struct soap *soap, struct _ns1__queryAppleTokenRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryAppleTokenRes))
		soap_serialize__ns1__queryAppleTokenRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryAppleTokenRes(struct soap *soap, const char *tag, int id, struct _ns1__queryAppleTokenRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryAppleTokenRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryAppleTokenRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryAppleTokenRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryAppleTokenRes(struct soap *soap, const char *tag, struct _ns1__queryAppleTokenRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryAppleTokenRes **)soap_malloc(soap, sizeof(struct _ns1__queryAppleTokenRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryAppleTokenRes *)soap_malloc(soap, sizeof(struct _ns1__queryAppleTokenRes));
		soap_default__ns1__queryAppleTokenRes(soap, *a);
		if (!(*a = soap_in__ns1__queryAppleTokenRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryAppleTokenRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryAppleTokenRes, sizeof(struct _ns1__queryAppleTokenRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryAppleTokenRes(struct soap *soap, struct _ns1__queryAppleTokenRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryAppleTokenRes);
	if (soap_out_PointerTo_ns1__queryAppleTokenRes(soap, tag?tag:"ns1:queryAppleTokenRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryAppleTokenRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryAppleTokenRes(struct soap *soap, struct _ns1__queryAppleTokenRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryAppleTokenRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryAppleTokenReq(struct soap *soap, struct _ns1__queryAppleTokenReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryAppleTokenReq))
		soap_serialize__ns1__queryAppleTokenReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryAppleTokenReq(struct soap *soap, const char *tag, int id, struct _ns1__queryAppleTokenReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryAppleTokenReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryAppleTokenReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryAppleTokenReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryAppleTokenReq(struct soap *soap, const char *tag, struct _ns1__queryAppleTokenReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryAppleTokenReq **)soap_malloc(soap, sizeof(struct _ns1__queryAppleTokenReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryAppleTokenReq *)soap_malloc(soap, sizeof(struct _ns1__queryAppleTokenReq));
		soap_default__ns1__queryAppleTokenReq(soap, *a);
		if (!(*a = soap_in__ns1__queryAppleTokenReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryAppleTokenReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryAppleTokenReq, sizeof(struct _ns1__queryAppleTokenReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryAppleTokenReq(struct soap *soap, struct _ns1__queryAppleTokenReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryAppleTokenReq);
	if (soap_out_PointerTo_ns1__queryAppleTokenReq(soap, tag?tag:"ns1:queryAppleTokenReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryAppleTokenReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryAppleTokenReq(struct soap *soap, struct _ns1__queryAppleTokenReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryAppleTokenReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDeviceSharingSourceRes(struct soap *soap, struct _ns1__queryDeviceSharingSourceRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDeviceSharingSourceRes))
		soap_serialize__ns1__queryDeviceSharingSourceRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDeviceSharingSourceRes(struct soap *soap, const char *tag, int id, struct _ns1__queryDeviceSharingSourceRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDeviceSharingSourceRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDeviceSharingSourceRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharingSourceRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDeviceSharingSourceRes(struct soap *soap, const char *tag, struct _ns1__queryDeviceSharingSourceRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDeviceSharingSourceRes **)soap_malloc(soap, sizeof(struct _ns1__queryDeviceSharingSourceRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryDeviceSharingSourceRes *)soap_malloc(soap, sizeof(struct _ns1__queryDeviceSharingSourceRes));
		soap_default__ns1__queryDeviceSharingSourceRes(soap, *a);
		if (!(*a = soap_in__ns1__queryDeviceSharingSourceRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceSharingSourceRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDeviceSharingSourceRes, sizeof(struct _ns1__queryDeviceSharingSourceRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDeviceSharingSourceRes(struct soap *soap, struct _ns1__queryDeviceSharingSourceRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDeviceSharingSourceRes);
	if (soap_out_PointerTo_ns1__queryDeviceSharingSourceRes(soap, tag?tag:"ns1:queryDeviceSharingSourceRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharingSourceRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDeviceSharingSourceRes(struct soap *soap, struct _ns1__queryDeviceSharingSourceRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDeviceSharingSourceRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDeviceSharingSourceReq(struct soap *soap, struct _ns1__queryDeviceSharingSourceReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDeviceSharingSourceReq))
		soap_serialize__ns1__queryDeviceSharingSourceReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDeviceSharingSourceReq(struct soap *soap, const char *tag, int id, struct _ns1__queryDeviceSharingSourceReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDeviceSharingSourceReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDeviceSharingSourceReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharingSourceReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDeviceSharingSourceReq(struct soap *soap, const char *tag, struct _ns1__queryDeviceSharingSourceReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDeviceSharingSourceReq **)soap_malloc(soap, sizeof(struct _ns1__queryDeviceSharingSourceReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryDeviceSharingSourceReq *)soap_malloc(soap, sizeof(struct _ns1__queryDeviceSharingSourceReq));
		soap_default__ns1__queryDeviceSharingSourceReq(soap, *a);
		if (!(*a = soap_in__ns1__queryDeviceSharingSourceReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceSharingSourceReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDeviceSharingSourceReq, sizeof(struct _ns1__queryDeviceSharingSourceReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDeviceSharingSourceReq(struct soap *soap, struct _ns1__queryDeviceSharingSourceReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDeviceSharingSourceReq);
	if (soap_out_PointerTo_ns1__queryDeviceSharingSourceReq(soap, tag?tag:"ns1:queryDeviceSharingSourceReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharingSourceReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDeviceSharingSourceReq(struct soap *soap, struct _ns1__queryDeviceSharingSourceReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDeviceSharingSourceReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDeviceSharerRes(struct soap *soap, struct _ns1__queryDeviceSharerRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDeviceSharerRes))
		soap_serialize__ns1__queryDeviceSharerRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDeviceSharerRes(struct soap *soap, const char *tag, int id, struct _ns1__queryDeviceSharerRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDeviceSharerRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDeviceSharerRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharerRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDeviceSharerRes(struct soap *soap, const char *tag, struct _ns1__queryDeviceSharerRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDeviceSharerRes **)soap_malloc(soap, sizeof(struct _ns1__queryDeviceSharerRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryDeviceSharerRes *)soap_malloc(soap, sizeof(struct _ns1__queryDeviceSharerRes));
		soap_default__ns1__queryDeviceSharerRes(soap, *a);
		if (!(*a = soap_in__ns1__queryDeviceSharerRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceSharerRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDeviceSharerRes, sizeof(struct _ns1__queryDeviceSharerRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDeviceSharerRes(struct soap *soap, struct _ns1__queryDeviceSharerRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDeviceSharerRes);
	if (soap_out_PointerTo_ns1__queryDeviceSharerRes(soap, tag?tag:"ns1:queryDeviceSharerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharerRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDeviceSharerRes(struct soap *soap, struct _ns1__queryDeviceSharerRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDeviceSharerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDeviceSharerReq(struct soap *soap, struct _ns1__queryDeviceSharerReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDeviceSharerReq))
		soap_serialize__ns1__queryDeviceSharerReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDeviceSharerReq(struct soap *soap, const char *tag, int id, struct _ns1__queryDeviceSharerReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDeviceSharerReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDeviceSharerReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharerReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDeviceSharerReq(struct soap *soap, const char *tag, struct _ns1__queryDeviceSharerReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDeviceSharerReq **)soap_malloc(soap, sizeof(struct _ns1__queryDeviceSharerReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryDeviceSharerReq *)soap_malloc(soap, sizeof(struct _ns1__queryDeviceSharerReq));
		soap_default__ns1__queryDeviceSharerReq(soap, *a);
		if (!(*a = soap_in__ns1__queryDeviceSharerReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceSharerReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDeviceSharerReq, sizeof(struct _ns1__queryDeviceSharerReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDeviceSharerReq(struct soap *soap, struct _ns1__queryDeviceSharerReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDeviceSharerReq);
	if (soap_out_PointerTo_ns1__queryDeviceSharerReq(soap, tag?tag:"ns1:queryDeviceSharerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceSharerReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDeviceSharerReq(struct soap *soap, struct _ns1__queryDeviceSharerReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDeviceSharerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__nullifyDeviceSharerRes(struct soap *soap, struct _ns1__nullifyDeviceSharerRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__nullifyDeviceSharerRes))
		soap_serialize__ns1__nullifyDeviceSharerRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__nullifyDeviceSharerRes(struct soap *soap, const char *tag, int id, struct _ns1__nullifyDeviceSharerRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__nullifyDeviceSharerRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__nullifyDeviceSharerRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceSharerRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__nullifyDeviceSharerRes(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceSharerRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__nullifyDeviceSharerRes **)soap_malloc(soap, sizeof(struct _ns1__nullifyDeviceSharerRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__nullifyDeviceSharerRes *)soap_malloc(soap, sizeof(struct _ns1__nullifyDeviceSharerRes));
		soap_default__ns1__nullifyDeviceSharerRes(soap, *a);
		if (!(*a = soap_in__ns1__nullifyDeviceSharerRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceSharerRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__nullifyDeviceSharerRes, sizeof(struct _ns1__nullifyDeviceSharerRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__nullifyDeviceSharerRes(struct soap *soap, struct _ns1__nullifyDeviceSharerRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__nullifyDeviceSharerRes);
	if (soap_out_PointerTo_ns1__nullifyDeviceSharerRes(soap, tag?tag:"ns1:nullifyDeviceSharerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceSharerRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__nullifyDeviceSharerRes(struct soap *soap, struct _ns1__nullifyDeviceSharerRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__nullifyDeviceSharerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__nullifyDeviceSharerReq(struct soap *soap, struct _ns1__nullifyDeviceSharerReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__nullifyDeviceSharerReq))
		soap_serialize__ns1__nullifyDeviceSharerReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__nullifyDeviceSharerReq(struct soap *soap, const char *tag, int id, struct _ns1__nullifyDeviceSharerReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__nullifyDeviceSharerReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__nullifyDeviceSharerReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceSharerReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__nullifyDeviceSharerReq(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceSharerReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__nullifyDeviceSharerReq **)soap_malloc(soap, sizeof(struct _ns1__nullifyDeviceSharerReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__nullifyDeviceSharerReq *)soap_malloc(soap, sizeof(struct _ns1__nullifyDeviceSharerReq));
		soap_default__ns1__nullifyDeviceSharerReq(soap, *a);
		if (!(*a = soap_in__ns1__nullifyDeviceSharerReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceSharerReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__nullifyDeviceSharerReq, sizeof(struct _ns1__nullifyDeviceSharerReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__nullifyDeviceSharerReq(struct soap *soap, struct _ns1__nullifyDeviceSharerReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__nullifyDeviceSharerReq);
	if (soap_out_PointerTo_ns1__nullifyDeviceSharerReq(soap, tag?tag:"ns1:nullifyDeviceSharerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceSharerReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__nullifyDeviceSharerReq(struct soap *soap, struct _ns1__nullifyDeviceSharerReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__nullifyDeviceSharerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addDeviceSharerRes(struct soap *soap, struct _ns1__addDeviceSharerRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addDeviceSharerRes))
		soap_serialize__ns1__addDeviceSharerRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addDeviceSharerRes(struct soap *soap, const char *tag, int id, struct _ns1__addDeviceSharerRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addDeviceSharerRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__addDeviceSharerRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__addDeviceSharerRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__addDeviceSharerRes(struct soap *soap, const char *tag, struct _ns1__addDeviceSharerRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__addDeviceSharerRes **)soap_malloc(soap, sizeof(struct _ns1__addDeviceSharerRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__addDeviceSharerRes *)soap_malloc(soap, sizeof(struct _ns1__addDeviceSharerRes));
		soap_default__ns1__addDeviceSharerRes(soap, *a);
		if (!(*a = soap_in__ns1__addDeviceSharerRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceSharerRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addDeviceSharerRes, sizeof(struct _ns1__addDeviceSharerRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addDeviceSharerRes(struct soap *soap, struct _ns1__addDeviceSharerRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addDeviceSharerRes);
	if (soap_out_PointerTo_ns1__addDeviceSharerRes(soap, tag?tag:"ns1:addDeviceSharerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceSharerRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__addDeviceSharerRes(struct soap *soap, struct _ns1__addDeviceSharerRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addDeviceSharerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addDeviceSharerReq(struct soap *soap, struct _ns1__addDeviceSharerReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addDeviceSharerReq))
		soap_serialize__ns1__addDeviceSharerReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addDeviceSharerReq(struct soap *soap, const char *tag, int id, struct _ns1__addDeviceSharerReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addDeviceSharerReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__addDeviceSharerReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__addDeviceSharerReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__addDeviceSharerReq(struct soap *soap, const char *tag, struct _ns1__addDeviceSharerReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__addDeviceSharerReq **)soap_malloc(soap, sizeof(struct _ns1__addDeviceSharerReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__addDeviceSharerReq *)soap_malloc(soap, sizeof(struct _ns1__addDeviceSharerReq));
		soap_default__ns1__addDeviceSharerReq(soap, *a);
		if (!(*a = soap_in__ns1__addDeviceSharerReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceSharerReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addDeviceSharerReq, sizeof(struct _ns1__addDeviceSharerReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addDeviceSharerReq(struct soap *soap, struct _ns1__addDeviceSharerReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addDeviceSharerReq);
	if (soap_out_PointerTo_ns1__addDeviceSharerReq(soap, tag?tag:"ns1:addDeviceSharerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceSharerReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__addDeviceSharerReq(struct soap *soap, struct _ns1__addDeviceSharerReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addDeviceSharerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDeviceStatusRes(struct soap *soap, struct _ns1__queryDeviceStatusRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDeviceStatusRes))
		soap_serialize__ns1__queryDeviceStatusRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDeviceStatusRes(struct soap *soap, const char *tag, int id, struct _ns1__queryDeviceStatusRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDeviceStatusRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDeviceStatusRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDeviceStatusRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDeviceStatusRes(struct soap *soap, const char *tag, struct _ns1__queryDeviceStatusRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDeviceStatusRes **)soap_malloc(soap, sizeof(struct _ns1__queryDeviceStatusRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryDeviceStatusRes *)soap_malloc(soap, sizeof(struct _ns1__queryDeviceStatusRes));
		soap_default__ns1__queryDeviceStatusRes(soap, *a);
		if (!(*a = soap_in__ns1__queryDeviceStatusRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceStatusRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDeviceStatusRes, sizeof(struct _ns1__queryDeviceStatusRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDeviceStatusRes(struct soap *soap, struct _ns1__queryDeviceStatusRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDeviceStatusRes);
	if (soap_out_PointerTo_ns1__queryDeviceStatusRes(soap, tag?tag:"ns1:queryDeviceStatusRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceStatusRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDeviceStatusRes(struct soap *soap, struct _ns1__queryDeviceStatusRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDeviceStatusRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDeviceStatusReq(struct soap *soap, struct _ns1__queryDeviceStatusReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDeviceStatusReq))
		soap_serialize__ns1__queryDeviceStatusReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDeviceStatusReq(struct soap *soap, const char *tag, int id, struct _ns1__queryDeviceStatusReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDeviceStatusReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDeviceStatusReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDeviceStatusReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDeviceStatusReq(struct soap *soap, const char *tag, struct _ns1__queryDeviceStatusReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDeviceStatusReq **)soap_malloc(soap, sizeof(struct _ns1__queryDeviceStatusReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryDeviceStatusReq *)soap_malloc(soap, sizeof(struct _ns1__queryDeviceStatusReq));
		soap_default__ns1__queryDeviceStatusReq(soap, *a);
		if (!(*a = soap_in__ns1__queryDeviceStatusReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceStatusReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDeviceStatusReq, sizeof(struct _ns1__queryDeviceStatusReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDeviceStatusReq(struct soap *soap, struct _ns1__queryDeviceStatusReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDeviceStatusReq);
	if (soap_out_PointerTo_ns1__queryDeviceStatusReq(soap, tag?tag:"ns1:queryDeviceStatusReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceStatusReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDeviceStatusReq(struct soap *soap, struct _ns1__queryDeviceStatusReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDeviceStatusReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAndroidTokenRes(struct soap *soap, struct _ns1__updateAndroidTokenRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAndroidTokenRes))
		soap_serialize__ns1__updateAndroidTokenRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAndroidTokenRes(struct soap *soap, const char *tag, int id, struct _ns1__updateAndroidTokenRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAndroidTokenRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAndroidTokenRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAndroidTokenRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAndroidTokenRes(struct soap *soap, const char *tag, struct _ns1__updateAndroidTokenRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAndroidTokenRes **)soap_malloc(soap, sizeof(struct _ns1__updateAndroidTokenRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__updateAndroidTokenRes *)soap_malloc(soap, sizeof(struct _ns1__updateAndroidTokenRes));
		soap_default__ns1__updateAndroidTokenRes(soap, *a);
		if (!(*a = soap_in__ns1__updateAndroidTokenRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAndroidTokenRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAndroidTokenRes, sizeof(struct _ns1__updateAndroidTokenRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAndroidTokenRes(struct soap *soap, struct _ns1__updateAndroidTokenRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAndroidTokenRes);
	if (soap_out_PointerTo_ns1__updateAndroidTokenRes(soap, tag?tag:"ns1:updateAndroidTokenRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAndroidTokenRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAndroidTokenRes(struct soap *soap, struct _ns1__updateAndroidTokenRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAndroidTokenRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAndroidTokenReq(struct soap *soap, struct _ns1__updateAndroidTokenReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAndroidTokenReq))
		soap_serialize__ns1__updateAndroidTokenReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAndroidTokenReq(struct soap *soap, const char *tag, int id, struct _ns1__updateAndroidTokenReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAndroidTokenReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAndroidTokenReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAndroidTokenReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAndroidTokenReq(struct soap *soap, const char *tag, struct _ns1__updateAndroidTokenReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAndroidTokenReq **)soap_malloc(soap, sizeof(struct _ns1__updateAndroidTokenReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__updateAndroidTokenReq *)soap_malloc(soap, sizeof(struct _ns1__updateAndroidTokenReq));
		soap_default__ns1__updateAndroidTokenReq(soap, *a);
		if (!(*a = soap_in__ns1__updateAndroidTokenReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAndroidTokenReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAndroidTokenReq, sizeof(struct _ns1__updateAndroidTokenReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAndroidTokenReq(struct soap *soap, struct _ns1__updateAndroidTokenReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAndroidTokenReq);
	if (soap_out_PointerTo_ns1__updateAndroidTokenReq(soap, tag?tag:"ns1:updateAndroidTokenReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAndroidTokenReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAndroidTokenReq(struct soap *soap, struct _ns1__updateAndroidTokenReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAndroidTokenReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryPUEventLogRes(struct soap *soap, struct _ns1__queryPUEventLogRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryPUEventLogRes))
		soap_serialize__ns1__queryPUEventLogRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryPUEventLogRes(struct soap *soap, const char *tag, int id, struct _ns1__queryPUEventLogRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryPUEventLogRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryPUEventLogRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryPUEventLogRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryPUEventLogRes(struct soap *soap, const char *tag, struct _ns1__queryPUEventLogRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryPUEventLogRes **)soap_malloc(soap, sizeof(struct _ns1__queryPUEventLogRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryPUEventLogRes *)soap_malloc(soap, sizeof(struct _ns1__queryPUEventLogRes));
		soap_default__ns1__queryPUEventLogRes(soap, *a);
		if (!(*a = soap_in__ns1__queryPUEventLogRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryPUEventLogRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryPUEventLogRes, sizeof(struct _ns1__queryPUEventLogRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryPUEventLogRes(struct soap *soap, struct _ns1__queryPUEventLogRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryPUEventLogRes);
	if (soap_out_PointerTo_ns1__queryPUEventLogRes(soap, tag?tag:"ns1:queryPUEventLogRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryPUEventLogRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryPUEventLogRes(struct soap *soap, struct _ns1__queryPUEventLogRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryPUEventLogRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryPUEventLogReq(struct soap *soap, struct _ns1__queryPUEventLogReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryPUEventLogReq))
		soap_serialize__ns1__queryPUEventLogReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryPUEventLogReq(struct soap *soap, const char *tag, int id, struct _ns1__queryPUEventLogReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryPUEventLogReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryPUEventLogReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryPUEventLogReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryPUEventLogReq(struct soap *soap, const char *tag, struct _ns1__queryPUEventLogReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryPUEventLogReq **)soap_malloc(soap, sizeof(struct _ns1__queryPUEventLogReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryPUEventLogReq *)soap_malloc(soap, sizeof(struct _ns1__queryPUEventLogReq));
		soap_default__ns1__queryPUEventLogReq(soap, *a);
		if (!(*a = soap_in__ns1__queryPUEventLogReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryPUEventLogReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryPUEventLogReq, sizeof(struct _ns1__queryPUEventLogReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryPUEventLogReq(struct soap *soap, struct _ns1__queryPUEventLogReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryPUEventLogReq);
	if (soap_out_PointerTo_ns1__queryPUEventLogReq(soap, tag?tag:"ns1:queryPUEventLogReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryPUEventLogReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryPUEventLogReq(struct soap *soap, struct _ns1__queryPUEventLogReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryPUEventLogReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryPUOnOffLogRes(struct soap *soap, struct _ns1__queryPUOnOffLogRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryPUOnOffLogRes))
		soap_serialize__ns1__queryPUOnOffLogRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryPUOnOffLogRes(struct soap *soap, const char *tag, int id, struct _ns1__queryPUOnOffLogRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryPUOnOffLogRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryPUOnOffLogRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryPUOnOffLogRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryPUOnOffLogRes(struct soap *soap, const char *tag, struct _ns1__queryPUOnOffLogRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryPUOnOffLogRes **)soap_malloc(soap, sizeof(struct _ns1__queryPUOnOffLogRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryPUOnOffLogRes *)soap_malloc(soap, sizeof(struct _ns1__queryPUOnOffLogRes));
		soap_default__ns1__queryPUOnOffLogRes(soap, *a);
		if (!(*a = soap_in__ns1__queryPUOnOffLogRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryPUOnOffLogRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryPUOnOffLogRes, sizeof(struct _ns1__queryPUOnOffLogRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryPUOnOffLogRes(struct soap *soap, struct _ns1__queryPUOnOffLogRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryPUOnOffLogRes);
	if (soap_out_PointerTo_ns1__queryPUOnOffLogRes(soap, tag?tag:"ns1:queryPUOnOffLogRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryPUOnOffLogRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryPUOnOffLogRes(struct soap *soap, struct _ns1__queryPUOnOffLogRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryPUOnOffLogRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryPUOnOffLogReq(struct soap *soap, struct _ns1__queryPUOnOffLogReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryPUOnOffLogReq))
		soap_serialize__ns1__queryPUOnOffLogReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryPUOnOffLogReq(struct soap *soap, const char *tag, int id, struct _ns1__queryPUOnOffLogReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryPUOnOffLogReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryPUOnOffLogReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryPUOnOffLogReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryPUOnOffLogReq(struct soap *soap, const char *tag, struct _ns1__queryPUOnOffLogReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryPUOnOffLogReq **)soap_malloc(soap, sizeof(struct _ns1__queryPUOnOffLogReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryPUOnOffLogReq *)soap_malloc(soap, sizeof(struct _ns1__queryPUOnOffLogReq));
		soap_default__ns1__queryPUOnOffLogReq(soap, *a);
		if (!(*a = soap_in__ns1__queryPUOnOffLogReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryPUOnOffLogReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryPUOnOffLogReq, sizeof(struct _ns1__queryPUOnOffLogReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryPUOnOffLogReq(struct soap *soap, struct _ns1__queryPUOnOffLogReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryPUOnOffLogReq);
	if (soap_out_PointerTo_ns1__queryPUOnOffLogReq(soap, tag?tag:"ns1:queryPUOnOffLogReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryPUOnOffLogReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryPUOnOffLogReq(struct soap *soap, struct _ns1__queryPUOnOffLogReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryPUOnOffLogReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__inviteKeepAliveRes(struct soap *soap, struct _ns1__inviteKeepAliveRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__inviteKeepAliveRes))
		soap_serialize__ns1__inviteKeepAliveRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__inviteKeepAliveRes(struct soap *soap, const char *tag, int id, struct _ns1__inviteKeepAliveRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__inviteKeepAliveRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__inviteKeepAliveRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__inviteKeepAliveRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__inviteKeepAliveRes(struct soap *soap, const char *tag, struct _ns1__inviteKeepAliveRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__inviteKeepAliveRes **)soap_malloc(soap, sizeof(struct _ns1__inviteKeepAliveRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__inviteKeepAliveRes *)soap_malloc(soap, sizeof(struct _ns1__inviteKeepAliveRes));
		soap_default__ns1__inviteKeepAliveRes(soap, *a);
		if (!(*a = soap_in__ns1__inviteKeepAliveRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__inviteKeepAliveRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__inviteKeepAliveRes, sizeof(struct _ns1__inviteKeepAliveRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__inviteKeepAliveRes(struct soap *soap, struct _ns1__inviteKeepAliveRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__inviteKeepAliveRes);
	if (soap_out_PointerTo_ns1__inviteKeepAliveRes(soap, tag?tag:"ns1:inviteKeepAliveRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__inviteKeepAliveRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__inviteKeepAliveRes(struct soap *soap, struct _ns1__inviteKeepAliveRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__inviteKeepAliveRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__inviteKeepAliveReq(struct soap *soap, struct _ns1__inviteKeepAliveReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__inviteKeepAliveReq))
		soap_serialize__ns1__inviteKeepAliveReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__inviteKeepAliveReq(struct soap *soap, const char *tag, int id, struct _ns1__inviteKeepAliveReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__inviteKeepAliveReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__inviteKeepAliveReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__inviteKeepAliveReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__inviteKeepAliveReq(struct soap *soap, const char *tag, struct _ns1__inviteKeepAliveReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__inviteKeepAliveReq **)soap_malloc(soap, sizeof(struct _ns1__inviteKeepAliveReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__inviteKeepAliveReq *)soap_malloc(soap, sizeof(struct _ns1__inviteKeepAliveReq));
		soap_default__ns1__inviteKeepAliveReq(soap, *a);
		if (!(*a = soap_in__ns1__inviteKeepAliveReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__inviteKeepAliveReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__inviteKeepAliveReq, sizeof(struct _ns1__inviteKeepAliveReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__inviteKeepAliveReq(struct soap *soap, struct _ns1__inviteKeepAliveReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__inviteKeepAliveReq);
	if (soap_out_PointerTo_ns1__inviteKeepAliveReq(soap, tag?tag:"ns1:inviteKeepAliveReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__inviteKeepAliveReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__inviteKeepAliveReq(struct soap *soap, struct _ns1__inviteKeepAliveReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__inviteKeepAliveReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__notifyNATResultRes(struct soap *soap, struct _ns1__notifyNATResultRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__notifyNATResultRes))
		soap_serialize__ns1__notifyNATResultRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__notifyNATResultRes(struct soap *soap, const char *tag, int id, struct _ns1__notifyNATResultRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__notifyNATResultRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__notifyNATResultRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__notifyNATResultRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__notifyNATResultRes(struct soap *soap, const char *tag, struct _ns1__notifyNATResultRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__notifyNATResultRes **)soap_malloc(soap, sizeof(struct _ns1__notifyNATResultRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__notifyNATResultRes *)soap_malloc(soap, sizeof(struct _ns1__notifyNATResultRes));
		soap_default__ns1__notifyNATResultRes(soap, *a);
		if (!(*a = soap_in__ns1__notifyNATResultRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__notifyNATResultRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__notifyNATResultRes, sizeof(struct _ns1__notifyNATResultRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__notifyNATResultRes(struct soap *soap, struct _ns1__notifyNATResultRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__notifyNATResultRes);
	if (soap_out_PointerTo_ns1__notifyNATResultRes(soap, tag?tag:"ns1:notifyNATResultRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__notifyNATResultRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__notifyNATResultRes(struct soap *soap, struct _ns1__notifyNATResultRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__notifyNATResultRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__notifyNATResultReq(struct soap *soap, struct _ns1__notifyNATResultReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__notifyNATResultReq))
		soap_serialize__ns1__notifyNATResultReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__notifyNATResultReq(struct soap *soap, const char *tag, int id, struct _ns1__notifyNATResultReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__notifyNATResultReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__notifyNATResultReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__notifyNATResultReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__notifyNATResultReq(struct soap *soap, const char *tag, struct _ns1__notifyNATResultReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__notifyNATResultReq **)soap_malloc(soap, sizeof(struct _ns1__notifyNATResultReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__notifyNATResultReq *)soap_malloc(soap, sizeof(struct _ns1__notifyNATResultReq));
		soap_default__ns1__notifyNATResultReq(soap, *a);
		if (!(*a = soap_in__ns1__notifyNATResultReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__notifyNATResultReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__notifyNATResultReq, sizeof(struct _ns1__notifyNATResultReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__notifyNATResultReq(struct soap *soap, struct _ns1__notifyNATResultReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__notifyNATResultReq);
	if (soap_out_PointerTo_ns1__notifyNATResultReq(soap, tag?tag:"ns1:notifyNATResultReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__notifyNATResultReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__notifyNATResultReq(struct soap *soap, struct _ns1__notifyNATResultReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__notifyNATResultReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__subscribeEMailRes(struct soap *soap, struct _ns1__subscribeEMailRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__subscribeEMailRes))
		soap_serialize__ns1__subscribeEMailRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__subscribeEMailRes(struct soap *soap, const char *tag, int id, struct _ns1__subscribeEMailRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__subscribeEMailRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__subscribeEMailRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__subscribeEMailRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__subscribeEMailRes(struct soap *soap, const char *tag, struct _ns1__subscribeEMailRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__subscribeEMailRes **)soap_malloc(soap, sizeof(struct _ns1__subscribeEMailRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__subscribeEMailRes *)soap_malloc(soap, sizeof(struct _ns1__subscribeEMailRes));
		soap_default__ns1__subscribeEMailRes(soap, *a);
		if (!(*a = soap_in__ns1__subscribeEMailRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeEMailRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__subscribeEMailRes, sizeof(struct _ns1__subscribeEMailRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__subscribeEMailRes(struct soap *soap, struct _ns1__subscribeEMailRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__subscribeEMailRes);
	if (soap_out_PointerTo_ns1__subscribeEMailRes(soap, tag?tag:"ns1:subscribeEMailRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeEMailRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__subscribeEMailRes(struct soap *soap, struct _ns1__subscribeEMailRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__subscribeEMailRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__subscribeEMailReq(struct soap *soap, struct _ns1__subscribeEMailReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__subscribeEMailReq))
		soap_serialize__ns1__subscribeEMailReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__subscribeEMailReq(struct soap *soap, const char *tag, int id, struct _ns1__subscribeEMailReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__subscribeEMailReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__subscribeEMailReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__subscribeEMailReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__subscribeEMailReq(struct soap *soap, const char *tag, struct _ns1__subscribeEMailReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__subscribeEMailReq **)soap_malloc(soap, sizeof(struct _ns1__subscribeEMailReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__subscribeEMailReq *)soap_malloc(soap, sizeof(struct _ns1__subscribeEMailReq));
		soap_default__ns1__subscribeEMailReq(soap, *a);
		if (!(*a = soap_in__ns1__subscribeEMailReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeEMailReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__subscribeEMailReq, sizeof(struct _ns1__subscribeEMailReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__subscribeEMailReq(struct soap *soap, struct _ns1__subscribeEMailReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__subscribeEMailReq);
	if (soap_out_PointerTo_ns1__subscribeEMailReq(soap, tag?tag:"ns1:subscribeEMailReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeEMailReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__subscribeEMailReq(struct soap *soap, struct _ns1__subscribeEMailReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__subscribeEMailReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__subscribeSMSRes(struct soap *soap, struct _ns1__subscribeSMSRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__subscribeSMSRes))
		soap_serialize__ns1__subscribeSMSRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__subscribeSMSRes(struct soap *soap, const char *tag, int id, struct _ns1__subscribeSMSRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__subscribeSMSRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__subscribeSMSRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__subscribeSMSRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__subscribeSMSRes(struct soap *soap, const char *tag, struct _ns1__subscribeSMSRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__subscribeSMSRes **)soap_malloc(soap, sizeof(struct _ns1__subscribeSMSRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__subscribeSMSRes *)soap_malloc(soap, sizeof(struct _ns1__subscribeSMSRes));
		soap_default__ns1__subscribeSMSRes(soap, *a);
		if (!(*a = soap_in__ns1__subscribeSMSRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeSMSRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__subscribeSMSRes, sizeof(struct _ns1__subscribeSMSRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__subscribeSMSRes(struct soap *soap, struct _ns1__subscribeSMSRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__subscribeSMSRes);
	if (soap_out_PointerTo_ns1__subscribeSMSRes(soap, tag?tag:"ns1:subscribeSMSRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeSMSRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__subscribeSMSRes(struct soap *soap, struct _ns1__subscribeSMSRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__subscribeSMSRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__subscribeSMSReq(struct soap *soap, struct _ns1__subscribeSMSReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__subscribeSMSReq))
		soap_serialize__ns1__subscribeSMSReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__subscribeSMSReq(struct soap *soap, const char *tag, int id, struct _ns1__subscribeSMSReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__subscribeSMSReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__subscribeSMSReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__subscribeSMSReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__subscribeSMSReq(struct soap *soap, const char *tag, struct _ns1__subscribeSMSReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__subscribeSMSReq **)soap_malloc(soap, sizeof(struct _ns1__subscribeSMSReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__subscribeSMSReq *)soap_malloc(soap, sizeof(struct _ns1__subscribeSMSReq));
		soap_default__ns1__subscribeSMSReq(soap, *a);
		if (!(*a = soap_in__ns1__subscribeSMSReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeSMSReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__subscribeSMSReq, sizeof(struct _ns1__subscribeSMSReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__subscribeSMSReq(struct soap *soap, struct _ns1__subscribeSMSReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__subscribeSMSReq);
	if (soap_out_PointerTo_ns1__subscribeSMSReq(soap, tag?tag:"ns1:subscribeSMSReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeSMSReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__subscribeSMSReq(struct soap *soap, struct _ns1__subscribeSMSReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__subscribeSMSReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getNATServerRes(struct soap *soap, struct _ns1__getNATServerRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getNATServerRes))
		soap_serialize__ns1__getNATServerRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getNATServerRes(struct soap *soap, const char *tag, int id, struct _ns1__getNATServerRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getNATServerRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getNATServerRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getNATServerRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getNATServerRes(struct soap *soap, const char *tag, struct _ns1__getNATServerRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getNATServerRes **)soap_malloc(soap, sizeof(struct _ns1__getNATServerRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getNATServerRes *)soap_malloc(soap, sizeof(struct _ns1__getNATServerRes));
		soap_default__ns1__getNATServerRes(soap, *a);
		if (!(*a = soap_in__ns1__getNATServerRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getNATServerRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getNATServerRes, sizeof(struct _ns1__getNATServerRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getNATServerRes(struct soap *soap, struct _ns1__getNATServerRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getNATServerRes);
	if (soap_out_PointerTo_ns1__getNATServerRes(soap, tag?tag:"ns1:getNATServerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getNATServerRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getNATServerRes(struct soap *soap, struct _ns1__getNATServerRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getNATServerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getNATServerReq(struct soap *soap, struct _ns1__getNATServerReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getNATServerReq))
		soap_serialize__ns1__getNATServerReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getNATServerReq(struct soap *soap, const char *tag, int id, struct _ns1__getNATServerReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getNATServerReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getNATServerReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getNATServerReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getNATServerReq(struct soap *soap, const char *tag, struct _ns1__getNATServerReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getNATServerReq **)soap_malloc(soap, sizeof(struct _ns1__getNATServerReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getNATServerReq *)soap_malloc(soap, sizeof(struct _ns1__getNATServerReq));
		soap_default__ns1__getNATServerReq(soap, *a);
		if (!(*a = soap_in__ns1__getNATServerReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getNATServerReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getNATServerReq, sizeof(struct _ns1__getNATServerReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getNATServerReq(struct soap *soap, struct _ns1__getNATServerReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getNATServerReq);
	if (soap_out_PointerTo_ns1__getNATServerReq(soap, tag?tag:"ns1:getNATServerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getNATServerReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getNATServerReq(struct soap *soap, struct _ns1__getNATServerReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getNATServerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__byeRes(struct soap *soap, struct _ns1__byeRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__byeRes))
		soap_serialize__ns1__byeRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__byeRes(struct soap *soap, const char *tag, int id, struct _ns1__byeRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__byeRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__byeRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__byeRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__byeRes(struct soap *soap, const char *tag, struct _ns1__byeRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__byeRes **)soap_malloc(soap, sizeof(struct _ns1__byeRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__byeRes *)soap_malloc(soap, sizeof(struct _ns1__byeRes));
		soap_default__ns1__byeRes(soap, *a);
		if (!(*a = soap_in__ns1__byeRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__byeRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__byeRes, sizeof(struct _ns1__byeRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__byeRes(struct soap *soap, struct _ns1__byeRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__byeRes);
	if (soap_out_PointerTo_ns1__byeRes(soap, tag?tag:"ns1:byeRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__byeRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__byeRes(struct soap *soap, struct _ns1__byeRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__byeRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__byeReq(struct soap *soap, struct _ns1__byeReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__byeReq))
		soap_serialize__ns1__byeReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__byeReq(struct soap *soap, const char *tag, int id, struct _ns1__byeReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__byeReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__byeReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__byeReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__byeReq(struct soap *soap, const char *tag, struct _ns1__byeReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__byeReq **)soap_malloc(soap, sizeof(struct _ns1__byeReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__byeReq *)soap_malloc(soap, sizeof(struct _ns1__byeReq));
		soap_default__ns1__byeReq(soap, *a);
		if (!(*a = soap_in__ns1__byeReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__byeReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__byeReq, sizeof(struct _ns1__byeReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__byeReq(struct soap *soap, struct _ns1__byeReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__byeReq);
	if (soap_out_PointerTo_ns1__byeReq(soap, tag?tag:"ns1:byeReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__byeReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__byeReq(struct soap *soap, struct _ns1__byeReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__byeReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__inviteRes(struct soap *soap, struct ns1__inviteRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__inviteRes))
		soap_serialize_ns1__inviteRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__inviteRes(struct soap *soap, const char *tag, int id, struct ns1__inviteRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__inviteRes);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__inviteRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__inviteRes ** SOAP_FMAC4 soap_in_PointerTons1__inviteRes(struct soap *soap, const char *tag, struct ns1__inviteRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__inviteRes **)soap_malloc(soap, sizeof(struct ns1__inviteRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__inviteRes *)soap_malloc(soap, sizeof(struct ns1__inviteRes));
		soap_default_ns1__inviteRes(soap, *a);
		if (!(*a = soap_in_ns1__inviteRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__inviteRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__inviteRes, sizeof(struct ns1__inviteRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__inviteRes(struct soap *soap, struct ns1__inviteRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__inviteRes);
	if (soap_out_PointerTons1__inviteRes(soap, tag?tag:"ns1:inviteRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__inviteRes ** SOAP_FMAC4 soap_get_PointerTons1__inviteRes(struct soap *soap, struct ns1__inviteRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__inviteRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__inviteReq(struct soap *soap, struct ns1__inviteReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__inviteReq))
		soap_serialize_ns1__inviteReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__inviteReq(struct soap *soap, const char *tag, int id, struct ns1__inviteReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__inviteReq);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__inviteReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__inviteReq ** SOAP_FMAC4 soap_in_PointerTons1__inviteReq(struct soap *soap, const char *tag, struct ns1__inviteReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__inviteReq **)soap_malloc(soap, sizeof(struct ns1__inviteReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__inviteReq *)soap_malloc(soap, sizeof(struct ns1__inviteReq));
		soap_default_ns1__inviteReq(soap, *a);
		if (!(*a = soap_in_ns1__inviteReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__inviteReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__inviteReq, sizeof(struct ns1__inviteReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__inviteReq(struct soap *soap, struct ns1__inviteReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__inviteReq);
	if (soap_out_PointerTons1__inviteReq(soap, tag?tag:"ns1:inviteReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__inviteReq ** SOAP_FMAC4 soap_get_PointerTons1__inviteReq(struct soap *soap, struct ns1__inviteReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__inviteReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setAuxiliaryRes(struct soap *soap, struct _ns1__setAuxiliaryRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setAuxiliaryRes))
		soap_serialize__ns1__setAuxiliaryRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setAuxiliaryRes(struct soap *soap, const char *tag, int id, struct _ns1__setAuxiliaryRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setAuxiliaryRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setAuxiliaryRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setAuxiliaryRes(struct soap *soap, const char *tag, struct _ns1__setAuxiliaryRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setAuxiliaryRes **)soap_malloc(soap, sizeof(struct _ns1__setAuxiliaryRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setAuxiliaryRes *)soap_malloc(soap, sizeof(struct _ns1__setAuxiliaryRes));
		soap_default__ns1__setAuxiliaryRes(soap, *a);
		if (!(*a = soap_in__ns1__setAuxiliaryRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setAuxiliaryRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setAuxiliaryRes, sizeof(struct _ns1__setAuxiliaryRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setAuxiliaryRes(struct soap *soap, struct _ns1__setAuxiliaryRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setAuxiliaryRes);
	if (soap_out_PointerTo_ns1__setAuxiliaryRes(soap, tag?tag:"ns1:setAuxiliaryRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setAuxiliaryRes(struct soap *soap, struct _ns1__setAuxiliaryRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setAuxiliaryRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setAuxiliaryReq(struct soap *soap, struct _ns1__setAuxiliaryReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setAuxiliaryReq))
		soap_serialize__ns1__setAuxiliaryReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setAuxiliaryReq(struct soap *soap, const char *tag, int id, struct _ns1__setAuxiliaryReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setAuxiliaryReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setAuxiliaryReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setAuxiliaryReq(struct soap *soap, const char *tag, struct _ns1__setAuxiliaryReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setAuxiliaryReq **)soap_malloc(soap, sizeof(struct _ns1__setAuxiliaryReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setAuxiliaryReq *)soap_malloc(soap, sizeof(struct _ns1__setAuxiliaryReq));
		soap_default__ns1__setAuxiliaryReq(soap, *a);
		if (!(*a = soap_in__ns1__setAuxiliaryReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setAuxiliaryReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setAuxiliaryReq, sizeof(struct _ns1__setAuxiliaryReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setAuxiliaryReq(struct soap *soap, struct _ns1__setAuxiliaryReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setAuxiliaryReq);
	if (soap_out_PointerTo_ns1__setAuxiliaryReq(soap, tag?tag:"ns1:setAuxiliaryReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setAuxiliaryReq(struct soap *soap, struct _ns1__setAuxiliaryReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setAuxiliaryReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAuxiliaryRes(struct soap *soap, struct _ns1__getAuxiliaryRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAuxiliaryRes))
		soap_serialize__ns1__getAuxiliaryRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAuxiliaryRes(struct soap *soap, const char *tag, int id, struct _ns1__getAuxiliaryRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAuxiliaryRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAuxiliaryRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAuxiliaryRes(struct soap *soap, const char *tag, struct _ns1__getAuxiliaryRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAuxiliaryRes **)soap_malloc(soap, sizeof(struct _ns1__getAuxiliaryRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getAuxiliaryRes *)soap_malloc(soap, sizeof(struct _ns1__getAuxiliaryRes));
		soap_default__ns1__getAuxiliaryRes(soap, *a);
		if (!(*a = soap_in__ns1__getAuxiliaryRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAuxiliaryRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAuxiliaryRes, sizeof(struct _ns1__getAuxiliaryRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAuxiliaryRes(struct soap *soap, struct _ns1__getAuxiliaryRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAuxiliaryRes);
	if (soap_out_PointerTo_ns1__getAuxiliaryRes(soap, tag?tag:"ns1:getAuxiliaryRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAuxiliaryRes(struct soap *soap, struct _ns1__getAuxiliaryRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAuxiliaryRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAuxiliaryReq(struct soap *soap, struct _ns1__getAuxiliaryReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAuxiliaryReq))
		soap_serialize__ns1__getAuxiliaryReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAuxiliaryReq(struct soap *soap, const char *tag, int id, struct _ns1__getAuxiliaryReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAuxiliaryReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAuxiliaryReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAuxiliaryReq(struct soap *soap, const char *tag, struct _ns1__getAuxiliaryReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAuxiliaryReq **)soap_malloc(soap, sizeof(struct _ns1__getAuxiliaryReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getAuxiliaryReq *)soap_malloc(soap, sizeof(struct _ns1__getAuxiliaryReq));
		soap_default__ns1__getAuxiliaryReq(soap, *a);
		if (!(*a = soap_in__ns1__getAuxiliaryReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAuxiliaryReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAuxiliaryReq, sizeof(struct _ns1__getAuxiliaryReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAuxiliaryReq(struct soap *soap, struct _ns1__getAuxiliaryReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAuxiliaryReq);
	if (soap_out_PointerTo_ns1__getAuxiliaryReq(soap, tag?tag:"ns1:getAuxiliaryReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAuxiliaryReq(struct soap *soap, struct _ns1__getAuxiliaryReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAuxiliaryReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getBackPasswordRes(struct soap *soap, struct _ns1__getBackPasswordRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getBackPasswordRes))
		soap_serialize__ns1__getBackPasswordRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getBackPasswordRes(struct soap *soap, const char *tag, int id, struct _ns1__getBackPasswordRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getBackPasswordRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getBackPasswordRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getBackPasswordRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getBackPasswordRes(struct soap *soap, const char *tag, struct _ns1__getBackPasswordRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getBackPasswordRes **)soap_malloc(soap, sizeof(struct _ns1__getBackPasswordRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getBackPasswordRes *)soap_malloc(soap, sizeof(struct _ns1__getBackPasswordRes));
		soap_default__ns1__getBackPasswordRes(soap, *a);
		if (!(*a = soap_in__ns1__getBackPasswordRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getBackPasswordRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getBackPasswordRes, sizeof(struct _ns1__getBackPasswordRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getBackPasswordRes(struct soap *soap, struct _ns1__getBackPasswordRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getBackPasswordRes);
	if (soap_out_PointerTo_ns1__getBackPasswordRes(soap, tag?tag:"ns1:getBackPasswordRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getBackPasswordRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getBackPasswordRes(struct soap *soap, struct _ns1__getBackPasswordRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getBackPasswordRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getBackPasswordReq(struct soap *soap, struct _ns1__getBackPasswordReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getBackPasswordReq))
		soap_serialize__ns1__getBackPasswordReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getBackPasswordReq(struct soap *soap, const char *tag, int id, struct _ns1__getBackPasswordReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getBackPasswordReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getBackPasswordReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getBackPasswordReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getBackPasswordReq(struct soap *soap, const char *tag, struct _ns1__getBackPasswordReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getBackPasswordReq **)soap_malloc(soap, sizeof(struct _ns1__getBackPasswordReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getBackPasswordReq *)soap_malloc(soap, sizeof(struct _ns1__getBackPasswordReq));
		soap_default__ns1__getBackPasswordReq(soap, *a);
		if (!(*a = soap_in__ns1__getBackPasswordReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getBackPasswordReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getBackPasswordReq, sizeof(struct _ns1__getBackPasswordReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getBackPasswordReq(struct soap *soap, struct _ns1__getBackPasswordReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getBackPasswordReq);
	if (soap_out_PointerTo_ns1__getBackPasswordReq(soap, tag?tag:"ns1:getBackPasswordReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getBackPasswordReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getBackPasswordReq(struct soap *soap, struct _ns1__getBackPasswordReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getBackPasswordReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAccountRes(struct soap *soap, struct _ns1__getAccountRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAccountRes))
		soap_serialize__ns1__getAccountRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAccountRes(struct soap *soap, const char *tag, int id, struct _ns1__getAccountRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAccountRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAccountRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAccountRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAccountRes(struct soap *soap, const char *tag, struct _ns1__getAccountRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAccountRes **)soap_malloc(soap, sizeof(struct _ns1__getAccountRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getAccountRes *)soap_malloc(soap, sizeof(struct _ns1__getAccountRes));
		soap_default__ns1__getAccountRes(soap, *a);
		if (!(*a = soap_in__ns1__getAccountRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAccountRes, sizeof(struct _ns1__getAccountRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAccountRes(struct soap *soap, struct _ns1__getAccountRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAccountRes);
	if (soap_out_PointerTo_ns1__getAccountRes(soap, tag?tag:"ns1:getAccountRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAccountRes(struct soap *soap, struct _ns1__getAccountRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAccountRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAccountReq(struct soap *soap, struct _ns1__getAccountReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAccountReq))
		soap_serialize__ns1__getAccountReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAccountReq(struct soap *soap, const char *tag, int id, struct _ns1__getAccountReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAccountReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAccountReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAccountReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAccountReq(struct soap *soap, const char *tag, struct _ns1__getAccountReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAccountReq **)soap_malloc(soap, sizeof(struct _ns1__getAccountReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getAccountReq *)soap_malloc(soap, sizeof(struct _ns1__getAccountReq));
		soap_default__ns1__getAccountReq(soap, *a);
		if (!(*a = soap_in__ns1__getAccountReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAccountReq, sizeof(struct _ns1__getAccountReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAccountReq(struct soap *soap, struct _ns1__getAccountReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAccountReq);
	if (soap_out_PointerTo_ns1__getAccountReq(soap, tag?tag:"ns1:getAccountReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAccountReq(struct soap *soap, struct _ns1__getAccountReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAccountReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAppleTokenRes(struct soap *soap, struct _ns1__updateAppleTokenRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAppleTokenRes))
		soap_serialize__ns1__updateAppleTokenRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAppleTokenRes(struct soap *soap, const char *tag, int id, struct _ns1__updateAppleTokenRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAppleTokenRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAppleTokenRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAppleTokenRes(struct soap *soap, const char *tag, struct _ns1__updateAppleTokenRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAppleTokenRes **)soap_malloc(soap, sizeof(struct _ns1__updateAppleTokenRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__updateAppleTokenRes *)soap_malloc(soap, sizeof(struct _ns1__updateAppleTokenRes));
		soap_default__ns1__updateAppleTokenRes(soap, *a);
		if (!(*a = soap_in__ns1__updateAppleTokenRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAppleTokenRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAppleTokenRes, sizeof(struct _ns1__updateAppleTokenRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAppleTokenRes(struct soap *soap, struct _ns1__updateAppleTokenRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAppleTokenRes);
	if (soap_out_PointerTo_ns1__updateAppleTokenRes(soap, tag?tag:"ns1:updateAppleTokenRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAppleTokenRes(struct soap *soap, struct _ns1__updateAppleTokenRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAppleTokenRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAppleTokenReq(struct soap *soap, struct _ns1__updateAppleTokenReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAppleTokenReq))
		soap_serialize__ns1__updateAppleTokenReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAppleTokenReq(struct soap *soap, const char *tag, int id, struct _ns1__updateAppleTokenReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAppleTokenReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAppleTokenReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAppleTokenReq(struct soap *soap, const char *tag, struct _ns1__updateAppleTokenReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAppleTokenReq **)soap_malloc(soap, sizeof(struct _ns1__updateAppleTokenReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__updateAppleTokenReq *)soap_malloc(soap, sizeof(struct _ns1__updateAppleTokenReq));
		soap_default__ns1__updateAppleTokenReq(soap, *a);
		if (!(*a = soap_in__ns1__updateAppleTokenReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAppleTokenReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAppleTokenReq, sizeof(struct _ns1__updateAppleTokenReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAppleTokenReq(struct soap *soap, struct _ns1__updateAppleTokenReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAppleTokenReq);
	if (soap_out_PointerTo_ns1__updateAppleTokenReq(soap, tag?tag:"ns1:updateAppleTokenReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAppleTokenReq(struct soap *soap, struct _ns1__updateAppleTokenReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAppleTokenReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDeviceRes(struct soap *soap, struct _ns1__queryDeviceRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDeviceRes))
		soap_serialize__ns1__queryDeviceRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDeviceRes(struct soap *soap, const char *tag, int id, struct _ns1__queryDeviceRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDeviceRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDeviceRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDeviceRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDeviceRes(struct soap *soap, const char *tag, struct _ns1__queryDeviceRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDeviceRes **)soap_malloc(soap, sizeof(struct _ns1__queryDeviceRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryDeviceRes *)soap_malloc(soap, sizeof(struct _ns1__queryDeviceRes));
		soap_default__ns1__queryDeviceRes(soap, *a);
		if (!(*a = soap_in__ns1__queryDeviceRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDeviceRes, sizeof(struct _ns1__queryDeviceRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDeviceRes(struct soap *soap, struct _ns1__queryDeviceRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDeviceRes);
	if (soap_out_PointerTo_ns1__queryDeviceRes(soap, tag?tag:"ns1:queryDeviceRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDeviceRes(struct soap *soap, struct _ns1__queryDeviceRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDeviceRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDeviceReq(struct soap *soap, struct _ns1__queryDeviceReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDeviceReq))
		soap_serialize__ns1__queryDeviceReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDeviceReq(struct soap *soap, const char *tag, int id, struct _ns1__queryDeviceReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDeviceReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDeviceReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDeviceReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDeviceReq(struct soap *soap, const char *tag, struct _ns1__queryDeviceReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDeviceReq **)soap_malloc(soap, sizeof(struct _ns1__queryDeviceReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryDeviceReq *)soap_malloc(soap, sizeof(struct _ns1__queryDeviceReq));
		soap_default__ns1__queryDeviceReq(soap, *a);
		if (!(*a = soap_in__ns1__queryDeviceReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDeviceReq, sizeof(struct _ns1__queryDeviceReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDeviceReq(struct soap *soap, struct _ns1__queryDeviceReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDeviceReq);
	if (soap_out_PointerTo_ns1__queryDeviceReq(soap, tag?tag:"ns1:queryDeviceReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDeviceReq(struct soap *soap, struct _ns1__queryDeviceReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDeviceReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updatePasswordRes(struct soap *soap, struct _ns1__updatePasswordRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updatePasswordRes))
		soap_serialize__ns1__updatePasswordRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updatePasswordRes(struct soap *soap, const char *tag, int id, struct _ns1__updatePasswordRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updatePasswordRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updatePasswordRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updatePasswordRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__updatePasswordRes(struct soap *soap, const char *tag, struct _ns1__updatePasswordRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updatePasswordRes **)soap_malloc(soap, sizeof(struct _ns1__updatePasswordRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__updatePasswordRes *)soap_malloc(soap, sizeof(struct _ns1__updatePasswordRes));
		soap_default__ns1__updatePasswordRes(soap, *a);
		if (!(*a = soap_in__ns1__updatePasswordRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updatePasswordRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updatePasswordRes, sizeof(struct _ns1__updatePasswordRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updatePasswordRes(struct soap *soap, struct _ns1__updatePasswordRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updatePasswordRes);
	if (soap_out_PointerTo_ns1__updatePasswordRes(soap, tag?tag:"ns1:updatePasswordRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updatePasswordRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__updatePasswordRes(struct soap *soap, struct _ns1__updatePasswordRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updatePasswordRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updatePasswordReq(struct soap *soap, struct _ns1__updatePasswordReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updatePasswordReq))
		soap_serialize__ns1__updatePasswordReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updatePasswordReq(struct soap *soap, const char *tag, int id, struct _ns1__updatePasswordReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updatePasswordReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updatePasswordReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updatePasswordReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__updatePasswordReq(struct soap *soap, const char *tag, struct _ns1__updatePasswordReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updatePasswordReq **)soap_malloc(soap, sizeof(struct _ns1__updatePasswordReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__updatePasswordReq *)soap_malloc(soap, sizeof(struct _ns1__updatePasswordReq));
		soap_default__ns1__updatePasswordReq(soap, *a);
		if (!(*a = soap_in__ns1__updatePasswordReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updatePasswordReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updatePasswordReq, sizeof(struct _ns1__updatePasswordReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updatePasswordReq(struct soap *soap, struct _ns1__updatePasswordReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updatePasswordReq);
	if (soap_out_PointerTo_ns1__updatePasswordReq(soap, tag?tag:"ns1:updatePasswordReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updatePasswordReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__updatePasswordReq(struct soap *soap, struct _ns1__updatePasswordReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updatePasswordReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAccountRes(struct soap *soap, struct _ns1__updateAccountRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAccountRes))
		soap_serialize__ns1__updateAccountRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAccountRes(struct soap *soap, const char *tag, int id, struct _ns1__updateAccountRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAccountRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAccountRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAccountRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAccountRes(struct soap *soap, const char *tag, struct _ns1__updateAccountRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAccountRes **)soap_malloc(soap, sizeof(struct _ns1__updateAccountRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__updateAccountRes *)soap_malloc(soap, sizeof(struct _ns1__updateAccountRes));
		soap_default__ns1__updateAccountRes(soap, *a);
		if (!(*a = soap_in__ns1__updateAccountRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAccountRes, sizeof(struct _ns1__updateAccountRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAccountRes(struct soap *soap, struct _ns1__updateAccountRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAccountRes);
	if (soap_out_PointerTo_ns1__updateAccountRes(soap, tag?tag:"ns1:updateAccountRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAccountRes(struct soap *soap, struct _ns1__updateAccountRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAccountRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAccountReq(struct soap *soap, struct _ns1__updateAccountReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAccountReq))
		soap_serialize__ns1__updateAccountReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAccountReq(struct soap *soap, const char *tag, int id, struct _ns1__updateAccountReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAccountReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAccountReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAccountReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAccountReq(struct soap *soap, const char *tag, struct _ns1__updateAccountReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAccountReq **)soap_malloc(soap, sizeof(struct _ns1__updateAccountReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__updateAccountReq *)soap_malloc(soap, sizeof(struct _ns1__updateAccountReq));
		soap_default__ns1__updateAccountReq(soap, *a);
		if (!(*a = soap_in__ns1__updateAccountReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAccountReq, sizeof(struct _ns1__updateAccountReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAccountReq(struct soap *soap, struct _ns1__updateAccountReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAccountReq);
	if (soap_out_PointerTo_ns1__updateAccountReq(soap, tag?tag:"ns1:updateAccountReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAccountReq(struct soap *soap, struct _ns1__updateAccountReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAccountReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__createAccountRes(struct soap *soap, struct _ns1__createAccountRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__createAccountRes))
		soap_serialize__ns1__createAccountRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__createAccountRes(struct soap *soap, const char *tag, int id, struct _ns1__createAccountRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__createAccountRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__createAccountRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__createAccountRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__createAccountRes(struct soap *soap, const char *tag, struct _ns1__createAccountRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__createAccountRes **)soap_malloc(soap, sizeof(struct _ns1__createAccountRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__createAccountRes *)soap_malloc(soap, sizeof(struct _ns1__createAccountRes));
		soap_default__ns1__createAccountRes(soap, *a);
		if (!(*a = soap_in__ns1__createAccountRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__createAccountRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__createAccountRes, sizeof(struct _ns1__createAccountRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__createAccountRes(struct soap *soap, struct _ns1__createAccountRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__createAccountRes);
	if (soap_out_PointerTo_ns1__createAccountRes(soap, tag?tag:"ns1:createAccountRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createAccountRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__createAccountRes(struct soap *soap, struct _ns1__createAccountRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__createAccountRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__createAccountReq(struct soap *soap, struct _ns1__createAccountReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__createAccountReq))
		soap_serialize__ns1__createAccountReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__createAccountReq(struct soap *soap, const char *tag, int id, struct _ns1__createAccountReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__createAccountReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__createAccountReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__createAccountReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__createAccountReq(struct soap *soap, const char *tag, struct _ns1__createAccountReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__createAccountReq **)soap_malloc(soap, sizeof(struct _ns1__createAccountReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__createAccountReq *)soap_malloc(soap, sizeof(struct _ns1__createAccountReq));
		soap_default__ns1__createAccountReq(soap, *a);
		if (!(*a = soap_in__ns1__createAccountReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__createAccountReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__createAccountReq, sizeof(struct _ns1__createAccountReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__createAccountReq(struct soap *soap, struct _ns1__createAccountReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__createAccountReq);
	if (soap_out_PointerTo_ns1__createAccountReq(soap, tag?tag:"ns1:createAccountReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createAccountReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__createAccountReq(struct soap *soap, struct _ns1__createAccountReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__createAccountReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPictureRes(struct soap *soap, struct _ns1__getPictureRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPictureRes))
		soap_serialize__ns1__getPictureRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPictureRes(struct soap *soap, const char *tag, int id, struct _ns1__getPictureRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPictureRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPictureRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPictureRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPictureRes(struct soap *soap, const char *tag, struct _ns1__getPictureRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPictureRes **)soap_malloc(soap, sizeof(struct _ns1__getPictureRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getPictureRes *)soap_malloc(soap, sizeof(struct _ns1__getPictureRes));
		soap_default__ns1__getPictureRes(soap, *a);
		if (!(*a = soap_in__ns1__getPictureRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPictureRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPictureRes, sizeof(struct _ns1__getPictureRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPictureRes(struct soap *soap, struct _ns1__getPictureRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPictureRes);
	if (soap_out_PointerTo_ns1__getPictureRes(soap, tag?tag:"ns1:getPictureRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPictureRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPictureRes(struct soap *soap, struct _ns1__getPictureRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPictureRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPictureReq(struct soap *soap, struct _ns1__getPictureReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPictureReq))
		soap_serialize__ns1__getPictureReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPictureReq(struct soap *soap, const char *tag, int id, struct _ns1__getPictureReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPictureReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPictureReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPictureReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPictureReq(struct soap *soap, const char *tag, struct _ns1__getPictureReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPictureReq **)soap_malloc(soap, sizeof(struct _ns1__getPictureReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getPictureReq *)soap_malloc(soap, sizeof(struct _ns1__getPictureReq));
		soap_default__ns1__getPictureReq(soap, *a);
		if (!(*a = soap_in__ns1__getPictureReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPictureReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPictureReq, sizeof(struct _ns1__getPictureReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPictureReq(struct soap *soap, struct _ns1__getPictureReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPictureReq);
	if (soap_out_PointerTo_ns1__getPictureReq(soap, tag?tag:"ns1:getPictureReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPictureReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPictureReq(struct soap *soap, struct _ns1__getPictureReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPictureReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__flaggedNoticeStatusRes(struct soap *soap, struct _ns1__flaggedNoticeStatusRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__flaggedNoticeStatusRes))
		soap_serialize__ns1__flaggedNoticeStatusRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__flaggedNoticeStatusRes(struct soap *soap, const char *tag, int id, struct _ns1__flaggedNoticeStatusRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__flaggedNoticeStatusRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__flaggedNoticeStatusRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__flaggedNoticeStatusRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__flaggedNoticeStatusRes(struct soap *soap, const char *tag, struct _ns1__flaggedNoticeStatusRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__flaggedNoticeStatusRes **)soap_malloc(soap, sizeof(struct _ns1__flaggedNoticeStatusRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__flaggedNoticeStatusRes *)soap_malloc(soap, sizeof(struct _ns1__flaggedNoticeStatusRes));
		soap_default__ns1__flaggedNoticeStatusRes(soap, *a);
		if (!(*a = soap_in__ns1__flaggedNoticeStatusRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__flaggedNoticeStatusRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__flaggedNoticeStatusRes, sizeof(struct _ns1__flaggedNoticeStatusRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__flaggedNoticeStatusRes(struct soap *soap, struct _ns1__flaggedNoticeStatusRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__flaggedNoticeStatusRes);
	if (soap_out_PointerTo_ns1__flaggedNoticeStatusRes(soap, tag?tag:"ns1:flaggedNoticeStatusRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__flaggedNoticeStatusRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__flaggedNoticeStatusRes(struct soap *soap, struct _ns1__flaggedNoticeStatusRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__flaggedNoticeStatusRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__flaggedNoticeStatusReq(struct soap *soap, struct _ns1__flaggedNoticeStatusReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__flaggedNoticeStatusReq))
		soap_serialize__ns1__flaggedNoticeStatusReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__flaggedNoticeStatusReq(struct soap *soap, const char *tag, int id, struct _ns1__flaggedNoticeStatusReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__flaggedNoticeStatusReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__flaggedNoticeStatusReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__flaggedNoticeStatusReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__flaggedNoticeStatusReq(struct soap *soap, const char *tag, struct _ns1__flaggedNoticeStatusReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__flaggedNoticeStatusReq **)soap_malloc(soap, sizeof(struct _ns1__flaggedNoticeStatusReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__flaggedNoticeStatusReq *)soap_malloc(soap, sizeof(struct _ns1__flaggedNoticeStatusReq));
		soap_default__ns1__flaggedNoticeStatusReq(soap, *a);
		if (!(*a = soap_in__ns1__flaggedNoticeStatusReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__flaggedNoticeStatusReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__flaggedNoticeStatusReq, sizeof(struct _ns1__flaggedNoticeStatusReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__flaggedNoticeStatusReq(struct soap *soap, struct _ns1__flaggedNoticeStatusReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__flaggedNoticeStatusReq);
	if (soap_out_PointerTo_ns1__flaggedNoticeStatusReq(soap, tag?tag:"ns1:flaggedNoticeStatusReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__flaggedNoticeStatusReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__flaggedNoticeStatusReq(struct soap *soap, struct _ns1__flaggedNoticeStatusReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__flaggedNoticeStatusReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryNoticesRes(struct soap *soap, struct _ns1__queryNoticesRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryNoticesRes))
		soap_serialize__ns1__queryNoticesRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryNoticesRes(struct soap *soap, const char *tag, int id, struct _ns1__queryNoticesRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryNoticesRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryNoticesRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryNoticesRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryNoticesRes(struct soap *soap, const char *tag, struct _ns1__queryNoticesRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryNoticesRes **)soap_malloc(soap, sizeof(struct _ns1__queryNoticesRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryNoticesRes *)soap_malloc(soap, sizeof(struct _ns1__queryNoticesRes));
		soap_default__ns1__queryNoticesRes(soap, *a);
		if (!(*a = soap_in__ns1__queryNoticesRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryNoticesRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryNoticesRes, sizeof(struct _ns1__queryNoticesRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryNoticesRes(struct soap *soap, struct _ns1__queryNoticesRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryNoticesRes);
	if (soap_out_PointerTo_ns1__queryNoticesRes(soap, tag?tag:"ns1:queryNoticesRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryNoticesRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryNoticesRes(struct soap *soap, struct _ns1__queryNoticesRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryNoticesRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryNoticesReq(struct soap *soap, struct _ns1__queryNoticesReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryNoticesReq))
		soap_serialize__ns1__queryNoticesReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryNoticesReq(struct soap *soap, const char *tag, int id, struct _ns1__queryNoticesReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryNoticesReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryNoticesReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryNoticesReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryNoticesReq(struct soap *soap, const char *tag, struct _ns1__queryNoticesReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryNoticesReq **)soap_malloc(soap, sizeof(struct _ns1__queryNoticesReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__queryNoticesReq *)soap_malloc(soap, sizeof(struct _ns1__queryNoticesReq));
		soap_default__ns1__queryNoticesReq(soap, *a);
		if (!(*a = soap_in__ns1__queryNoticesReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryNoticesReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryNoticesReq, sizeof(struct _ns1__queryNoticesReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryNoticesReq(struct soap *soap, struct _ns1__queryNoticesReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryNoticesReq);
	if (soap_out_PointerTo_ns1__queryNoticesReq(soap, tag?tag:"ns1:queryNoticesReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryNoticesReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryNoticesReq(struct soap *soap, struct _ns1__queryNoticesReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryNoticesReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__trustedAuthorityLoginRes(struct soap *soap, struct ns1__trustedAuthorityLoginRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__trustedAuthorityLoginRes))
		soap_serialize_ns1__trustedAuthorityLoginRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__trustedAuthorityLoginRes(struct soap *soap, const char *tag, int id, struct ns1__trustedAuthorityLoginRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__trustedAuthorityLoginRes);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__trustedAuthorityLoginRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__trustedAuthorityLoginRes ** SOAP_FMAC4 soap_in_PointerTons1__trustedAuthorityLoginRes(struct soap *soap, const char *tag, struct ns1__trustedAuthorityLoginRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__trustedAuthorityLoginRes **)soap_malloc(soap, sizeof(struct ns1__trustedAuthorityLoginRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__trustedAuthorityLoginRes *)soap_malloc(soap, sizeof(struct ns1__trustedAuthorityLoginRes));
		soap_default_ns1__trustedAuthorityLoginRes(soap, *a);
		if (!(*a = soap_in_ns1__trustedAuthorityLoginRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__trustedAuthorityLoginRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__trustedAuthorityLoginRes, sizeof(struct ns1__trustedAuthorityLoginRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__trustedAuthorityLoginRes(struct soap *soap, struct ns1__trustedAuthorityLoginRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__trustedAuthorityLoginRes);
	if (soap_out_PointerTons1__trustedAuthorityLoginRes(soap, tag?tag:"ns1:trustedAuthorityLoginRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__trustedAuthorityLoginRes ** SOAP_FMAC4 soap_get_PointerTons1__trustedAuthorityLoginRes(struct soap *soap, struct ns1__trustedAuthorityLoginRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__trustedAuthorityLoginRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__trustedAuthorityLoginReq(struct soap *soap, struct ns1__trustedAuthorityLoginReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__trustedAuthorityLoginReq))
		soap_serialize_ns1__trustedAuthorityLoginReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__trustedAuthorityLoginReq(struct soap *soap, const char *tag, int id, struct ns1__trustedAuthorityLoginReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__trustedAuthorityLoginReq);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__trustedAuthorityLoginReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__trustedAuthorityLoginReq ** SOAP_FMAC4 soap_in_PointerTons1__trustedAuthorityLoginReq(struct soap *soap, const char *tag, struct ns1__trustedAuthorityLoginReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__trustedAuthorityLoginReq **)soap_malloc(soap, sizeof(struct ns1__trustedAuthorityLoginReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__trustedAuthorityLoginReq *)soap_malloc(soap, sizeof(struct ns1__trustedAuthorityLoginReq));
		soap_default_ns1__trustedAuthorityLoginReq(soap, *a);
		if (!(*a = soap_in_ns1__trustedAuthorityLoginReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__trustedAuthorityLoginReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__trustedAuthorityLoginReq, sizeof(struct ns1__trustedAuthorityLoginReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__trustedAuthorityLoginReq(struct soap *soap, struct ns1__trustedAuthorityLoginReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__trustedAuthorityLoginReq);
	if (soap_out_PointerTons1__trustedAuthorityLoginReq(soap, tag?tag:"ns1:trustedAuthorityLoginReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__trustedAuthorityLoginReq ** SOAP_FMAC4 soap_get_PointerTons1__trustedAuthorityLoginReq(struct soap *soap, struct ns1__trustedAuthorityLoginReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__trustedAuthorityLoginReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDeviceMatchingResultRes(struct soap *soap, struct _ns1__getDeviceMatchingResultRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDeviceMatchingResultRes))
		soap_serialize__ns1__getDeviceMatchingResultRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDeviceMatchingResultRes(struct soap *soap, const char *tag, int id, struct _ns1__getDeviceMatchingResultRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDeviceMatchingResultRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getDeviceMatchingResultRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingResultRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDeviceMatchingResultRes(struct soap *soap, const char *tag, struct _ns1__getDeviceMatchingResultRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getDeviceMatchingResultRes **)soap_malloc(soap, sizeof(struct _ns1__getDeviceMatchingResultRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getDeviceMatchingResultRes *)soap_malloc(soap, sizeof(struct _ns1__getDeviceMatchingResultRes));
		soap_default__ns1__getDeviceMatchingResultRes(soap, *a);
		if (!(*a = soap_in__ns1__getDeviceMatchingResultRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDeviceMatchingResultRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDeviceMatchingResultRes, sizeof(struct _ns1__getDeviceMatchingResultRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDeviceMatchingResultRes(struct soap *soap, struct _ns1__getDeviceMatchingResultRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDeviceMatchingResultRes);
	if (soap_out_PointerTo_ns1__getDeviceMatchingResultRes(soap, tag?tag:"ns1:getDeviceMatchingResultRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingResultRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDeviceMatchingResultRes(struct soap *soap, struct _ns1__getDeviceMatchingResultRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDeviceMatchingResultRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDeviceMatchingResultReq(struct soap *soap, struct _ns1__getDeviceMatchingResultReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDeviceMatchingResultReq))
		soap_serialize__ns1__getDeviceMatchingResultReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDeviceMatchingResultReq(struct soap *soap, const char *tag, int id, struct _ns1__getDeviceMatchingResultReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDeviceMatchingResultReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getDeviceMatchingResultReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingResultReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDeviceMatchingResultReq(struct soap *soap, const char *tag, struct _ns1__getDeviceMatchingResultReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getDeviceMatchingResultReq **)soap_malloc(soap, sizeof(struct _ns1__getDeviceMatchingResultReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getDeviceMatchingResultReq *)soap_malloc(soap, sizeof(struct _ns1__getDeviceMatchingResultReq));
		soap_default__ns1__getDeviceMatchingResultReq(soap, *a);
		if (!(*a = soap_in__ns1__getDeviceMatchingResultReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDeviceMatchingResultReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDeviceMatchingResultReq, sizeof(struct _ns1__getDeviceMatchingResultReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDeviceMatchingResultReq(struct soap *soap, struct _ns1__getDeviceMatchingResultReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDeviceMatchingResultReq);
	if (soap_out_PointerTo_ns1__getDeviceMatchingResultReq(soap, tag?tag:"ns1:getDeviceMatchingResultReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingResultReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDeviceMatchingResultReq(struct soap *soap, struct _ns1__getDeviceMatchingResultReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDeviceMatchingResultReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDeviceMatchingCodeRes(struct soap *soap, struct _ns1__getDeviceMatchingCodeRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDeviceMatchingCodeRes))
		soap_serialize__ns1__getDeviceMatchingCodeRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDeviceMatchingCodeRes(struct soap *soap, const char *tag, int id, struct _ns1__getDeviceMatchingCodeRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDeviceMatchingCodeRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getDeviceMatchingCodeRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingCodeRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDeviceMatchingCodeRes(struct soap *soap, const char *tag, struct _ns1__getDeviceMatchingCodeRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getDeviceMatchingCodeRes **)soap_malloc(soap, sizeof(struct _ns1__getDeviceMatchingCodeRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getDeviceMatchingCodeRes *)soap_malloc(soap, sizeof(struct _ns1__getDeviceMatchingCodeRes));
		soap_default__ns1__getDeviceMatchingCodeRes(soap, *a);
		if (!(*a = soap_in__ns1__getDeviceMatchingCodeRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDeviceMatchingCodeRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDeviceMatchingCodeRes, sizeof(struct _ns1__getDeviceMatchingCodeRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDeviceMatchingCodeRes(struct soap *soap, struct _ns1__getDeviceMatchingCodeRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDeviceMatchingCodeRes);
	if (soap_out_PointerTo_ns1__getDeviceMatchingCodeRes(soap, tag?tag:"ns1:getDeviceMatchingCodeRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingCodeRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDeviceMatchingCodeRes(struct soap *soap, struct _ns1__getDeviceMatchingCodeRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDeviceMatchingCodeRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDeviceMatchingCodeReq(struct soap *soap, struct _ns1__getDeviceMatchingCodeReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDeviceMatchingCodeReq))
		soap_serialize__ns1__getDeviceMatchingCodeReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDeviceMatchingCodeReq(struct soap *soap, const char *tag, int id, struct _ns1__getDeviceMatchingCodeReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDeviceMatchingCodeReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getDeviceMatchingCodeReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingCodeReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDeviceMatchingCodeReq(struct soap *soap, const char *tag, struct _ns1__getDeviceMatchingCodeReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getDeviceMatchingCodeReq **)soap_malloc(soap, sizeof(struct _ns1__getDeviceMatchingCodeReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getDeviceMatchingCodeReq *)soap_malloc(soap, sizeof(struct _ns1__getDeviceMatchingCodeReq));
		soap_default__ns1__getDeviceMatchingCodeReq(soap, *a);
		if (!(*a = soap_in__ns1__getDeviceMatchingCodeReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDeviceMatchingCodeReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDeviceMatchingCodeReq, sizeof(struct _ns1__getDeviceMatchingCodeReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDeviceMatchingCodeReq(struct soap *soap, struct _ns1__getDeviceMatchingCodeReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDeviceMatchingCodeReq);
	if (soap_out_PointerTo_ns1__getDeviceMatchingCodeReq(soap, tag?tag:"ns1:getDeviceMatchingCodeReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDeviceMatchingCodeReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDeviceMatchingCodeReq(struct soap *soap, struct _ns1__getDeviceMatchingCodeReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDeviceMatchingCodeReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDynamicPasswordRes(struct soap *soap, struct _ns1__getDynamicPasswordRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDynamicPasswordRes))
		soap_serialize__ns1__getDynamicPasswordRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDynamicPasswordRes(struct soap *soap, const char *tag, int id, struct _ns1__getDynamicPasswordRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDynamicPasswordRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getDynamicPasswordRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getDynamicPasswordRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDynamicPasswordRes(struct soap *soap, const char *tag, struct _ns1__getDynamicPasswordRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getDynamicPasswordRes **)soap_malloc(soap, sizeof(struct _ns1__getDynamicPasswordRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getDynamicPasswordRes *)soap_malloc(soap, sizeof(struct _ns1__getDynamicPasswordRes));
		soap_default__ns1__getDynamicPasswordRes(soap, *a);
		if (!(*a = soap_in__ns1__getDynamicPasswordRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDynamicPasswordRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDynamicPasswordRes, sizeof(struct _ns1__getDynamicPasswordRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDynamicPasswordRes(struct soap *soap, struct _ns1__getDynamicPasswordRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDynamicPasswordRes);
	if (soap_out_PointerTo_ns1__getDynamicPasswordRes(soap, tag?tag:"ns1:getDynamicPasswordRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDynamicPasswordRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDynamicPasswordRes(struct soap *soap, struct _ns1__getDynamicPasswordRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDynamicPasswordRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDynamicPasswordReq(struct soap *soap, struct _ns1__getDynamicPasswordReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDynamicPasswordReq))
		soap_serialize__ns1__getDynamicPasswordReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDynamicPasswordReq(struct soap *soap, const char *tag, int id, struct _ns1__getDynamicPasswordReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDynamicPasswordReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getDynamicPasswordReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getDynamicPasswordReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDynamicPasswordReq(struct soap *soap, const char *tag, struct _ns1__getDynamicPasswordReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getDynamicPasswordReq **)soap_malloc(soap, sizeof(struct _ns1__getDynamicPasswordReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getDynamicPasswordReq *)soap_malloc(soap, sizeof(struct _ns1__getDynamicPasswordReq));
		soap_default__ns1__getDynamicPasswordReq(soap, *a);
		if (!(*a = soap_in__ns1__getDynamicPasswordReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDynamicPasswordReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDynamicPasswordReq, sizeof(struct _ns1__getDynamicPasswordReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDynamicPasswordReq(struct soap *soap, struct _ns1__getDynamicPasswordReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDynamicPasswordReq);
	if (soap_out_PointerTo_ns1__getDynamicPasswordReq(soap, tag?tag:"ns1:getDynamicPasswordReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDynamicPasswordReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDynamicPasswordReq(struct soap *soap, struct _ns1__getDynamicPasswordReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDynamicPasswordReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getWirelessNetworkRes(struct soap *soap, struct _ns1__getWirelessNetworkRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getWirelessNetworkRes))
		soap_serialize__ns1__getWirelessNetworkRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getWirelessNetworkRes(struct soap *soap, const char *tag, int id, struct _ns1__getWirelessNetworkRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getWirelessNetworkRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getWirelessNetworkRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getWirelessNetworkRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getWirelessNetworkRes(struct soap *soap, const char *tag, struct _ns1__getWirelessNetworkRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getWirelessNetworkRes **)soap_malloc(soap, sizeof(struct _ns1__getWirelessNetworkRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getWirelessNetworkRes *)soap_malloc(soap, sizeof(struct _ns1__getWirelessNetworkRes));
		soap_default__ns1__getWirelessNetworkRes(soap, *a);
		if (!(*a = soap_in__ns1__getWirelessNetworkRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getWirelessNetworkRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getWirelessNetworkRes, sizeof(struct _ns1__getWirelessNetworkRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getWirelessNetworkRes(struct soap *soap, struct _ns1__getWirelessNetworkRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getWirelessNetworkRes);
	if (soap_out_PointerTo_ns1__getWirelessNetworkRes(soap, tag?tag:"ns1:getWirelessNetworkRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getWirelessNetworkRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getWirelessNetworkRes(struct soap *soap, struct _ns1__getWirelessNetworkRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getWirelessNetworkRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getWirelessNetworkReq(struct soap *soap, struct _ns1__getWirelessNetworkReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getWirelessNetworkReq))
		soap_serialize__ns1__getWirelessNetworkReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getWirelessNetworkReq(struct soap *soap, const char *tag, int id, struct _ns1__getWirelessNetworkReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getWirelessNetworkReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getWirelessNetworkReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getWirelessNetworkReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getWirelessNetworkReq(struct soap *soap, const char *tag, struct _ns1__getWirelessNetworkReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getWirelessNetworkReq **)soap_malloc(soap, sizeof(struct _ns1__getWirelessNetworkReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getWirelessNetworkReq *)soap_malloc(soap, sizeof(struct _ns1__getWirelessNetworkReq));
		soap_default__ns1__getWirelessNetworkReq(soap, *a);
		if (!(*a = soap_in__ns1__getWirelessNetworkReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getWirelessNetworkReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getWirelessNetworkReq, sizeof(struct _ns1__getWirelessNetworkReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getWirelessNetworkReq(struct soap *soap, struct _ns1__getWirelessNetworkReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getWirelessNetworkReq);
	if (soap_out_PointerTo_ns1__getWirelessNetworkReq(soap, tag?tag:"ns1:getWirelessNetworkReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getWirelessNetworkReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getWirelessNetworkReq(struct soap *soap, struct _ns1__getWirelessNetworkReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getWirelessNetworkReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setRelayRes(struct soap *soap, struct _ns1__setRelayRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setRelayRes))
		soap_serialize__ns1__setRelayRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setRelayRes(struct soap *soap, const char *tag, int id, struct _ns1__setRelayRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setRelayRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setRelayRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setRelayRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setRelayRes(struct soap *soap, const char *tag, struct _ns1__setRelayRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setRelayRes **)soap_malloc(soap, sizeof(struct _ns1__setRelayRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setRelayRes *)soap_malloc(soap, sizeof(struct _ns1__setRelayRes));
		soap_default__ns1__setRelayRes(soap, *a);
		if (!(*a = soap_in__ns1__setRelayRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setRelayRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setRelayRes, sizeof(struct _ns1__setRelayRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setRelayRes(struct soap *soap, struct _ns1__setRelayRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setRelayRes);
	if (soap_out_PointerTo_ns1__setRelayRes(soap, tag?tag:"ns1:setRelayRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setRelayRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setRelayRes(struct soap *soap, struct _ns1__setRelayRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setRelayRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setRelayReq(struct soap *soap, struct _ns1__setRelayReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setRelayReq))
		soap_serialize__ns1__setRelayReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setRelayReq(struct soap *soap, const char *tag, int id, struct _ns1__setRelayReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setRelayReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setRelayReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setRelayReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setRelayReq(struct soap *soap, const char *tag, struct _ns1__setRelayReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setRelayReq **)soap_malloc(soap, sizeof(struct _ns1__setRelayReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setRelayReq *)soap_malloc(soap, sizeof(struct _ns1__setRelayReq));
		soap_default__ns1__setRelayReq(soap, *a);
		if (!(*a = soap_in__ns1__setRelayReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setRelayReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setRelayReq, sizeof(struct _ns1__setRelayReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setRelayReq(struct soap *soap, struct _ns1__setRelayReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setRelayReq);
	if (soap_out_PointerTo_ns1__setRelayReq(soap, tag?tag:"ns1:setRelayReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setRelayReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setRelayReq(struct soap *soap, struct _ns1__setRelayReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setRelayReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRelayRes(struct soap *soap, struct _ns1__getRelayRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRelayRes))
		soap_serialize__ns1__getRelayRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRelayRes(struct soap *soap, const char *tag, int id, struct _ns1__getRelayRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRelayRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getRelayRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getRelayRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRelayRes(struct soap *soap, const char *tag, struct _ns1__getRelayRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getRelayRes **)soap_malloc(soap, sizeof(struct _ns1__getRelayRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getRelayRes *)soap_malloc(soap, sizeof(struct _ns1__getRelayRes));
		soap_default__ns1__getRelayRes(soap, *a);
		if (!(*a = soap_in__ns1__getRelayRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getRelayRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRelayRes, sizeof(struct _ns1__getRelayRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRelayRes(struct soap *soap, struct _ns1__getRelayRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getRelayRes);
	if (soap_out_PointerTo_ns1__getRelayRes(soap, tag?tag:"ns1:getRelayRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getRelayRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRelayRes(struct soap *soap, struct _ns1__getRelayRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRelayRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRelayReq(struct soap *soap, struct _ns1__getRelayReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRelayReq))
		soap_serialize__ns1__getRelayReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRelayReq(struct soap *soap, const char *tag, int id, struct _ns1__getRelayReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRelayReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getRelayReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getRelayReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRelayReq(struct soap *soap, const char *tag, struct _ns1__getRelayReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getRelayReq **)soap_malloc(soap, sizeof(struct _ns1__getRelayReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getRelayReq *)soap_malloc(soap, sizeof(struct _ns1__getRelayReq));
		soap_default__ns1__getRelayReq(soap, *a);
		if (!(*a = soap_in__ns1__getRelayReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getRelayReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRelayReq, sizeof(struct _ns1__getRelayReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRelayReq(struct soap *soap, struct _ns1__getRelayReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getRelayReq);
	if (soap_out_PointerTo_ns1__getRelayReq(soap, tag?tag:"ns1:getRelayReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getRelayReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRelayReq(struct soap *soap, struct _ns1__getRelayReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRelayReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setRecordParamRes(struct soap *soap, struct _ns1__setRecordParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setRecordParamRes))
		soap_serialize__ns1__setRecordParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setRecordParamRes(struct soap *soap, const char *tag, int id, struct _ns1__setRecordParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setRecordParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setRecordParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setRecordParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setRecordParamRes(struct soap *soap, const char *tag, struct _ns1__setRecordParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setRecordParamRes **)soap_malloc(soap, sizeof(struct _ns1__setRecordParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setRecordParamRes *)soap_malloc(soap, sizeof(struct _ns1__setRecordParamRes));
		soap_default__ns1__setRecordParamRes(soap, *a);
		if (!(*a = soap_in__ns1__setRecordParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setRecordParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setRecordParamRes, sizeof(struct _ns1__setRecordParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setRecordParamRes(struct soap *soap, struct _ns1__setRecordParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setRecordParamRes);
	if (soap_out_PointerTo_ns1__setRecordParamRes(soap, tag?tag:"ns1:setRecordParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setRecordParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setRecordParamRes(struct soap *soap, struct _ns1__setRecordParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setRecordParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setRecordParamReq(struct soap *soap, struct _ns1__setRecordParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setRecordParamReq))
		soap_serialize__ns1__setRecordParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setRecordParamReq(struct soap *soap, const char *tag, int id, struct _ns1__setRecordParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setRecordParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setRecordParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setRecordParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setRecordParamReq(struct soap *soap, const char *tag, struct _ns1__setRecordParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setRecordParamReq **)soap_malloc(soap, sizeof(struct _ns1__setRecordParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setRecordParamReq *)soap_malloc(soap, sizeof(struct _ns1__setRecordParamReq));
		soap_default__ns1__setRecordParamReq(soap, *a);
		if (!(*a = soap_in__ns1__setRecordParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setRecordParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setRecordParamReq, sizeof(struct _ns1__setRecordParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setRecordParamReq(struct soap *soap, struct _ns1__setRecordParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setRecordParamReq);
	if (soap_out_PointerTo_ns1__setRecordParamReq(soap, tag?tag:"ns1:setRecordParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setRecordParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setRecordParamReq(struct soap *soap, struct _ns1__setRecordParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setRecordParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRecordParamRes(struct soap *soap, struct _ns1__getRecordParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRecordParamRes))
		soap_serialize__ns1__getRecordParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRecordParamRes(struct soap *soap, const char *tag, int id, struct _ns1__getRecordParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRecordParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getRecordParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getRecordParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRecordParamRes(struct soap *soap, const char *tag, struct _ns1__getRecordParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getRecordParamRes **)soap_malloc(soap, sizeof(struct _ns1__getRecordParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getRecordParamRes *)soap_malloc(soap, sizeof(struct _ns1__getRecordParamRes));
		soap_default__ns1__getRecordParamRes(soap, *a);
		if (!(*a = soap_in__ns1__getRecordParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getRecordParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRecordParamRes, sizeof(struct _ns1__getRecordParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRecordParamRes(struct soap *soap, struct _ns1__getRecordParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getRecordParamRes);
	if (soap_out_PointerTo_ns1__getRecordParamRes(soap, tag?tag:"ns1:getRecordParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getRecordParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRecordParamRes(struct soap *soap, struct _ns1__getRecordParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRecordParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRecordParamReq(struct soap *soap, struct _ns1__getRecordParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRecordParamReq))
		soap_serialize__ns1__getRecordParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRecordParamReq(struct soap *soap, const char *tag, int id, struct _ns1__getRecordParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRecordParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getRecordParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getRecordParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRecordParamReq(struct soap *soap, const char *tag, struct _ns1__getRecordParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getRecordParamReq **)soap_malloc(soap, sizeof(struct _ns1__getRecordParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getRecordParamReq *)soap_malloc(soap, sizeof(struct _ns1__getRecordParamReq));
		soap_default__ns1__getRecordParamReq(soap, *a);
		if (!(*a = soap_in__ns1__getRecordParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getRecordParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRecordParamReq, sizeof(struct _ns1__getRecordParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRecordParamReq(struct soap *soap, struct _ns1__getRecordParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getRecordParamReq);
	if (soap_out_PointerTo_ns1__getRecordParamReq(soap, tag?tag:"ns1:getRecordParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getRecordParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRecordParamReq(struct soap *soap, struct _ns1__getRecordParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRecordParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setPushWorkSheetRes(struct soap *soap, struct _ns1__setPushWorkSheetRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setPushWorkSheetRes))
		soap_serialize__ns1__setPushWorkSheetRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setPushWorkSheetRes(struct soap *soap, const char *tag, int id, struct _ns1__setPushWorkSheetRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setPushWorkSheetRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setPushWorkSheetRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setPushWorkSheetRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setPushWorkSheetRes(struct soap *soap, const char *tag, struct _ns1__setPushWorkSheetRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setPushWorkSheetRes **)soap_malloc(soap, sizeof(struct _ns1__setPushWorkSheetRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setPushWorkSheetRes *)soap_malloc(soap, sizeof(struct _ns1__setPushWorkSheetRes));
		soap_default__ns1__setPushWorkSheetRes(soap, *a);
		if (!(*a = soap_in__ns1__setPushWorkSheetRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPushWorkSheetRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setPushWorkSheetRes, sizeof(struct _ns1__setPushWorkSheetRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setPushWorkSheetRes(struct soap *soap, struct _ns1__setPushWorkSheetRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setPushWorkSheetRes);
	if (soap_out_PointerTo_ns1__setPushWorkSheetRes(soap, tag?tag:"ns1:setPushWorkSheetRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPushWorkSheetRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setPushWorkSheetRes(struct soap *soap, struct _ns1__setPushWorkSheetRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setPushWorkSheetRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setPushWorkSheetReq(struct soap *soap, struct _ns1__setPushWorkSheetReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setPushWorkSheetReq))
		soap_serialize__ns1__setPushWorkSheetReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setPushWorkSheetReq(struct soap *soap, const char *tag, int id, struct _ns1__setPushWorkSheetReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setPushWorkSheetReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setPushWorkSheetReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setPushWorkSheetReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setPushWorkSheetReq(struct soap *soap, const char *tag, struct _ns1__setPushWorkSheetReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setPushWorkSheetReq **)soap_malloc(soap, sizeof(struct _ns1__setPushWorkSheetReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__setPushWorkSheetReq *)soap_malloc(soap, sizeof(struct _ns1__setPushWorkSheetReq));
		soap_default__ns1__setPushWorkSheetReq(soap, *a);
		if (!(*a = soap_in__ns1__setPushWorkSheetReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPushWorkSheetReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setPushWorkSheetReq, sizeof(struct _ns1__setPushWorkSheetReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setPushWorkSheetReq(struct soap *soap, struct _ns1__setPushWorkSheetReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setPushWorkSheetReq);
	if (soap_out_PointerTo_ns1__setPushWorkSheetReq(soap, tag?tag:"ns1:setPushWorkSheetReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPushWorkSheetReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setPushWorkSheetReq(struct soap *soap, struct _ns1__setPushWorkSheetReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setPushWorkSheetReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPushWorkSheetRes(struct soap *soap, struct _ns1__getPushWorkSheetRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPushWorkSheetRes))
		soap_serialize__ns1__getPushWorkSheetRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPushWorkSheetRes(struct soap *soap, const char *tag, int id, struct _ns1__getPushWorkSheetRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPushWorkSheetRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPushWorkSheetRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPushWorkSheetRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPushWorkSheetRes(struct soap *soap, const char *tag, struct _ns1__getPushWorkSheetRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPushWorkSheetRes **)soap_malloc(soap, sizeof(struct _ns1__getPushWorkSheetRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getPushWorkSheetRes *)soap_malloc(soap, sizeof(struct _ns1__getPushWorkSheetRes));
		soap_default__ns1__getPushWorkSheetRes(soap, *a);
		if (!(*a = soap_in__ns1__getPushWorkSheetRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPushWorkSheetRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPushWorkSheetRes, sizeof(struct _ns1__getPushWorkSheetRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPushWorkSheetRes(struct soap *soap, struct _ns1__getPushWorkSheetRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPushWorkSheetRes);
	if (soap_out_PointerTo_ns1__getPushWorkSheetRes(soap, tag?tag:"ns1:getPushWorkSheetRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPushWorkSheetRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPushWorkSheetRes(struct soap *soap, struct _ns1__getPushWorkSheetRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPushWorkSheetRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPushWorkSheetReq(struct soap *soap, struct _ns1__getPushWorkSheetReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPushWorkSheetReq))
		soap_serialize__ns1__getPushWorkSheetReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPushWorkSheetReq(struct soap *soap, const char *tag, int id, struct _ns1__getPushWorkSheetReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPushWorkSheetReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPushWorkSheetReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPushWorkSheetReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPushWorkSheetReq(struct soap *soap, const char *tag, struct _ns1__getPushWorkSheetReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPushWorkSheetReq **)soap_malloc(soap, sizeof(struct _ns1__getPushWorkSheetReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__getPushWorkSheetReq *)soap_malloc(soap, sizeof(struct _ns1__getPushWorkSheetReq));
		soap_default__ns1__getPushWorkSheetReq(soap, *a);
		if (!(*a = soap_in__ns1__getPushWorkSheetReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPushWorkSheetReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPushWorkSheetReq, sizeof(struct _ns1__getPushWorkSheetReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPushWorkSheetReq(struct soap *soap, struct _ns1__getPushWorkSheetReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPushWorkSheetReq);
	if (soap_out_PointerTo_ns1__getPushWorkSheetReq(soap, tag?tag:"ns1:getPushWorkSheetReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPushWorkSheetReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPushWorkSheetReq(struct soap *soap, struct _ns1__getPushWorkSheetReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPushWorkSheetReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__subscribeAndroidPushRes(struct soap *soap, struct _ns1__subscribeAndroidPushRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__subscribeAndroidPushRes))
		soap_serialize__ns1__subscribeAndroidPushRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__subscribeAndroidPushRes(struct soap *soap, const char *tag, int id, struct _ns1__subscribeAndroidPushRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__subscribeAndroidPushRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__subscribeAndroidPushRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__subscribeAndroidPushRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__subscribeAndroidPushRes(struct soap *soap, const char *tag, struct _ns1__subscribeAndroidPushRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__subscribeAndroidPushRes **)soap_malloc(soap, sizeof(struct _ns1__subscribeAndroidPushRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__subscribeAndroidPushRes *)soap_malloc(soap, sizeof(struct _ns1__subscribeAndroidPushRes));
		soap_default__ns1__subscribeAndroidPushRes(soap, *a);
		if (!(*a = soap_in__ns1__subscribeAndroidPushRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeAndroidPushRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__subscribeAndroidPushRes, sizeof(struct _ns1__subscribeAndroidPushRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__subscribeAndroidPushRes(struct soap *soap, struct _ns1__subscribeAndroidPushRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__subscribeAndroidPushRes);
	if (soap_out_PointerTo_ns1__subscribeAndroidPushRes(soap, tag?tag:"ns1:subscribeAndroidPushRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeAndroidPushRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__subscribeAndroidPushRes(struct soap *soap, struct _ns1__subscribeAndroidPushRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__subscribeAndroidPushRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__subscribeAndroidPushReq(struct soap *soap, struct _ns1__subscribeAndroidPushReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__subscribeAndroidPushReq))
		soap_serialize__ns1__subscribeAndroidPushReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__subscribeAndroidPushReq(struct soap *soap, const char *tag, int id, struct _ns1__subscribeAndroidPushReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__subscribeAndroidPushReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__subscribeAndroidPushReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__subscribeAndroidPushReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__subscribeAndroidPushReq(struct soap *soap, const char *tag, struct _ns1__subscribeAndroidPushReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__subscribeAndroidPushReq **)soap_malloc(soap, sizeof(struct _ns1__subscribeAndroidPushReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__subscribeAndroidPushReq *)soap_malloc(soap, sizeof(struct _ns1__subscribeAndroidPushReq));
		soap_default__ns1__subscribeAndroidPushReq(soap, *a);
		if (!(*a = soap_in__ns1__subscribeAndroidPushReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeAndroidPushReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__subscribeAndroidPushReq, sizeof(struct _ns1__subscribeAndroidPushReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__subscribeAndroidPushReq(struct soap *soap, struct _ns1__subscribeAndroidPushReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__subscribeAndroidPushReq);
	if (soap_out_PointerTo_ns1__subscribeAndroidPushReq(soap, tag?tag:"ns1:subscribeAndroidPushReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeAndroidPushReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__subscribeAndroidPushReq(struct soap *soap, struct _ns1__subscribeAndroidPushReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__subscribeAndroidPushReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__subscribeApplePushRes(struct soap *soap, struct _ns1__subscribeApplePushRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__subscribeApplePushRes))
		soap_serialize__ns1__subscribeApplePushRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__subscribeApplePushRes(struct soap *soap, const char *tag, int id, struct _ns1__subscribeApplePushRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__subscribeApplePushRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__subscribeApplePushRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__subscribeApplePushRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__subscribeApplePushRes(struct soap *soap, const char *tag, struct _ns1__subscribeApplePushRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__subscribeApplePushRes **)soap_malloc(soap, sizeof(struct _ns1__subscribeApplePushRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__subscribeApplePushRes *)soap_malloc(soap, sizeof(struct _ns1__subscribeApplePushRes));
		soap_default__ns1__subscribeApplePushRes(soap, *a);
		if (!(*a = soap_in__ns1__subscribeApplePushRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeApplePushRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__subscribeApplePushRes, sizeof(struct _ns1__subscribeApplePushRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__subscribeApplePushRes(struct soap *soap, struct _ns1__subscribeApplePushRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__subscribeApplePushRes);
	if (soap_out_PointerTo_ns1__subscribeApplePushRes(soap, tag?tag:"ns1:subscribeApplePushRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeApplePushRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__subscribeApplePushRes(struct soap *soap, struct _ns1__subscribeApplePushRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__subscribeApplePushRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__subscribeApplePushReq(struct soap *soap, struct _ns1__subscribeApplePushReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__subscribeApplePushReq))
		soap_serialize__ns1__subscribeApplePushReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__subscribeApplePushReq(struct soap *soap, const char *tag, int id, struct _ns1__subscribeApplePushReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__subscribeApplePushReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__subscribeApplePushReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__subscribeApplePushReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__subscribeApplePushReq(struct soap *soap, const char *tag, struct _ns1__subscribeApplePushReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__subscribeApplePushReq **)soap_malloc(soap, sizeof(struct _ns1__subscribeApplePushReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct _ns1__subscribeApplePushReq *)soap_malloc(soap, sizeof(struct _ns1__subscribeApplePushReq));
		soap_default__ns1__subscribeApplePushReq(soap, *a);
		if (!(*a = soap_in__ns1__subscribeApplePushReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__subscribeApplePushReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__subscribeApplePushReq, sizeof(struct _ns1__subscribeApplePushReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__subscribeApplePushReq(struct soap *soap, struct _ns1__subscribeApplePushReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__subscribeApplePushReq);
	if (soap_out_PointerTo_ns1__subscribeApplePushReq(soap, tag?tag:"ns1:subscribeApplePushReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__subscribeApplePushReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__subscribeApplePushReq(struct soap *soap, struct _ns1__subscribeApplePushReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__subscribeApplePushReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__VODRecord(struct soap *soap, struct ns1__VODRecord *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__VODRecord))
		soap_serialize_ns1__VODRecord(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__VODRecord(struct soap *soap, const char *tag, int id, struct ns1__VODRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__VODRecord);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__VODRecord(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__VODRecord ** SOAP_FMAC4 soap_in_PointerTons1__VODRecord(struct soap *soap, const char *tag, struct ns1__VODRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__VODRecord **)soap_malloc(soap, sizeof(struct ns1__VODRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__VODRecord *)soap_malloc(soap, sizeof(struct ns1__VODRecord));
		soap_default_ns1__VODRecord(soap, *a);
		if (!(*a = soap_in_ns1__VODRecord(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__VODRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__VODRecord, sizeof(struct ns1__VODRecord), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__VODRecord(struct soap *soap, struct ns1__VODRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__VODRecord);
	if (soap_out_PointerTons1__VODRecord(soap, tag?tag:"ns1:VODRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VODRecord ** SOAP_FMAC4 soap_get_PointerTons1__VODRecord(struct soap *soap, struct ns1__VODRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__VODRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PrivacyMaskRegion(struct soap *soap, struct ns1__PrivacyMaskRegion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PrivacyMaskRegion))
		soap_serialize_ns1__PrivacyMaskRegion(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PrivacyMaskRegion(struct soap *soap, const char *tag, int id, struct ns1__PrivacyMaskRegion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PrivacyMaskRegion);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__PrivacyMaskRegion(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__PrivacyMaskRegion ** SOAP_FMAC4 soap_in_PointerTons1__PrivacyMaskRegion(struct soap *soap, const char *tag, struct ns1__PrivacyMaskRegion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__PrivacyMaskRegion **)soap_malloc(soap, sizeof(struct ns1__PrivacyMaskRegion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__PrivacyMaskRegion *)soap_malloc(soap, sizeof(struct ns1__PrivacyMaskRegion));
		soap_default_ns1__PrivacyMaskRegion(soap, *a);
		if (!(*a = soap_in_ns1__PrivacyMaskRegion(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__PrivacyMaskRegion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PrivacyMaskRegion, sizeof(struct ns1__PrivacyMaskRegion), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PrivacyMaskRegion(struct soap *soap, struct ns1__PrivacyMaskRegion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PrivacyMaskRegion);
	if (soap_out_PointerTons1__PrivacyMaskRegion(soap, tag?tag:"ns1:PrivacyMaskRegion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__PrivacyMaskRegion ** SOAP_FMAC4 soap_get_PointerTons1__PrivacyMaskRegion(struct soap *soap, struct ns1__PrivacyMaskRegion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PrivacyMaskRegion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__VMDGrid(struct soap *soap, struct ns1__VMDGrid *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__VMDGrid))
		soap_serialize_ns1__VMDGrid(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__VMDGrid(struct soap *soap, const char *tag, int id, struct ns1__VMDGrid *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__VMDGrid);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__VMDGrid(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__VMDGrid ** SOAP_FMAC4 soap_in_PointerTons1__VMDGrid(struct soap *soap, const char *tag, struct ns1__VMDGrid **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__VMDGrid **)soap_malloc(soap, sizeof(struct ns1__VMDGrid *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__VMDGrid *)soap_malloc(soap, sizeof(struct ns1__VMDGrid));
		soap_default_ns1__VMDGrid(soap, *a);
		if (!(*a = soap_in_ns1__VMDGrid(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__VMDGrid **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__VMDGrid, sizeof(struct ns1__VMDGrid), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__VMDGrid(struct soap *soap, struct ns1__VMDGrid *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__VMDGrid);
	if (soap_out_PointerTons1__VMDGrid(soap, tag?tag:"ns1:VMDGrid", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VMDGrid ** SOAP_FMAC4 soap_get_PointerTons1__VMDGrid(struct soap *soap, struct ns1__VMDGrid **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__VMDGrid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__VideoStandard(struct soap *soap, enum ns1__VideoStandard *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__VideoStandard);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__VideoStandard(struct soap *soap, const char *tag, int id, enum ns1__VideoStandard *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__VideoStandard);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__VideoStandard(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__VideoStandard ** SOAP_FMAC4 soap_in_PointerTons1__VideoStandard(struct soap *soap, const char *tag, enum ns1__VideoStandard **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__VideoStandard **)soap_malloc(soap, sizeof(enum ns1__VideoStandard *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__VideoStandard(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__VideoStandard **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__VideoStandard, sizeof(enum ns1__VideoStandard), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__VideoStandard(struct soap *soap, enum ns1__VideoStandard *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__VideoStandard);
	if (soap_out_PointerTons1__VideoStandard(soap, tag?tag:"ns1:VideoStandard", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__VideoStandard ** SOAP_FMAC4 soap_get_PointerTons1__VideoStandard(struct soap *soap, enum ns1__VideoStandard **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__VideoStandard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDevLog(struct soap *soap, struct ns1__ArrayOfDevLog *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfDevLog))
		soap_serialize_ns1__ArrayOfDevLog(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDevLog(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfDevLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfDevLog);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfDevLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfDevLog ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDevLog(struct soap *soap, const char *tag, struct ns1__ArrayOfDevLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfDevLog **)soap_malloc(soap, sizeof(struct ns1__ArrayOfDevLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__ArrayOfDevLog *)soap_malloc(soap, sizeof(struct ns1__ArrayOfDevLog));
		soap_default_ns1__ArrayOfDevLog(soap, *a);
		if (!(*a = soap_in_ns1__ArrayOfDevLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfDevLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDevLog, sizeof(struct ns1__ArrayOfDevLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDevLog(struct soap *soap, struct ns1__ArrayOfDevLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfDevLog);
	if (soap_out_PointerTons1__ArrayOfDevLog(soap, tag?tag:"ns1:ArrayOfDevLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfDevLog ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDevLog(struct soap *soap, struct ns1__ArrayOfDevLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDevLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfPuLog(struct soap *soap, struct ns1__ArrayOfPuLog *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfPuLog))
		soap_serialize_ns1__ArrayOfPuLog(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfPuLog(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfPuLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfPuLog);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfPuLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfPuLog ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfPuLog(struct soap *soap, const char *tag, struct ns1__ArrayOfPuLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfPuLog **)soap_malloc(soap, sizeof(struct ns1__ArrayOfPuLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__ArrayOfPuLog *)soap_malloc(soap, sizeof(struct ns1__ArrayOfPuLog));
		soap_default_ns1__ArrayOfPuLog(soap, *a);
		if (!(*a = soap_in_ns1__ArrayOfPuLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfPuLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfPuLog, sizeof(struct ns1__ArrayOfPuLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfPuLog(struct soap *soap, struct ns1__ArrayOfPuLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfPuLog);
	if (soap_out_PointerTons1__ArrayOfPuLog(soap, tag?tag:"ns1:ArrayOfPuLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfPuLog ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfPuLog(struct soap *soap, struct ns1__ArrayOfPuLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfPuLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RateType(struct soap *soap, enum ns1__RateType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__RateType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RateType(struct soap *soap, const char *tag, int id, enum ns1__RateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RateType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__RateType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__RateType ** SOAP_FMAC4 soap_in_PointerTons1__RateType(struct soap *soap, const char *tag, enum ns1__RateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__RateType **)soap_malloc(soap, sizeof(enum ns1__RateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__RateType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__RateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RateType, sizeof(enum ns1__RateType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RateType(struct soap *soap, enum ns1__RateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__RateType);
	if (soap_out_PointerTons1__RateType(soap, tag?tag:"ns1:RateType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__RateType ** SOAP_FMAC4 soap_get_PointerTons1__RateType(struct soap *soap, enum ns1__RateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FrameSize(struct soap *soap, enum ns1__FrameSize *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__FrameSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FrameSize(struct soap *soap, const char *tag, int id, enum ns1__FrameSize *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FrameSize);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FrameSize(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__FrameSize ** SOAP_FMAC4 soap_in_PointerTons1__FrameSize(struct soap *soap, const char *tag, enum ns1__FrameSize **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__FrameSize **)soap_malloc(soap, sizeof(enum ns1__FrameSize *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FrameSize(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__FrameSize **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FrameSize, sizeof(enum ns1__FrameSize), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FrameSize(struct soap *soap, enum ns1__FrameSize *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__FrameSize);
	if (soap_out_PointerTons1__FrameSize(soap, tag?tag:"ns1:FrameSize", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__FrameSize ** SOAP_FMAC4 soap_get_PointerTons1__FrameSize(struct soap *soap, enum ns1__FrameSize **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FrameSize(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDevice(struct soap *soap, struct ns1__ArrayOfDevice *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfDevice))
		soap_serialize_ns1__ArrayOfDevice(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDevice(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfDevice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfDevice);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfDevice(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfDevice ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDevice(struct soap *soap, const char *tag, struct ns1__ArrayOfDevice **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfDevice **)soap_malloc(soap, sizeof(struct ns1__ArrayOfDevice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__ArrayOfDevice *)soap_malloc(soap, sizeof(struct ns1__ArrayOfDevice));
		soap_default_ns1__ArrayOfDevice(soap, *a);
		if (!(*a = soap_in_ns1__ArrayOfDevice(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfDevice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDevice, sizeof(struct ns1__ArrayOfDevice), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDevice(struct soap *soap, struct ns1__ArrayOfDevice *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfDevice);
	if (soap_out_PointerTons1__ArrayOfDevice(soap, tag?tag:"ns1:ArrayOfDevice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfDevice ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDevice(struct soap *soap, struct ns1__ArrayOfDevice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDeviceSharer(struct soap *soap, struct ns1__ArrayOfDeviceSharer *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfDeviceSharer))
		soap_serialize_ns1__ArrayOfDeviceSharer(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDeviceSharer(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfDeviceSharer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfDeviceSharer);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfDeviceSharer(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfDeviceSharer ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDeviceSharer(struct soap *soap, const char *tag, struct ns1__ArrayOfDeviceSharer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfDeviceSharer **)soap_malloc(soap, sizeof(struct ns1__ArrayOfDeviceSharer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__ArrayOfDeviceSharer *)soap_malloc(soap, sizeof(struct ns1__ArrayOfDeviceSharer));
		soap_default_ns1__ArrayOfDeviceSharer(soap, *a);
		if (!(*a = soap_in_ns1__ArrayOfDeviceSharer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfDeviceSharer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDeviceSharer, sizeof(struct ns1__ArrayOfDeviceSharer), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDeviceSharer(struct soap *soap, struct ns1__ArrayOfDeviceSharer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfDeviceSharer);
	if (soap_out_PointerTons1__ArrayOfDeviceSharer(soap, tag?tag:"ns1:ArrayOfDeviceSharer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfDeviceSharer ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDeviceSharer(struct soap *soap, struct ns1__ArrayOfDeviceSharer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDeviceSharer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfPUEventLog(struct soap *soap, struct ns1__ArrayOfPUEventLog *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfPUEventLog))
		soap_serialize_ns1__ArrayOfPUEventLog(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfPUEventLog(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfPUEventLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfPUEventLog);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfPUEventLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfPUEventLog ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfPUEventLog(struct soap *soap, const char *tag, struct ns1__ArrayOfPUEventLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfPUEventLog **)soap_malloc(soap, sizeof(struct ns1__ArrayOfPUEventLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__ArrayOfPUEventLog *)soap_malloc(soap, sizeof(struct ns1__ArrayOfPUEventLog));
		soap_default_ns1__ArrayOfPUEventLog(soap, *a);
		if (!(*a = soap_in_ns1__ArrayOfPUEventLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfPUEventLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfPUEventLog, sizeof(struct ns1__ArrayOfPUEventLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfPUEventLog(struct soap *soap, struct ns1__ArrayOfPUEventLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfPUEventLog);
	if (soap_out_PointerTons1__ArrayOfPUEventLog(soap, tag?tag:"ns1:ArrayOfPUEventLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfPUEventLog ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfPUEventLog(struct soap *soap, struct ns1__ArrayOfPUEventLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfPUEventLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EventState(struct soap *soap, enum ns1__EventState *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__EventState);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EventState(struct soap *soap, const char *tag, int id, enum ns1__EventState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EventState);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__EventState(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__EventState ** SOAP_FMAC4 soap_in_PointerTons1__EventState(struct soap *soap, const char *tag, enum ns1__EventState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__EventState **)soap_malloc(soap, sizeof(enum ns1__EventState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__EventState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__EventState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EventState, sizeof(enum ns1__EventState), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EventState(struct soap *soap, enum ns1__EventState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__EventState);
	if (soap_out_PointerTons1__EventState(soap, tag?tag:"ns1:EventState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__EventState ** SOAP_FMAC4 soap_get_PointerTons1__EventState(struct soap *soap, enum ns1__EventState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EventState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EventType(struct soap *soap, enum ns1__EventType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__EventType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EventType(struct soap *soap, const char *tag, int id, enum ns1__EventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EventType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__EventType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__EventType ** SOAP_FMAC4 soap_in_PointerTons1__EventType(struct soap *soap, const char *tag, enum ns1__EventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__EventType **)soap_malloc(soap, sizeof(enum ns1__EventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__EventType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__EventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EventType, sizeof(enum ns1__EventType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EventType(struct soap *soap, enum ns1__EventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__EventType);
	if (soap_out_PointerTons1__EventType(soap, tag?tag:"ns1:EventType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__EventType ** SOAP_FMAC4 soap_get_PointerTons1__EventType(struct soap *soap, enum ns1__EventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfPUOnOffLog(struct soap *soap, struct ns1__ArrayOfPUOnOffLog *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfPUOnOffLog))
		soap_serialize_ns1__ArrayOfPUOnOffLog(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfPUOnOffLog(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfPUOnOffLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfPUOnOffLog);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfPUOnOffLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfPUOnOffLog ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfPUOnOffLog(struct soap *soap, const char *tag, struct ns1__ArrayOfPUOnOffLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfPUOnOffLog **)soap_malloc(soap, sizeof(struct ns1__ArrayOfPUOnOffLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__ArrayOfPUOnOffLog *)soap_malloc(soap, sizeof(struct ns1__ArrayOfPUOnOffLog));
		soap_default_ns1__ArrayOfPUOnOffLog(soap, *a);
		if (!(*a = soap_in_ns1__ArrayOfPUOnOffLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfPUOnOffLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfPUOnOffLog, sizeof(struct ns1__ArrayOfPUOnOffLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfPUOnOffLog(struct soap *soap, struct ns1__ArrayOfPUOnOffLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfPUOnOffLog);
	if (soap_out_PointerTons1__ArrayOfPUOnOffLog(soap, tag?tag:"ns1:ArrayOfPUOnOffLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfPUOnOffLog ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfPUOnOffLog(struct soap *soap, struct ns1__ArrayOfPUOnOffLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfPUOnOffLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTURNServer(struct soap *soap, struct ns1__ArrayOfTURNServer *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfTURNServer))
		soap_serialize_ns1__ArrayOfTURNServer(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTURNServer(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfTURNServer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfTURNServer);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfTURNServer(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfTURNServer ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTURNServer(struct soap *soap, const char *tag, struct ns1__ArrayOfTURNServer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfTURNServer **)soap_malloc(soap, sizeof(struct ns1__ArrayOfTURNServer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__ArrayOfTURNServer *)soap_malloc(soap, sizeof(struct ns1__ArrayOfTURNServer));
		soap_default_ns1__ArrayOfTURNServer(soap, *a);
		if (!(*a = soap_in_ns1__ArrayOfTURNServer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfTURNServer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfTURNServer, sizeof(struct ns1__ArrayOfTURNServer), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTURNServer(struct soap *soap, struct ns1__ArrayOfTURNServer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfTURNServer);
	if (soap_out_PointerTons1__ArrayOfTURNServer(soap, tag?tag:"ns1:ArrayOfTURNServer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfTURNServer ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTURNServer(struct soap *soap, struct ns1__ArrayOfTURNServer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTURNServer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSTUNServer(struct soap *soap, struct ns1__ArrayOfSTUNServer *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSTUNServer))
		soap_serialize_ns1__ArrayOfSTUNServer(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSTUNServer(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfSTUNServer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSTUNServer);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfSTUNServer(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfSTUNServer ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSTUNServer(struct soap *soap, const char *tag, struct ns1__ArrayOfSTUNServer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfSTUNServer **)soap_malloc(soap, sizeof(struct ns1__ArrayOfSTUNServer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__ArrayOfSTUNServer *)soap_malloc(soap, sizeof(struct ns1__ArrayOfSTUNServer));
		soap_default_ns1__ArrayOfSTUNServer(soap, *a);
		if (!(*a = soap_in_ns1__ArrayOfSTUNServer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfSTUNServer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSTUNServer, sizeof(struct ns1__ArrayOfSTUNServer), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSTUNServer(struct soap *soap, struct ns1__ArrayOfSTUNServer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSTUNServer);
	if (soap_out_PointerTons1__ArrayOfSTUNServer(soap, tag?tag:"ns1:ArrayOfSTUNServer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfSTUNServer ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSTUNServer(struct soap *soap, struct ns1__ArrayOfSTUNServer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSTUNServer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AuxiliaryType(struct soap *soap, enum ns1__AuxiliaryType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__AuxiliaryType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AuxiliaryType(struct soap *soap, const char *tag, int id, enum ns1__AuxiliaryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AuxiliaryType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__AuxiliaryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__AuxiliaryType ** SOAP_FMAC4 soap_in_PointerTons1__AuxiliaryType(struct soap *soap, const char *tag, enum ns1__AuxiliaryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__AuxiliaryType **)soap_malloc(soap, sizeof(enum ns1__AuxiliaryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__AuxiliaryType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__AuxiliaryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AuxiliaryType, sizeof(enum ns1__AuxiliaryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AuxiliaryType(struct soap *soap, enum ns1__AuxiliaryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AuxiliaryType);
	if (soap_out_PointerTons1__AuxiliaryType(soap, tag?tag:"ns1:AuxiliaryType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__AuxiliaryType ** SOAP_FMAC4 soap_get_PointerTons1__AuxiliaryType(struct soap *soap, enum ns1__AuxiliaryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AuxiliaryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AuxiliaryState(struct soap *soap, enum ns1__AuxiliaryState *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__AuxiliaryState);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AuxiliaryState(struct soap *soap, const char *tag, int id, enum ns1__AuxiliaryState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AuxiliaryState);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__AuxiliaryState(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__AuxiliaryState ** SOAP_FMAC4 soap_in_PointerTons1__AuxiliaryState(struct soap *soap, const char *tag, enum ns1__AuxiliaryState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__AuxiliaryState **)soap_malloc(soap, sizeof(enum ns1__AuxiliaryState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__AuxiliaryState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__AuxiliaryState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AuxiliaryState, sizeof(enum ns1__AuxiliaryState), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AuxiliaryState(struct soap *soap, enum ns1__AuxiliaryState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AuxiliaryState);
	if (soap_out_PointerTons1__AuxiliaryState(soap, tag?tag:"ns1:AuxiliaryState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__AuxiliaryState ** SOAP_FMAC4 soap_get_PointerTons1__AuxiliaryState(struct soap *soap, enum ns1__AuxiliaryState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AuxiliaryState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfNodeDetails(struct soap *soap, struct ns1__ArrayOfNodeDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfNodeDetails))
		soap_serialize_ns1__ArrayOfNodeDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfNodeDetails(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfNodeDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfNodeDetails);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfNodeDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfNodeDetails ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfNodeDetails(struct soap *soap, const char *tag, struct ns1__ArrayOfNodeDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfNodeDetails **)soap_malloc(soap, sizeof(struct ns1__ArrayOfNodeDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__ArrayOfNodeDetails *)soap_malloc(soap, sizeof(struct ns1__ArrayOfNodeDetails));
		soap_default_ns1__ArrayOfNodeDetails(soap, *a);
		if (!(*a = soap_in_ns1__ArrayOfNodeDetails(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfNodeDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfNodeDetails, sizeof(struct ns1__ArrayOfNodeDetails), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfNodeDetails(struct soap *soap, struct ns1__ArrayOfNodeDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfNodeDetails);
	if (soap_out_PointerTons1__ArrayOfNodeDetails(soap, tag?tag:"ns1:ArrayOfNodeDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfNodeDetails ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfNodeDetails(struct soap *soap, struct ns1__ArrayOfNodeDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfNodeDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CountryAbbr2ISO3166(struct soap *soap, enum ns1__CountryAbbr2ISO3166 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__CountryAbbr2ISO3166);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CountryAbbr2ISO3166(struct soap *soap, const char *tag, int id, enum ns1__CountryAbbr2ISO3166 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CountryAbbr2ISO3166);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__CountryAbbr2ISO3166(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__CountryAbbr2ISO3166 ** SOAP_FMAC4 soap_in_PointerTons1__CountryAbbr2ISO3166(struct soap *soap, const char *tag, enum ns1__CountryAbbr2ISO3166 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__CountryAbbr2ISO3166 **)soap_malloc(soap, sizeof(enum ns1__CountryAbbr2ISO3166 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__CountryAbbr2ISO3166(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__CountryAbbr2ISO3166 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CountryAbbr2ISO3166, sizeof(enum ns1__CountryAbbr2ISO3166), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CountryAbbr2ISO3166(struct soap *soap, enum ns1__CountryAbbr2ISO3166 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CountryAbbr2ISO3166);
	if (soap_out_PointerTons1__CountryAbbr2ISO3166(soap, tag?tag:"ns1:CountryAbbr2ISO3166", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__CountryAbbr2ISO3166 ** SOAP_FMAC4 soap_get_PointerTons1__CountryAbbr2ISO3166(struct soap *soap, enum ns1__CountryAbbr2ISO3166 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CountryAbbr2ISO3166(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfNotice(struct soap *soap, struct ns1__ArrayOfNotice *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfNotice))
		soap_serialize_ns1__ArrayOfNotice(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfNotice(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfNotice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfNotice);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfNotice(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfNotice ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfNotice(struct soap *soap, const char *tag, struct ns1__ArrayOfNotice **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfNotice **)soap_malloc(soap, sizeof(struct ns1__ArrayOfNotice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__ArrayOfNotice *)soap_malloc(soap, sizeof(struct ns1__ArrayOfNotice));
		soap_default_ns1__ArrayOfNotice(soap, *a);
		if (!(*a = soap_in_ns1__ArrayOfNotice(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfNotice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfNotice, sizeof(struct ns1__ArrayOfNotice), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfNotice(struct soap *soap, struct ns1__ArrayOfNotice *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfNotice);
	if (soap_out_PointerTons1__ArrayOfNotice(soap, tag?tag:"ns1:ArrayOfNotice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfNotice ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfNotice(struct soap *soap, struct ns1__ArrayOfNotice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfNotice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NoticeStatus(struct soap *soap, enum ns1__NoticeStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__NoticeStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NoticeStatus(struct soap *soap, const char *tag, int id, enum ns1__NoticeStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NoticeStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__NoticeStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__NoticeStatus ** SOAP_FMAC4 soap_in_PointerTons1__NoticeStatus(struct soap *soap, const char *tag, enum ns1__NoticeStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__NoticeStatus **)soap_malloc(soap, sizeof(enum ns1__NoticeStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__NoticeStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__NoticeStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NoticeStatus, sizeof(enum ns1__NoticeStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NoticeStatus(struct soap *soap, enum ns1__NoticeStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__NoticeStatus);
	if (soap_out_PointerTons1__NoticeStatus(soap, tag?tag:"ns1:NoticeStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__NoticeStatus ** SOAP_FMAC4 soap_get_PointerTons1__NoticeStatus(struct soap *soap, enum ns1__NoticeStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NoticeStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Relay(struct soap *soap, struct ns1__Relay *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Relay))
		soap_serialize_ns1__Relay(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Relay(struct soap *soap, const char *tag, int id, struct ns1__Relay *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Relay);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Relay(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Relay ** SOAP_FMAC4 soap_in_PointerTons1__Relay(struct soap *soap, const char *tag, struct ns1__Relay **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Relay **)soap_malloc(soap, sizeof(struct ns1__Relay *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__Relay *)soap_malloc(soap, sizeof(struct ns1__Relay));
		soap_default_ns1__Relay(soap, *a);
		if (!(*a = soap_in_ns1__Relay(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Relay **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Relay, sizeof(struct ns1__Relay), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Relay(struct soap *soap, struct ns1__Relay *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Relay);
	if (soap_out_PointerTons1__Relay(soap, tag?tag:"ns1:Relay", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Relay ** SOAP_FMAC4 soap_get_PointerTons1__Relay(struct soap *soap, struct ns1__Relay **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Relay(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__WorkSheet(struct soap *soap, struct ns1__WorkSheet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__WorkSheet))
		soap_serialize_ns1__WorkSheet(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__WorkSheet(struct soap *soap, const char *tag, int id, struct ns1__WorkSheet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__WorkSheet);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__WorkSheet(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__WorkSheet ** SOAP_FMAC4 soap_in_PointerTons1__WorkSheet(struct soap *soap, const char *tag, struct ns1__WorkSheet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__WorkSheet **)soap_malloc(soap, sizeof(struct ns1__WorkSheet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__WorkSheet *)soap_malloc(soap, sizeof(struct ns1__WorkSheet));
		soap_default_ns1__WorkSheet(soap, *a);
		if (!(*a = soap_in_ns1__WorkSheet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__WorkSheet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__WorkSheet, sizeof(struct ns1__WorkSheet), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__WorkSheet(struct soap *soap, struct ns1__WorkSheet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__WorkSheet);
	if (soap_out_PointerTons1__WorkSheet(soap, tag?tag:"ns1:WorkSheet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__WorkSheet ** SOAP_FMAC4 soap_get_PointerTons1__WorkSheet(struct soap *soap, struct ns1__WorkSheet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__WorkSheet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DevLog(struct soap *soap, struct ns1__DevLog *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DevLog))
		soap_serialize_ns1__DevLog(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DevLog(struct soap *soap, const char *tag, int id, struct ns1__DevLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DevLog);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__DevLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__DevLog ** SOAP_FMAC4 soap_in_PointerTons1__DevLog(struct soap *soap, const char *tag, struct ns1__DevLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__DevLog **)soap_malloc(soap, sizeof(struct ns1__DevLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__DevLog *)soap_malloc(soap, sizeof(struct ns1__DevLog));
		soap_default_ns1__DevLog(soap, *a);
		if (!(*a = soap_in_ns1__DevLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__DevLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DevLog, sizeof(struct ns1__DevLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DevLog(struct soap *soap, struct ns1__DevLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DevLog);
	if (soap_out_PointerTons1__DevLog(soap, tag?tag:"ns1:DevLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DevLog ** SOAP_FMAC4 soap_get_PointerTons1__DevLog(struct soap *soap, struct ns1__DevLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DevLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PuLog(struct soap *soap, struct ns1__PuLog *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PuLog))
		soap_serialize_ns1__PuLog(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PuLog(struct soap *soap, const char *tag, int id, struct ns1__PuLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PuLog);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__PuLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__PuLog ** SOAP_FMAC4 soap_in_PointerTons1__PuLog(struct soap *soap, const char *tag, struct ns1__PuLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__PuLog **)soap_malloc(soap, sizeof(struct ns1__PuLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__PuLog *)soap_malloc(soap, sizeof(struct ns1__PuLog));
		soap_default_ns1__PuLog(soap, *a);
		if (!(*a = soap_in_ns1__PuLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__PuLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PuLog, sizeof(struct ns1__PuLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PuLog(struct soap *soap, struct ns1__PuLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PuLog);
	if (soap_out_PointerTons1__PuLog(soap, tag?tag:"ns1:PuLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__PuLog ** SOAP_FMAC4 soap_get_PointerTons1__PuLog(struct soap *soap, struct ns1__PuLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PuLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Device(struct soap *soap, struct ns1__Device *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Device))
		soap_serialize_ns1__Device(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Device(struct soap *soap, const char *tag, int id, struct ns1__Device *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Device);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Device(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Device ** SOAP_FMAC4 soap_in_PointerTons1__Device(struct soap *soap, const char *tag, struct ns1__Device **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Device **)soap_malloc(soap, sizeof(struct ns1__Device *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__Device *)soap_malloc(soap, sizeof(struct ns1__Device));
		soap_default_ns1__Device(soap, *a);
		if (!(*a = soap_in_ns1__Device(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Device **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Device, sizeof(struct ns1__Device), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Device(struct soap *soap, struct ns1__Device *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Device);
	if (soap_out_PointerTons1__Device(soap, tag?tag:"ns1:Device", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Device ** SOAP_FMAC4 soap_get_PointerTons1__Device(struct soap *soap, struct ns1__Device **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Device(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DeviceSharer(struct soap *soap, struct ns1__DeviceSharer *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DeviceSharer))
		soap_serialize_ns1__DeviceSharer(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DeviceSharer(struct soap *soap, const char *tag, int id, struct ns1__DeviceSharer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DeviceSharer);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__DeviceSharer(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__DeviceSharer ** SOAP_FMAC4 soap_in_PointerTons1__DeviceSharer(struct soap *soap, const char *tag, struct ns1__DeviceSharer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__DeviceSharer **)soap_malloc(soap, sizeof(struct ns1__DeviceSharer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__DeviceSharer *)soap_malloc(soap, sizeof(struct ns1__DeviceSharer));
		soap_default_ns1__DeviceSharer(soap, *a);
		if (!(*a = soap_in_ns1__DeviceSharer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__DeviceSharer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DeviceSharer, sizeof(struct ns1__DeviceSharer), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DeviceSharer(struct soap *soap, struct ns1__DeviceSharer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DeviceSharer);
	if (soap_out_PointerTons1__DeviceSharer(soap, tag?tag:"ns1:DeviceSharer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeviceSharer ** SOAP_FMAC4 soap_get_PointerTons1__DeviceSharer(struct soap *soap, struct ns1__DeviceSharer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DeviceSharer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PUEventLog(struct soap *soap, struct ns1__PUEventLog *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PUEventLog))
		soap_serialize_ns1__PUEventLog(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PUEventLog(struct soap *soap, const char *tag, int id, struct ns1__PUEventLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PUEventLog);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__PUEventLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__PUEventLog ** SOAP_FMAC4 soap_in_PointerTons1__PUEventLog(struct soap *soap, const char *tag, struct ns1__PUEventLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__PUEventLog **)soap_malloc(soap, sizeof(struct ns1__PUEventLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__PUEventLog *)soap_malloc(soap, sizeof(struct ns1__PUEventLog));
		soap_default_ns1__PUEventLog(soap, *a);
		if (!(*a = soap_in_ns1__PUEventLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__PUEventLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PUEventLog, sizeof(struct ns1__PUEventLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PUEventLog(struct soap *soap, struct ns1__PUEventLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PUEventLog);
	if (soap_out_PointerTons1__PUEventLog(soap, tag?tag:"ns1:PUEventLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__PUEventLog ** SOAP_FMAC4 soap_get_PointerTons1__PUEventLog(struct soap *soap, struct ns1__PUEventLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PUEventLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PUOnOffLog(struct soap *soap, struct ns1__PUOnOffLog *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PUOnOffLog))
		soap_serialize_ns1__PUOnOffLog(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PUOnOffLog(struct soap *soap, const char *tag, int id, struct ns1__PUOnOffLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PUOnOffLog);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__PUOnOffLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__PUOnOffLog ** SOAP_FMAC4 soap_in_PointerTons1__PUOnOffLog(struct soap *soap, const char *tag, struct ns1__PUOnOffLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__PUOnOffLog **)soap_malloc(soap, sizeof(struct ns1__PUOnOffLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__PUOnOffLog *)soap_malloc(soap, sizeof(struct ns1__PUOnOffLog));
		soap_default_ns1__PUOnOffLog(soap, *a);
		if (!(*a = soap_in_ns1__PUOnOffLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__PUOnOffLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PUOnOffLog, sizeof(struct ns1__PUOnOffLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PUOnOffLog(struct soap *soap, struct ns1__PUOnOffLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PUOnOffLog);
	if (soap_out_PointerTons1__PUOnOffLog(soap, tag?tag:"ns1:PUOnOffLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__PUOnOffLog ** SOAP_FMAC4 soap_get_PointerTons1__PUOnOffLog(struct soap *soap, struct ns1__PUOnOffLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PUOnOffLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TURNServer(struct soap *soap, struct ns1__TURNServer *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TURNServer))
		soap_serialize_ns1__TURNServer(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TURNServer(struct soap *soap, const char *tag, int id, struct ns1__TURNServer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TURNServer);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TURNServer(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TURNServer ** SOAP_FMAC4 soap_in_PointerTons1__TURNServer(struct soap *soap, const char *tag, struct ns1__TURNServer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TURNServer **)soap_malloc(soap, sizeof(struct ns1__TURNServer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__TURNServer *)soap_malloc(soap, sizeof(struct ns1__TURNServer));
		soap_default_ns1__TURNServer(soap, *a);
		if (!(*a = soap_in_ns1__TURNServer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TURNServer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TURNServer, sizeof(struct ns1__TURNServer), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TURNServer(struct soap *soap, struct ns1__TURNServer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TURNServer);
	if (soap_out_PointerTons1__TURNServer(soap, tag?tag:"ns1:TURNServer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TURNServer ** SOAP_FMAC4 soap_get_PointerTons1__TURNServer(struct soap *soap, struct ns1__TURNServer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TURNServer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__STUNServer(struct soap *soap, struct ns1__STUNServer *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__STUNServer))
		soap_serialize_ns1__STUNServer(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__STUNServer(struct soap *soap, const char *tag, int id, struct ns1__STUNServer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__STUNServer);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__STUNServer(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__STUNServer ** SOAP_FMAC4 soap_in_PointerTons1__STUNServer(struct soap *soap, const char *tag, struct ns1__STUNServer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__STUNServer **)soap_malloc(soap, sizeof(struct ns1__STUNServer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__STUNServer *)soap_malloc(soap, sizeof(struct ns1__STUNServer));
		soap_default_ns1__STUNServer(soap, *a);
		if (!(*a = soap_in_ns1__STUNServer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__STUNServer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__STUNServer, sizeof(struct ns1__STUNServer), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__STUNServer(struct soap *soap, struct ns1__STUNServer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__STUNServer);
	if (soap_out_PointerTons1__STUNServer(soap, tag?tag:"ns1:STUNServer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__STUNServer ** SOAP_FMAC4 soap_get_PointerTons1__STUNServer(struct soap *soap, struct ns1__STUNServer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__STUNServer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__WirelessNetwork(struct soap *soap, struct ns1__WirelessNetwork *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__WirelessNetwork))
		soap_serialize_ns1__WirelessNetwork(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__WirelessNetwork(struct soap *soap, const char *tag, int id, struct ns1__WirelessNetwork *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__WirelessNetwork);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__WirelessNetwork(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__WirelessNetwork ** SOAP_FMAC4 soap_in_PointerTons1__WirelessNetwork(struct soap *soap, const char *tag, struct ns1__WirelessNetwork **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__WirelessNetwork **)soap_malloc(soap, sizeof(struct ns1__WirelessNetwork *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__WirelessNetwork *)soap_malloc(soap, sizeof(struct ns1__WirelessNetwork));
		soap_default_ns1__WirelessNetwork(soap, *a);
		if (!(*a = soap_in_ns1__WirelessNetwork(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__WirelessNetwork **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__WirelessNetwork, sizeof(struct ns1__WirelessNetwork), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__WirelessNetwork(struct soap *soap, struct ns1__WirelessNetwork *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__WirelessNetwork);
	if (soap_out_PointerTons1__WirelessNetwork(soap, tag?tag:"ns1:WirelessNetwork", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__WirelessNetwork ** SOAP_FMAC4 soap_get_PointerTons1__WirelessNetwork(struct soap *soap, struct ns1__WirelessNetwork **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__WirelessNetwork(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NodeDetails(struct soap *soap, struct ns1__NodeDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NodeDetails))
		soap_serialize_ns1__NodeDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NodeDetails(struct soap *soap, const char *tag, int id, struct ns1__NodeDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NodeDetails);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__NodeDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__NodeDetails ** SOAP_FMAC4 soap_in_PointerTons1__NodeDetails(struct soap *soap, const char *tag, struct ns1__NodeDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__NodeDetails **)soap_malloc(soap, sizeof(struct ns1__NodeDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__NodeDetails *)soap_malloc(soap, sizeof(struct ns1__NodeDetails));
		soap_default_ns1__NodeDetails(soap, *a);
		if (!(*a = soap_in_ns1__NodeDetails(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__NodeDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NodeDetails, sizeof(struct ns1__NodeDetails), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NodeDetails(struct soap *soap, struct ns1__NodeDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__NodeDetails);
	if (soap_out_PointerTons1__NodeDetails(soap, tag?tag:"ns1:NodeDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__NodeDetails ** SOAP_FMAC4 soap_get_PointerTons1__NodeDetails(struct soap *soap, struct ns1__NodeDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NodeDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfString(struct soap *soap, struct ns1__ArrayOfString *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfString))
		soap_serialize_ns1__ArrayOfString(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfString);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfString(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfString ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, struct ns1__ArrayOfString **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfString **)soap_malloc(soap, sizeof(struct ns1__ArrayOfString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__ArrayOfString *)soap_malloc(soap, sizeof(struct ns1__ArrayOfString));
		soap_default_ns1__ArrayOfString(soap, *a);
		if (!(*a = soap_in_ns1__ArrayOfString(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfString, sizeof(struct ns1__ArrayOfString), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfString(struct soap *soap, struct ns1__ArrayOfString *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfString);
	if (soap_out_PointerTons1__ArrayOfString(soap, tag?tag:"ns1:ArrayOfString", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfString ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfString(struct soap *soap, struct ns1__ArrayOfString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Notice(struct soap *soap, struct ns1__Notice *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Notice))
		soap_serialize_ns1__Notice(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Notice(struct soap *soap, const char *tag, int id, struct ns1__Notice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Notice);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Notice(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Notice ** SOAP_FMAC4 soap_in_PointerTons1__Notice(struct soap *soap, const char *tag, struct ns1__Notice **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Notice **)soap_malloc(soap, sizeof(struct ns1__Notice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__Notice *)soap_malloc(soap, sizeof(struct ns1__Notice));
		soap_default_ns1__Notice(soap, *a);
		if (!(*a = soap_in_ns1__Notice(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Notice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Notice, sizeof(struct ns1__Notice), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Notice(struct soap *soap, struct ns1__Notice *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Notice);
	if (soap_out_PointerTons1__Notice(soap, tag?tag:"ns1:Notice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Notice ** SOAP_FMAC4 soap_get_PointerTons1__Notice(struct soap *soap, struct ns1__Notice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Notice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Dev(struct soap *soap, struct ns1__Dev *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Dev))
		soap_serialize_ns1__Dev(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Dev(struct soap *soap, const char *tag, int id, struct ns1__Dev *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Dev);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Dev(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Dev ** SOAP_FMAC4 soap_in_PointerTons1__Dev(struct soap *soap, const char *tag, struct ns1__Dev **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Dev **)soap_malloc(soap, sizeof(struct ns1__Dev *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__Dev *)soap_malloc(soap, sizeof(struct ns1__Dev));
		soap_default_ns1__Dev(soap, *a);
		if (!(*a = soap_in_ns1__Dev(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Dev **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Dev, sizeof(struct ns1__Dev), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Dev(struct soap *soap, struct ns1__Dev *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Dev);
	if (soap_out_PointerTons1__Dev(soap, tag?tag:"ns1:Dev", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Dev ** SOAP_FMAC4 soap_get_PointerTons1__Dev(struct soap *soap, struct ns1__Dev **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Dev(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDev(struct soap *soap, struct ns1__ArrayOfDev *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfDev))
		soap_serialize_ns1__ArrayOfDev(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDev(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfDev *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfDev);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfDev(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfDev ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDev(struct soap *soap, const char *tag, struct ns1__ArrayOfDev **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfDev **)soap_malloc(soap, sizeof(struct ns1__ArrayOfDev *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__ArrayOfDev *)soap_malloc(soap, sizeof(struct ns1__ArrayOfDev));
		soap_default_ns1__ArrayOfDev(soap, *a);
		if (!(*a = soap_in_ns1__ArrayOfDev(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfDev **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDev, sizeof(struct ns1__ArrayOfDev), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDev(struct soap *soap, struct ns1__ArrayOfDev *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfDev);
	if (soap_out_PointerTons1__ArrayOfDev(soap, tag?tag:"ns1:ArrayOfDev", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfDev ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDev(struct soap *soap, struct ns1__ArrayOfDev **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDev(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MCUDev(struct soap *soap, struct ns1__MCUDev *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MCUDev))
		soap_serialize_ns1__MCUDev(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MCUDev(struct soap *soap, const char *tag, int id, struct ns1__MCUDev *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MCUDev);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__MCUDev(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__MCUDev ** SOAP_FMAC4 soap_in_PointerTons1__MCUDev(struct soap *soap, const char *tag, struct ns1__MCUDev **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__MCUDev **)soap_malloc(soap, sizeof(struct ns1__MCUDev *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct ns1__MCUDev *)soap_malloc(soap, sizeof(struct ns1__MCUDev));
		soap_default_ns1__MCUDev(soap, *a);
		if (!(*a = soap_in_ns1__MCUDev(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__MCUDev **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MCUDev, sizeof(struct ns1__MCUDev), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MCUDev(struct soap *soap, struct ns1__MCUDev *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MCUDev);
	if (soap_out_PointerTons1__MCUDev(soap, tag?tag:"ns1:MCUDev", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__MCUDev ** SOAP_FMAC4 soap_get_PointerTons1__MCUDev(struct soap *soap, struct ns1__MCUDev **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MCUDev(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RelayState(struct soap *soap, enum ns1__RelayState *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__RelayState);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RelayState(struct soap *soap, const char *tag, int id, enum ns1__RelayState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RelayState);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__RelayState(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__RelayState ** SOAP_FMAC4 soap_in_PointerTons1__RelayState(struct soap *soap, const char *tag, enum ns1__RelayState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__RelayState **)soap_malloc(soap, sizeof(enum ns1__RelayState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__RelayState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__RelayState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RelayState, sizeof(enum ns1__RelayState), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RelayState(struct soap *soap, enum ns1__RelayState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__RelayState);
	if (soap_out_PointerTons1__RelayState(soap, tag?tag:"ns1:RelayState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__RelayState ** SOAP_FMAC4 soap_get_PointerTons1__RelayState(struct soap *soap, enum ns1__RelayState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RelayState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean);
	if (soap_out_PointerToxsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
